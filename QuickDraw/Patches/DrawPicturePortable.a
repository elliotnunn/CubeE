;
;	File:		DrawPicturePortable.a
;
;	Contains:	xxx put contents here xxx
;
;	Written by:	xxx put writers here xxx
;
;	Copyright:	Â© 1990 by Apple Computer, Inc., all rights reserved.
;
;   This file is used in these builds: BigBang Sys606
;
;	Change History (most recent first):
;
;		<18>	 4/10/91	KON		mrr, gbm,csd: Calculate numer and denom to 32-bits, and then
;									shift to make it fit in 15-bits if necessary. This fixes the
;									problem where text was not scaling uniformly in pictures.
;		<17>	  4/9/91	KON		csd: When reducing a picture, text would not reduce properly
;									since both numer and denom are small and the divide underflows.
;									The fix is not to reduce numer/denom if the picture is being
;									scaled down.
;		<16>	 3/23/91	KON		csd, WRKSHT#SAH-QD-58: ReduceD3D4 would hang because MapRatio
;									would return a zero result. I removed calls to MapRatio (since
;									ReduceD3D4 does the same work) and changed ReduceD3D4 so it
;									won't hang.
;		<15>	 3/22/91	KON		CSD, WRKSHT#7P-WA-054: Large text does not draw correctly since
;									fromRect scaled by numer/denom can overflow a word. A small
;									problem with the last fix was discovered when updating the color
;									versions.
;		<14>	 3/22/91	KON		CSD, WRKSHT#7P-WA-054: Large text does not draw correctly since
;									fromRect scaled by numer/denom can overflow a word.
;		<13>	 3/20/91	KON		gbm, BRC#SAH-QD-053: StdOpCodeProc sets the denom of a picture
;									created with OpenCPicture. This is a problem since DrawPicture
;									reduced numer/denom, and blasting denom to a large value makes
;									the fraction invalid. Now numer/denom are reduced only after the
;									header has been processed.
;		<12>	 3/13/91	JT		Added the glyph state opcode support to picture drawing drawing
;									under old QuickDraw. This opcode records the state of the Font
;									Manager and TrueType so text will be drawn the same on picture
;									playback as it was during picture recording. Code checked by KON
;									and BAL. BRC numbers 82651 and 79185. Worksheet number KON-022.
;		<11>	 2/15/91	KON		stb BRC #82511: PixMaps with nil color tables are not drawn
;									properly.
;		<10>	 1/14/91	KON		Reduce Numer and Denom by GCD when drawing a picture. These
;									overflow on higher DPI devices. [CEL]
;		 <9>	12/13/90	KON		Check for color table signature before throwing it away. [smc]
;		 <8>	 12/3/90	KON		Make pnSize scale so 1-pixel wide lines scale. [smc]
;		 <7>	 9/12/90	KON		Get pictures in sync with MacII and ci picture changes.
;		 <6>	 8/24/90	PKE		(per JT) Use new Script Mgr line layout values in GrafGlobals
;									instead of soon-to-be-obsolete values in Script Mgr globals.
;		 <5>	  8/2/90	gbm		get rid of a few more warnings
;		 <4>	 5/27/90	JT		Moved the saved script manager fields to the bottom of the
;									DrawPicture stack frame so we don't break up the picture state
;									record. Also made this patch not fall into the ROM since the
;									stack frame no longer matches. This costs us a few extra
;									instructions, but we leave the two reserved fields available in
;									the picture state record.
;		 <3>	  5/2/90	JT		Copied the Script Manager specific changes from DrawPicture to
;									this patch set.
;		 <2>	 4/16/90	KON		Don't dereference stdbits address twice.
;		 <2>	 4/16/90	KON		Don't dereference stdbits address twice.
;
;	To Do:
;



;
; Most of the code following this point is filched from pictures.a.
;
; General notes:
;
; The Color QD version of DrawPicture has an extended play state record.
; We want to jump into ROM here and there in order to save system heap
; space.  To do this, we must keep the stack frame layout below A6 the
; same as in the existing ROM.  So, we do some slimy tricks to break the
; play state record into two parts:  the existing part, and an extension
; placed below other stuff in the stack frame.
;


PortableDrawPicture PROC  EXPORT
		IMPORT PicItemPortable,ReduceD3D4
;------------------------------------------------------------------
;
;  PROCEDURE DrawPicture(myPicture: PicHandle; dstRect: Rect);
;					Fix File	Date			Patch#		Fix Routine(s)		Routine(s) Fixed
;AppleSystemPatch 	DrawPicturePatch.a	01Jan1904		#???		(DrawPicture) 		(DrawPicture)		
;

;--------------------------------------------
;
;  OFFSETS WITHIN A PICTURE PLAY STATE RECORD:
;
; *** NOTE *** This information appears in two places: DrawPicture
;				and PicItemPortable.
;


THERECT 		EQU 	0				;RECT
PENLOC			EQU 	THERECT+8		;POINT
TEXTLOC 		EQU 	PENLOC+4		;POINT
OVALSIZE		EQU 	TEXTLOC+4		;POINT
FROMRECT		EQU 	OVALSIZE+4		;RECT
TORECT			EQU 	FROMRECT+8		;RECT
NUMER			EQU 	TORECT+8		;POINT
DENOM			EQU 	NUMER+4 		;POINT
THECLIP 		EQU 	DENOM+4 		;RGNHANDLE
USERCLIP		EQU 	THECLIP+4		;RGNHANDLE
NEWHFRAC		EQU		USERCLIP+4		;(WORD) UPDATED FRACTION RECEIVED <C933 DBG>
TXHFRAC			EQU		NEWHFRAC+2		;(WORD) FRACTIONAL TEXT POSITION <C933 DBG>
PLAYVERSION		EQU		TXHFRAC+2		;(WORD) PICTURE VERSION <C933 DBG>
PLAYREC 		EQU 	PLAYVERSION+2	;TOTAL SIZE <C933 DBG>

TEMPPIXPAT		EQU		THERECT-PORTREC-2		;PIXPAT FOR PLAYING NEW PICS IN OLD PORTS
FontMappingTbl 	EQU 	TEMPPIXPAT-4			;Handle to array of old,new font id pairs
PSreserve1 		EQU 	FontMappingTbl-4		;reserved
PSreserve2 		EQU 	PSreserve1-4			;reserved
PLAYREC2 		EQU 	TEMPPIXPAT+2-PSreserve2	;TOTAL SIZE				

;
;  A6 OFFSETS OF PARAMS AND LOCALS AFTER LINK:
;

PARAMSIZE		EQU 	8
MYPICTURE		EQU 	PARAMSIZE+8-4			;LONG, PICHANDLE
DSTRECT 		EQU 	MYPICTURE-4 			;LONG, ADDR OF RECT

PLAYSTATE		EQU 	-PLAYREC				;PICTURE PLAY STATE RECORD
SAVEPORT		EQU 	PLAYSTATE-PORTREC		;GRAFPORT RECORD
SAVECURSTATE	EQU		SAVEPORT-2				;(WORD) Save state of pic handle <C933 DBG>
PLAYSTATE2		EQU		SAVECURSTATE-PLAYREC2
saveQdRunSlop	equ		PLAYSTATE2-4			;Fixed							<6>
saveQdChExtra	equ		saveQdRunSlop-4			;Fixed							<6>
saveOutline		equ		saveQdChExtra-1			;Byte
savePreserve	equ		saveOutline-1			;Byte
saveFractional	equ		savePreserve-1			;Byte
saveUnscaled	equ		saveFractional-1		;Byte
VARSIZE 		EQU 	saveUnscaled			;TOTAL BYTES OF LOCALS


		LINK	A6,#VARSIZE 					;ALLOCATE LOCALS
		MOVEM.L D3-D7/A2-A4,-(SP)				;SAVE REGISTERS
		MOVE.L	GRAFGLOBALS(A5),A4				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A4),A3					;POINT TO CURRENT GRAFPORT
		TST.L	MYPICTURE(A6)					;IS PICHANDLE NIL ?
		BEQ 	GOHOME							;YES, QUIT

;--------------------------------------------------
;
;  SET UP NUMER AND QUIT IF DSTRECT WIDTH OR HEIGHT IS <= 0
;  COPY DSTRECT INTO TORECT
;
		MOVE.L	DSTRECT(A6),A0					;POINT TO DSTRECT
		MOVE	RIGHT(A0),D0
		SUB 	LEFT(A0),D0 					;CALC DST WIDTH
		BLE 	GOHOME							;QUIT IF WIDTH <= 0
		MOVE	D0,PLAYSTATE+NUMER+H(A6)		;NUMER.H := DST WIDTH
		MOVE	BOTTOM(A0),D0
		SUB 	TOP(A0),D0						;CALC DST HEIGHT
		BLE 	GOHOME							;QUIT IF HEIGHT <= 0
		MOVE	D0,PLAYSTATE+NUMER+V(A6)		;NUMER.V := DST HEIGHT
		LEA 	PLAYSTATE+TORECT(A6),A1
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+ 					;TORECT := DSTRECT


;--------------------------------------------------
;
;  SET UP DENOM AND QUIT IF PICFRAME WIDTH OR HEIGHT IS <= 0
;  COPY PICFRAME INTO FROMRECT.
;
		MOVE.L	MYPICTURE(A6),A0				;GET PICHANDLE
		MOVE.L	(A0),A0 						;DE-REFERENCE IT
		MOVE.L	A0, D0							;SET CONDITION CODE					<FJL PMAB270>
		BEQ		GOHOME							;IF INVALID POINTER -> EXIT			<FJL PMAB270>
		LEA 	PICFRAME(A0),A0 				;POINT TO PICTURE FRAME
		MOVE	RIGHT(A0),D0
		SUB 	LEFT(A0),D0 					;CALC SRC WIDTH
		BLE 	GOHOME							;QUIT IF WIDTH <= 0
		MOVE	D0,PLAYSTATE+DENOM+H(A6)		;DENOM.H := SRC WIDTH
		MOVE	BOTTOM(A0),D0
		SUB 	TOP(A0),D0						;CALC SRC HEIGHT
		BLE 	GOHOME							;QUIT IF HEIGHT <= 0
		MOVE	D0,PLAYSTATE+DENOM+V(A6)		;DENOM.V := SRC HEIGHT
;
; Divide Numer and Denom for width and height by GCD to prevent overflow.  
; <KON 7/1/91>
;
; CAN'T DO THIS HERE SINCE STDOPCODEPROC CLOBBERS DENOM WITH THE RECTANGLE FROM
; THE HEADER. <KON 20MAR91>
;
;		move.l	PLAYSTATE+NUMER(A6),d3			;reduce both high and low words of d3...
;		move.l	PLAYSTATE+denom(A6),d4			;...and d4 by GCD
;		jsr		ReduceD3D4
;		move.l	d3,PLAYSTATE+NUMER(A6)			;save results
;		move.l	d4,PLAYSTATE+denom(A6)	

;		
; End <KON 7/1/91>
;

		LEA 	PLAYSTATE+FROMRECT(A6),A1		;POINT TO FROMRECT
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+ 					;FROMRECT := PICFRAME


;---------------------------------------------------
;
;  PRESERVE THE CURRENT GRAFPORT IN SAVEPORT
;
		MOVE.L	A3,A0							;SRC = THEPORT
		LEA 	SAVEPORT(A6),A1 				;DST = SAVEPORT
		MOVEQ	#PORTREC/2-1,D0 				;INIT DBRA COUNT
SAVELP	MOVE.W	(A0)+,(A1)+ 					;COPY A WORD
		DBRA	D0,SAVELP						;LOOP ENTIRE PORT


;---------------------------------------------------
;
;  PRESERVE AND INIT THE CURRENT LINE-LAYOUT STATE
;
	IF SCRIPT_CHAR_EXTRA THEN
		move.l	grafGlobals(a5),a0							; load quickDraw globals.		<6>
		move.l	qdChExtra(a0),saveQdChExtra(a6)				; save character extra amount.	<6>
		move.l	qdRunSlop(a0),saveQdRunSlop(a6)				; save run slop amount.			<6>
		clr.l	qdChExtra(a0)								; clear character extra amount.	<6>
		clr.l	qdRunSlop(a0)								; clear run slop amount.		<6>
	ENDIF


;---------------------------------------------------
;
;  PRESERVE THE INITIAL GLYPH RENDERING STATE
;
	IF hasGlyphState THEN
		btst.b	#splinePreferred,HiliteMode			; bit flag set in HiliteMode?
		sne.b	saveOutline(a6)						; yes, set outline preferred flag
		btst.b	#preserveGlyph,HiliteMode			; bit flag set in HiliteMode?
		sne.b	savePreserve(a6)					; yes, set preserve glyph flag
		move.b	FractEnable,saveFractional(a6)		; save fractional widths flag
		move.b	FScaleDisable,saveUnscaled(a6)		; save scale disable flag
	ENDIF


;----------------------------------------
;
;  INIT GLOBAL VARS:
;
		MOVE.L	MYPICTURE(A6), A0				;SAVE STATE OF PICTURE HANDLE		<FJL PMAB270>
		_HGetState
		MOVE.B	D0, SAVECURSTATE(A6)			;SAVE IN STACK FRAME
		MOVE.L	MYPICTURE(A6), A0				;MAKE IT NON-PURGEABLE FOR THE DURATION
		_HNoPurge								;									<FJL PMAB270>
		
		CLR.L	PATALIGN(A4)					;PATALIGN := (0,0)
		MOVE.L	MYPICTURE(A6),PLAYPIC(A4)		;SAVE PICTURE FOR STDGETPIC
		MOVE.L	#PICDATA,PLAYINDEX(A4)			;INIT INDEX TO FIRST OPCODE


;----------------------------------------
;
;  INIT PLAY STATE RECORD:
;
		LEA 	PLAYSTATE(A6),A0
		CLR.L	(A0)+							;THERECT := (0,0,0,0)
		CLR.L	(A0)+
		CLR.L	(A0)+							;PENLOC := (0,0)
		CLR.L	(A0)+							;TEXTLOC := (0,0)
		CLR.L	(A0)+							;OVALSIZE := (0,0)
												;FROMRECT SET UP
												;TORECT SET UP
												;NUMER SET UP
												;DENOM SET UP

		MOVE.L	CLIPRGN(A3),PLAYSTATE+USERCLIP(A6) ;SAVE USER CLIPRGN

		CLR.L	-(SP)
		_NEWRGN
		MOVE.L	(SP)+,PLAYSTATE+THECLIP(A6)		;ALLOCATE THECLIP
;		MOVE	#$8000,D0						;INITIALIZE FRACTIONAL PARTS
;		MOVE	D0,PLAYSTATE+TXHFRAC(A6)		;TXHFRAC = 1/2
;		MOVE	D0,PLAYSTATE+FRACFLAG(A6)		;NEW FRACTION = 1/2

		IF withFonts THEN
;
; Allocate handle for mapping of fond id's we have seen so far
;
;		Format of FontMappingTbl handle is:
;			handle size [long]
;			# of entries - 1 used [word]
;				oldID1,newID1 ... oldIDn,newIDn

FontMapSize	equ		25*4

doFontList
		moveq	#FontMapSize+6,d0				;initial size for 50 entries
		_NewHandle
		move.l	a0,PLAYSTATE+FontMappingTbl(a6)	;save picFontList handle in picSave record
		beq.s	@noHandle
		
		move.l	(a0),a0							;point into fontList
		moveq	#FontMapSize+6,d0				;initial size for 25 entries
		move.l	d0,(a0)+
		move.w	#-1,(a0)						; 0 entries

	;	clr.l	(a0)+							; 1 entry, first oldID = 0
	;	clr.w	(a0)							; 		   first newID = 0

@noHandle
		ENDIF	;withFonts
;--------------------------------------------------------
;
;  INIT MOST FIELDS OF THEPORT
;
		CLR.L	-(SP)
		_NEWRGN
		MOVE.L	(SP)+,CLIPRGN(A3)				;ALLOCATE TEMP CLIPRGN
		LEA 	BKPAT(A3),A0					;POINT TO BKPAT
		CLR.L	(A0)+							;BKPAT := WHITE
		CLR.L	(A0)+
		MOVEQ	#-1,D0							;GET SOME BLACK
		MOVE.L	D0,(A0)+						;fillPat := BLACK
		MOVE.L	D0,(A0)+
		CLR.L	(A0)+							;PNLOC := (0,0)
		MOVE.L	#$00010001,D1
		MOVE.L	D1,(A0)+						;pnSize := (1,1)
		MOVE	#8,(A0)+						;pnMode := patCopy
		MOVE.L	D0,(A0)+						;pnPat := black
		MOVE.L	D0,(A0)+
		ADD 	#2,A0							;skip over pnVis
		CLR.L	(A0)+							;txFont, txFace := 0
		MOVE	#1,(A0)+						;txMode := srcOr
		CLR 	(A0)+							;txSize := 0;
		CLR.L	(A0)+							;spExtra := 0.0;
		MOVE.L	#blackColor,(A0)+				;FGCOLOR := blackColor
		MOVE.L	#whiteColor,(A0)+				;BKCOLOR := whiteColor
												;LEAVE COLRBIT ALONE
												;LEAVE PATSTRETCH ALONE
												;LEAVE PICSAVE ALONE
												;LEAVE RGNSAVE ALONE
												;LEAVE POLYSAVE ALONE
												;LEAVE GRAFPROCS ALONE

;--------------------------------------------------
;
		PEA 	PNSIZE(A3)						;Scale initial pensize	<KON 27NOV90>
		PEA 	FROMRECT+PLAYSTATE(A6)			;so that 1,1 lines scale
		PEA 	TORECT+PLAYSTATE(A6)
		_SCALEPT 								;SCALE PNSIZE

;---------------------------------------------------
;
;  NOW DRAW THE PICTURE:
;  REPEAT UNTIL NOT PicItemPortable(playState);
;
DRAWPIC	MOVE	#PICTVERSION,PLAYSTATE+PLAYVERSION(A6)	;DEFAULT TO OLD PICTURE

MORE	CLR.B	-(SP)							;MAKE ROOM FOR FCN RESULT
		PEA 	PLAYSTATE(A6)					;PUSH ADDR OF PLAYSTATE
		JSR 	PicItemPortable					;DRAW ONE PICTURE ITEM
		MOVE.B	(SP)+,D0						;POP BOOLEAN RESULT
		BNE 	MORE							;LOOP TILL FALSE

;-----------------------------------------------------
;
;  DISCARD HANDLES AND RESTORE GRAFPORT STATE
;
DONE	MOVE.L	MYPICTURE(A6),A0				;GET PIC HANDLE						<FJL PMAB270>
		MOVE.B	SAVECURSTATE(A6),D0				;RESTORE STATE OF PICTURE HANDLE
		_HSetState								;									<FJL PMAB270>

		MOVE.L	PLAYSTATE+THECLIP(A6),A0		;GET THECLIP RGNHANDLE
		_DisposHandle							;DISCARD IT

	IF withFonts THEN
		MOVE.L	PLAYSTATE+FontMappingTbl(A6),A0	;get the fontID association table
		_DisposHandle							;DISCARD IT
	ENDIF
		
		MOVE.L	CLIPRGN(A3),A0					;GET TEMPCLIP
		_DisposHandle							;DISCARD IT
		LEA 	SAVEPORT(A6),A0 				;SRC = SAVEPORT
		MOVEQ	#PORTREC/2-1,D0 				;INIT DBRA COUNT
DONELP	MOVE.W	(A0)+,(A3)+ 					;COPY A WORD INTO THEPORT
		DBRA	D0,DONELP						;LOOP ENTIRE PORT

;---------------------------------------------------
;
;  RESTORE THE GLYPH RENDERING STATE
;
	IF hasGlyphState THEN
		move.b	saveOutline(a6),-(sp)				; push saved outline preferred flag
		_SetOutlinePreferred						; restore saved outline preferred
		move.b	savePreserve(a6),-(sp)				; push saved preserve glyph flag
		_SetPreserveGlyph							; restore saved preserve glyph
		move.b	saveFractional(a6),-(sp)			; push saved fractional widths flag
		_SetFractEnable								; restore saved fractional widths
		move.b	saveUnscaled(a6),-(sp)				; push saved scale disable flag
		_SetFScaleDisable							; restore saved scale disable
	ENDIF

;---------------------------------------------------
;
;  RESTORE THE LINE-LAYOUT STATE
;
	IF SCRIPT_CHAR_EXTRA THEN
		move.l	grafGlobals(a5),a0						; load quickDraw globals.			<6>
		move.l	saveQdChExtra(a6),qdChExtra(a0)			; restore character extra amount.	<6>
		move.l	saveQdRunSlop(a6),qdRunSlop(a0)			; restore run slop amount.			<6>
	ENDIF

;---------------------------------------------------
;
;  RESTORE GLOBAL VARS AND QUIT
;
		CLR.L	PATALIGN(A4)					;RESTORE PATALIGN TO (0,0)
		CLR.L	PLAYPIC(A4) 					;SET PLAYPIC TO NIL
		CLR.L	PLAYINDEX(A4)					;AND PLAYINDEX TO 0

GOHOME	MOVEM.L (SP)+,D3-D7/A2-A4				;RESTORE REGISTERS
		UNLINK	PARAMSIZE,'DRAWPICT'			;destroys condition codes
		
		ENDPROC



PicItemPortable FUNC  EXPORT
		IMPORT GetPicData,ScalePt,MapPt,MapRect,MapRgn,MapPoly,GetUByte,GetWord,GetLong
		IMPORT NewRgn,CopyRgn,SectRgn,UnpackBits,MapRatio,GetPicPixPat,GETPICTABLE,GETPM1Deep
		IMPORT MapPt1
		IMPORT StdOpcodeProc,RGB2OLD,SkipPicData,RGB2Pixel,MapMode
		IMPORT GETSBYTE, GETUBYTE
		IMPORT GETWORD,ReduceD3D4
;------------------------------------------------------------------
;
;  FUNCTION PicItem1(VAR playState: PicPlayRec): BOOLEAN;
;
;					Fix File	Date			Patch#		Fix Routine(s)	Routine(s) Fixed
;AppleSystemPatch 	DrawPicturePatch.a	01Jan1904		#???		(PicItem1) 		(PicItem1)		
;
;  Draws one picture item, updating playState and thePort.
;  Returns FALSE when an endPic opCode is encountered.
;  The only state modified other than thePort and playState is patAlign.
;
;  When reading from an NPIC, skips to word boundary before fetching
;  word-long opcode.


;--------------------------------------------
;
;  OFFSETS WITHIN A PICTURE PLAY STATE RECORD:
;
; *** NOTE *** This information appears in two places: DrawPicture
;				and PICITEM1.
;
;--------------------------------------------
;
;  OFFSETS WITHIN A PICTURE PLAY STATE RECORD:
;
THERECT 		EQU 	0			;RECT
PENLOC			EQU 	THERECT+8		;POINT
TEXTLOC 		EQU 	PENLOC+4		;POINT
OVALSIZE		EQU 	TEXTLOC+4		;POINT
FROMRECT		EQU 	OVALSIZE+4		;RECT
TORECT			EQU 	FROMRECT+8		;RECT
NUMER			EQU 	TORECT+8		;POINT
DENOM			EQU 	NUMER+4 		;POINT
THECLIP 		EQU 	DENOM+4 		;RGNHANDLE
USERCLIP		EQU 	THECLIP+4		;RGNHANDLE
NEWHFRAC		EQU		USERCLIP+4		;(WORD) UPDATED FRACTION RECEIVED <C933 DBG>
TXHFRAC			EQU		NEWHFRAC+2		;(WORD) FRACTIONAL TEXT POSITION <C933 DBG>
PLAYVERSION		EQU		TXHFRAC+2		;(WORD) PICTURE VERSION <C933 DBG>
PLAYREC 		EQU 	PLAYVERSION+2	;TOTAL SIZE <C933 DBG>

				IF withFonts THEN
TEMPPIXPAT		EQU		THERECT-PORTREC-2		;PIXPAT FOR PLAYING NEW PICS IN OLD PORTS
FontMappingTbl 	EQU 	TEMPPIXPAT-4			;Handle to array of old,new font id pairs
PSreserve1 		EQU 	FontMappingTbl-4		;reserved
PSreserve2 		EQU 	PSreserve1-4			;reserved
PLAYREC2 		EQU 	TEMPPIXPAT+2-PSreserve2	;TOTAL SIZE				
				ENDIF	;withFonts
				
;
;  params:
;
PARAMSIZE		EQU 	4
RESULT			EQU 	PARAMSIZE+8 			;BOOLEAN
PLAYSTATE		EQU 	RESULT-4				;LONG, PICHANDLE
;
;  locals:
;
HANDLE1 		EQU 	-4						;HANDLE
HANDLE2 		EQU 	HANDLE1-4				;HANDLE
DSTRECT 		EQU 	HANDLE2-8				;RECT (MUST BE BEFORE SRCRECT)
SRCRECT 		EQU 	DSTRECT-8				;RECT (MUST FOLLOW DSTRECT)
SRCBITS	 		EQU 	SRCRECT-14				;BITMAP (Not used)
SAMEFLAG		EQU 	SRCBITS-2				;BOOLEAN
NEWPT			EQU 	SAMEFLAG-4				;LONG
TXDATA			EQU 	NEWPT-256				;UP TO 256 CHARACTERS,
												;ALSO USED FOR PACKBUF !!!
												;Also used by CTBitMap <19Feb87 DBG>
SRCPTR			EQU 	TXDATA-4				;LONG
DSTPTR			EQU 	SRCPTR-4				;LONG
SAVEDSP			EQU 	DSTPTR-4				;LONG

; Following is the extension to the stack frame in ROM

SRCPIX			EQU		SAVEDSP-PMREC			;SRCPIX
VARSIZE 		EQU 	SRCPIX					;TOTAL BYTES OF LOCALS


		LINK	A6,#VARSIZE 					;ALLOCATE LOCALS
		MOVEM.L D3-D7/A2-A4,-(SP)				;SAVE REGISTERS
		MOVE.L	SP,SAVEDSP(A6)					;REMEMBER STACK FOR ABORT
		MOVE.L	GRAFGLOBALS(A5),A4				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	THEPORT(A4),A3					;POINT TO CURRENT GRAFPORT
		
;  GET PICTURE OPCODE AND CHECK FOR END OF PICTURE.

		CLR.B	RESULT(A6)						;ASSUME END OF PICTURE
		BSR		GetPicOp						;READ OPCODE INTO D0
		MOVE	D0,D7							;PUT IT IN D7
		CMP		#opEndPic,D7 					;IS THIS THE ENDPIC OPCODE ?
		BEQ		DONE							;=>YES, ALL DONE
		BLO.S	GoodOp							;=>GOOD OPCODE, CONTINUE
		
; IT'S AN OPCODE THAT WE DON'T KNOW HOW TO HANDLE.  CALL THE OPCODE PROC.

		LEA		StdOpcodeProc,A0				;USE STANDARD OPCODE PROC
USESTD	MOVE.L	PLAYSTATE(A6),A2				;GET THE PLAYSTATE RECORD
		PEA		FROMRECT(A2)					;PUSH SRC RECT
		PEA		TORECT(A2)						;PUSH DST RECT
		MOVE	D7,-(SP)						;PUSH OPCODE
		MOVE	PLAYVERSION(A2),-(SP)			;PUSH VERSION
		JSR		(A0)							;CALL PROC
		MOVE.B	#1,RESULT(A6)					;FLAG NOT END OF PICTURE
		BRA		DONE							;=>DONE WITH THIS OPCODE
		
GoodOp	MOVE.B	#1,RESULT(A6)					;NOT END OF PICTURE

;  CHECK FOR PARAM OPCODES $00..$1F

		CMP 	#$20,D7 						;IS IT A PARAM OPCODE ?
		BLO.S	PARAMOP 						;YES, GO TO IT

;  GET LO AND HI NIBBLES OF OPCODE, AND CASE ON HI NIBBLE (NOUN).

		MOVE.B	D7,D0							;COPY OPCODE
		AND 	#$F0,D0 						;MASK FOR HI NIBBLE
		BTST	#3,D7							;IS OPCODE BIT 3 SET ?
		SNE 	SAMEFLAG(A6)					;REMEMBER IN SAMEFLAG
		AND 	#$7,D7							;GET VERB FROM LO NIBBLE
		LSR 	#3,D0							;DOUBLE HI NIBBLE FOR INDEX
		MOVE	NOUNJMP(D0),D0					;GET JUMP OFFSET
		JMP 	NOUNJMP(D0) 					;TAKE CASE JUMP

NOUNJMP DC.W	DONE-NOUNJMP					;NEVER TAKEN
		DC.W	DONE-NOUNJMP					;NEVER TAKEN
		DC.W	TXLNOP-NOUNJMP
		DC.W	RECTOP-NOUNJMP
		DC.W	RRECTOP-NOUNJMP
		DC.W	OVALOP-NOUNJMP
		DC.W	ARCOP-NOUNJMP
		DC.W	POLYOP-NOUNJMP
		DC.W	RGNOP-NOUNJMP
		DC.W	BITSOP-NOUNJMP
		DC.W	COMMOP-NOUNJMP
		DC.W	DONE-NOUNJMP					;OPCODE WITH NO DATA
		DC.W	DONE-NOUNJMP					;OPCODE WITH NO DATA
		DC.W	IGNORESHORT-NOUNJMP				;IGNORE WORD LENGTH, DATA
		DC.W	IGNORELONG-NOUNJMP				;IGNORE LONG LENGTH, DATA
		DC.W	IGNORELONG-NOUNJMP				;IGNORE LONG LENGTH, DATA


;---------------------------------------------------
;
;  OPCODES $00..$1F DO NO DRAWING, THEY JUST SET PARAMETERS.
;
PARAMOP AND 	#$1F,D7 						;GET LO 5 BITS OF OPCODE
		ADD 	D7,D7							;DOUBLE PARAM FOR CASE INDEX
		MOVE	PARMJMP(D7),D0					;GET CASE JUMP OFFSET
		JMP 	PARMJMP(D0) 					;TAKE CASE JUMP
PARMJMP DC.W	DONE-PARMJMP					;OPCODE 0 IS PURPOSELY A NOP
		DC.W	XCLIP-PARMJMP					;OPCODE $01
		DC.W	XBKPAT-PARMJMP					;OPCODE $02
		DC.W	XTXFONT-PARMJMP					;OPCODE $03
		DC.W	XTXFACE-PARMJMP					;OPCODE $04
		DC.W	XTXMODE-PARMJMP					;OPCODE $05
		DC.W	XSPXTRA-PARMJMP					;OPCODE $06
		DC.W	XPNSIZE-PARMJMP					;OPCODE $07
		DC.W	XPNMODE-PARMJMP					;OPCODE $08
		DC.W	XPNPAT-PARMJMP					;OPCODE $09
		DC.W	XFILLPAT-PARMJMP				;OPCODE $0A
		DC.W	XOVSIZE-PARMJMP					;OPCODE $0B
		DC.W	XORIGIN-PARMJMP					;OPCODE $0C
		DC.W	XTXSIZE-PARMJMP					;OPCODE $0D
		DC.W	XFGCOL-PARMJMP					;OPCODE $0E
		DC.W	XBKCOL-PARMJMP					;OPCODE $0F
		DC.W	TXRATIO-PARMJMP 				;OPCODE $10
		DC.W	VERSION-PARMJMP 				;OPCODE $11
		DC.W	XBkPixPat-PARMJMP 				;OPCODE $12
		DC.W	XPnPixPat-PARMJMP 				;OPCODE $13
		DC.W	XFillPixPat-PARMJMP 			;OPCODE $14
		DC.W	XPnLocHFrac-PARMJMP 			;OPCODE $15
		DC.W	XChExtra-PARMJMP				;OPCODE	$16
		DC.W	DONE-PARMJMP 					;OPCODE $17
		DC.W	DONE-PARMJMP 					;OPCODE $18 (opIFore)
		DC.W	DONE-PARMJMP 					;OPCODE $19 (opIBack)
		DC.W	XRGBFGCOL-PARMJMP 				;OPCODE $1A
		DC.W	XRGBBKCOL-PARMJMP 				;OPCODE $1B
		DC.W	xHiliteMode-PARMJMP				;OPCODE $1C
		DC.W	xHiliteColor-PARMJMP			;OPCODE $1D
		DC.W	xDefHilite-PARMJMP				;OPCODE $1E
		DC.W	xOpColor-PARMJMP 				;OPCODE $1F


XCLIP	BSR 	GETHNDL 						;COPY RGN INTO HANDLE1
		IF		noROM THEN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH HANDLE1
		MOVE.L	THECLIP(A2),-(SP)				;PUSH PLAYSTATE THECLIP
XCLIP2	_COPYRGN 								;COPY HANDLE1 INTO THECLIP
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH HANDLE1 TEMP
		PEA 	FROMRECT(A2)					;PUSH FROMRECT
		PEA 	TORECT(A2)						;PUSH TORECT
		_MAPRGN									;MAP RGN INTO DST COORDS
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH MAPPED RGN
		MOVE.L	USERCLIP(A2),-(SP)				;PUSH ORIGINAL CLIP
		MOVE.L	CLIPRGN(A3),-(SP)				;PUSH DST = THEPORT^.CLIPRGN
		_SECTRGN 								;PUT INTERSECT INTO CLIPRGN
		BRA 	KILL1							;DISCARD HANDLE1 AND QUIT
		ELSE
		jmpROM		RomXClip					; Jump into ROM
XCLIP2	jmpROM		RomXClip2					; Jump into ROM
		ENDIF


GET8	MOVEQ	#8,D6							;BYTECOUNT = 8
		BRA 	GETDONE 						;COPY 8 BYTES AND QUIT

GET4	MOVEQ	#4,D6							;BYTECOUNT = 4
		BRA 	GETDONE 						;COPY 4 BYTES AND QUIT

GET2	MOVEQ	#2,D6							;BYTECOUNT = 2
		BRA 	GETDONE 						;COPY 2 BYTES AND QUIT

GETMODE	JSR		GETWORD							;GET THE MODE WORD
		JSR		MAPMODE							;GET EQUIVALENT MODES
		MOVE.W	D0,(A3)							;SAVE IT
		BRA		DONE							;QUIT

XFGCOL	LEA 	FGCOLOR(A3),A3
		BRA 	GET4							;GET FOREGROUND COLOR

XBKCOL	LEA 	BKCOLOR(A3),A3
		BRA 	GET4							;GET BACKGROUND COLOR

XBKPAT	LEA 	BKPAT(A3),A3
		BRA 	GET8							;GET BKPAT

XTXFONT LEA 	TXFONT(A3),A3
		IF	withFonts THEN
		jsr		getword							;get the old font ID in d0
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	FontMappingTbl(A2),d1			;get the fontID association table
		beq.s	@doit							;just use ID as is
		move.l	d1,a0
		move.l	(a0),a0
		addq	#4,a0							;point to zero based entry count
		move.w	(a0)+,d1						;pick up entry count (could be -1)
		bmi.s	@doit							;no mapping entries
												
												;entries: oldID,newID word pairs
@1		cmp.w	(a0),d0							;entry for this ID?
		addq	#4,a0							;bump to next pair
		dbeq	d1,@1							;look until the end or we find it
		bne.s	@doit							;not found: so don't map
		move.w	-2(a0),d0						;found: so use new ID
		
@doit	move.w	d0,(a3)							;install the font id in the port
		BRA 	Done							;
		ELSE
		BRA		Get2
		ENDIF

XTXFACE LEA 	TXFACE(A3),A3
		MOVEQ	#1,D6
		BRA 	GETDONE 						;GET TXFACE

XTXMODE LEA 	TXMODE(A3),A3
		BRA 	GETMODE							;GET TXMODE

XTXSIZE LEA 	TXSIZE(A3),A3
		BRA 	GET2							;GET TXSIZE

XSPXTRA LEA 	SPEXTRA(A3),A3
		BRA 	GET4							;GET fixed point SPACE EXTRA

XPNSIZE JSR 	GETLONG 						;GET PNSIZE
		IF		noROM THEN
		MOVE.L	D0,PNSIZE(A3)					;INSTALL INTO THEPORT
		PEA 	PNSIZE(A3)
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_SCALEPT 								;SCALE PNSIZE
		BRA 	DONE
		ELSE
		jmpROM		RomXPnSize					;Jump into ROM
		ENDIF

TXRATIO MOVE.L	PLAYSTATE(A6),A3				;POINT TO PLAYSTATE RECORD
		JSR 	GETLONG 						;GET TEXT NUMER
		MOVE.L	D0,NUMER(A3)					;INSTALL INTO PLAYSTATE
		JSR 	GETLONG 						;GET TEXT DENOM
		MOVE.L	D0,DENOM(A3)					;INSTALL INTO PLAYSTATE
;
; Calculate new numer/denom to 32-bits using ConcatRatio.
;
		move.w	numer+v(a3),d3
		move.w	toRect+bottom(a3),d4
		sub.w	toRect+top(a3),d4				;get height of toRect
		swap	d3
		swap	d4
		move.w	denom+v(a3),d3
		move.w	fromRect+bottom(a3),d4
		sub.w	fromRect+top(a3),d4				;get height of fromRect

		bsr		ConcatRatio
		move.w	d3,denom+v(a3)
		swap	d3
		move.w	d3,numer+v(a3)

		move.w	numer+h(a3),d3
		move.w	toRect+right(a3),d4
		sub.w	toRect+left(a3),d4				;get width of toRect
		swap	d3
		swap	d4
		move.w	denom+h(a3),d3
		move.w	fromRect+right(a3),d4
		sub.w	fromRect+left(a3),d4			;get width of fromRect

		bsr		ConcatRatio
		move.w	d3,denom+h(a3)
		swap	d3
		move.w	d3,numer+h(a3)
		
		bra 	done

ConcatRatio
;
; takes two 16-bit numer/denom pairs and returns a 16-bit numer/denom
; D3 = numer/denom
; D4 = ToRect/FromRect
;
; Returns answer in D3
;
		move.w	d3,d0
		mulu.w	d4,d0							;has 32-bit denom
		swap	d3
		swap	d4
		
		mulu.w	d4,d3							;has 32-bit numer
;
; Need to convert 32-bit ratio (in d3/d0) into 16-bit ratio in d3
;
		move.l	d0,d1
		or.l	d3,d1							;number of bits to mask in high word
		bra.s	@FifteenBitsYet
;
; shift until we're clear. 
;
@loop
		lsr.l	#1,d3							;
		lsr.l	#1,d0
		lsr.l	#1,d1		
@FifteenBitsYet
		move.l	d1,d4							;ratio fit in 15 bits?
		and.l	#$FFFF8000,d4
		bne.s	@loop							;nope, loop again
		swap	d3
		move.w	d0,d3
		rts

VERSION JSR 	GETUBYTE						;GET VERSION NUMBER BYTE
		MOVE.L	PLAYSTATE(A6),A3				;POINT TO PLAYSTATE RECORD
		MOVE	D0,PLAYVERSION(A3)				;INSTALL VERSION INTO PLAYSTATE
		BRA 	DONE							;AND RETURN

XPNMODE LEA 	PNMODE(A3),A3
		BRA 	GETMODE							;GET PNMODE

XPNPAT	LEA 	PNPAT(A3),A3
		BRA 	GET8							;GET PNPAT

XFILLPAT LEA	 FILLPAT(A3),A3
		BRA 	GET8							;GET FILLPAT

XOVSIZE JSR 	GETLONG 						;GET OVAL SIZE
		IF		noROM THEN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	D0,OVALSIZE(A2)
		PEA 	OVALSIZE(A2)
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_SCALEPT 								;SCALE OVAL SIZE
		BRA 	DONE
		ELSE
		jmpROM		OvalEnd						; Jump into ROM
		ENDIF

;-----------------------------------------------------
;
;  CHANGE ORIGIN:  ADD DH AND DV TO FROMRECT, ADJUST PATALIGN,
;		   THEN RE-MAP THECLIP
;
XORIGIN JSR 	GETLONG 						;GET DH,DV
		IF		noROM THEN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		ADD 	D0,FROMRECT+TOP(A2) 			;ADD DV TO FROMRECT
		ADD 	D0,FROMRECT+BOTTOM(A2)
		ADD 	D0,PATALIGN+V(A4)				;AND TO PATALIGN
		SWAP	D0								;GET DH IN LO WORD
		ADD 	D0,FROMRECT+LEFT(A2)			;ADD DH TO FROMRECT
		ADD 	D0,FROMRECT+RIGHT(A2)
		ADD 	D0,PATALIGN+H(A4)				;AND TO PATALIGN
;
;  RE-COMPUTE MAPPED CLIPRGN FROM UNMAPPED THECLIP
;
		MOVE.L	THECLIP(A2),-(SP)				;PUSH THECLIP
		CLR.L	-(SP)							;ROOM FOR FCN RESULT
		_NEWRGN									;ALLOCATE A TEMP RGN
		MOVE.L	(SP),HANDLE1(A6)				;PUT IN HANDLE1
		BRA.S	XCLIP2							;COPY, MAP, SECT, AND DISCARD
		ELSE
		jmpROM		XOrigin						; Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  NEW CQD OPCODES THAT JUST SET PARAMETERS
		
XRGBFGCOL
			LEA		FGCOLOR(A3),A3				;POINT AT SLOT
			BRA.S	XRGBCOMMON					;COMMON CODE

XRGBBKCOL
			LEA		BKCOLOR(A3),A3				;POINT AT SLOT
XRGBCOMMON
			JSR		GETLONG						;GET R,G
			MOVE.L	D0,D6						;SAVE R,G
			JSR		GETWORD						;GET B
			MOVE	D0,-(SP)					;PUT B ON STACK
			MOVE.L	D6,-(SP)					;PUT R,G ON STACK
			MOVE.L	SP,A1						;POINT TO RGB
			jsr		RGB2OLD						;CONVERT TO OLD
			MOVE.L	D0,(A3)						;SET IT
			ADDQ	#6,SP						;STRIP RGB
			BRA		DONE						;AND RETURN

XBkPixPat	PEA		BKPAT(A3)					;PUSH BKPAT PTR
			BRA.S	XPIXPAT						;=>USE COMMON CODE

XPnPixPat	PEA		PNPAT(A3)					;PUSH PNPAT PTR
			BRA.S	XPIXPAT						;=>USE COMMON CODE

XFillPixPat PEA		FILLPAT(A3)					;PUSH FILLPAT PTR
XPixPat		JSR		GetPicPixPat				;GET THE PATTERN
			BRA		DONE						;=>AND RETURN

XPnLocHFrac	JSR		GetWord						;GET FRACTION INTO D0
;			MOVE.L	PLAYSTATE(A6),A2			;POINT TO PLAYSTATE RECORD
;			MOVE	D0,TXHFRAC(A2)				;SAVE HORIZONTAL FRACTION
			BRA		DONE						;=>AND RETURN
			
XCHEXTRA
			JSR		GetWord						;Get Junk word
			BRA		DONE						;=>AND RETURN
			
XHiliteMode ;BCLR	#hiliteBit,HiliteMode		;ENABLE HILITING
			BRA		DONE						;AND RETURN
			
; HILITE COLOR CHANGED, SAVE NEW VALUE INTO GRAFVARS

XHiliteColor JSR	GETLONG						;GET R,G
			MOVE.L	D0,D6						;SAVE R,G
			JSR		GETWORD						;GET B
; DO NOTHING, OLD GRAFPORT
@DONE		BRA		DONE						;AND RETURN

; HILITE COLOR CHANGED TO DEFAULT, COPY HILITE FROM LOW-MEM TO GRAFVARS
			
XDefHilite	BRA		DONE						;AND RETURN
			
; OP COLOR CHANGED, SAVE NEW VALUE INTO GRAFVARS

XOpColor	JSR		GETLONG						;GET R,G
			MOVE.L	D0,D6						;SAVE R,G
			JSR		GETWORD						;GET B
; OLD GRAFPORT, DO NOTHING
@DONE		BRA		DONE						;AND RETURN


;---------------------------------------------------
;
;  ROUTINES FOR IGNORING DATA
;
;  READ THE LENGTH FOLLOWED BY THAT NUMBER OF BYTES
;
CHKSAME		TST.B	SAMEFLAG(A6)					;USE SAME STRUCTURE?
			BEQ.S	IGCOUNT							;=>NO, USE COUNT IN D0
			MOVE.L	D1,D0							;ELSE GET SIZE FOR SAME
			BRA.S	IGCOUNT							;=>IGNORE SPECIFIED NUMBER OF BYTES

IGNORELONG	JSR		GETLONG							;GET A LONG OF LENGTH
			BRA.S	IGCOUNT							;AND IGNORE THAT MUCH DATA
			
IGNORESHORT	JSR		GETWORD							;GET A WORD OF LENGTH
			SWAP	D0								;GET HIGH WORD
			CLR		D0								;CLEAR IT OUT
			SWAP	D0								;SO WE HAVE A LONG LENGTH

IGCOUNT		JSR		SkipPicData						;Skip D0 bytes
			BRA		DONE

;---------------------------------------------------
;
;  DRAWING OPCODES: 	$20 - $FE
;
;---------------------------------------------------
;
;  TEXT OR LINE OPCODES:
;
;  LINE:	  	  20,  PNLOC(pt), NEWPT(pt)
;  LINEFROM:	  21,  			  NEWPT(pt)
;  SHORT LINE:	  22,  PNLOC(pt), DH(byte), DV(byte)
;  SHORTLNFROM:   23,             DH(byte), DV(byte)
;
;  TEXT:	  28,29,2A,2B
;
TXLNOP	TST.B	SAMEFLAG(A6)					;IS THIS A TEXT OPCODE ?	<07Nov89 KON>
		BNE		TEXTOP							;YES, DO IT					<07Nov89 KON>
		CMP		#3,D7							;IS OPCODE VALID?
		BGT.S	IGNORESHORT						;=>NO, IGNORE SHORT DATA
		
		TST.B	SAMEFLAG(A6)					;IS THIS A TEXT OPCODE ?
		BNE.S	TEXTOP							;YES, DO IT
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	PENLOC(A2),D0					;NO, GET PREVIOUS LINE ENDPOINT
		ROR 	#1,D7							;IS LO NIBBLE ODD ? (BIT 0)
		BCS.S	LNFROM							;YES, DRAW LINE FROM PREV
		JSR 	GETLONG 						;NO, GET NEW STARTPT
LNFROM	MOVE.L	D0,PNLOC(A3)					;COPY STARTPT INTO THEPORT
		MOVE.L	D0,NEWPT(A6)					;SAVE FOR SHORT DH,DV BELOW
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	PNLOC(A3)
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_MAPPT									;MAP STARTPT

		ROR 	#1,D7							;IS OPCODE BIT 1 SET ?
		BCS.S	SHORTLN 						;YES, USE SHORT DH,DV FORM
		JSR 	GETLONG 						;NO, GET NEWPT
		MOVE.L	D0,NEWPT(A6)					;PUT IN TEMP
		BRA.S	LNOK							;AND CONTINUE
SHORTLN jsr 	GETSBYTE						;GET A SIGNED BYTE
		ADD.W	D0,NEWPT+H(A6)					;ADD TO STARTPT.H
		jsr 	GETSBYTE						;GET A SIGNED BYTE
		ADD.W	D0,NEWPT+V(A6)					;ADD TO STARTPT.V

		IF		noROM THEN
LNOK	MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	NEWPT(A6),PENLOC(A2)			;REMEMBER NEWPT FOR NEXT TIME
;		MOVE	#$8000,TXHFRAC(A2)				;INVALIDATE TEXT FRACTION
		PEA 	NEWPT(A6)						;PUSH ADDRESS OF NEWPT
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_MAPPT									;MAP NEWPT
		MOVE.L	NEWPT(A6),-(SP) 				;PUSH NEWPT PARAM FOR LINEPROC
		MOVE.L	PStdLine,A0 					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	LINEPROC(A0),A0 				;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
		ELSE
LNOK	jmpROM		RomLNOK							;Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  LONG TEXT:		28, txLoc(pt), count(0..255), text
;  DH TEXT:			29, dh(0..255), count(0..255), text
;  DV TEXT:   		2A, dv(0..255), count(0..255), text
;  DHDV TEXT:		2B, dh(0..255), dv(0,..255), count(0..255), text
;
;  Font ID/Name:	2C, data size (word), fond ID, fond name (pstr)
;  Line layout:		2D, data size (word), character extra (fixed), run slop (fixed)
;  Glyph state:		2E, data size (word), ouline preferred (byte), preserve glyph (byte),
;										  fractional widths (byte), scaling disabled (byte)
;
TEXTOP
	IF hasGlyphState THEN
		cmp		#6,d7							; glyph state opcode?
		beq		GlyphState						; yes, glyph state information
	ENDIF
	IF SCRIPT_CHAR_EXTRA THEN
		cmp		#5,d7							;line-layout opcode?
		beq		LineLayout						;yes -> line-layout information.
	ENDIF
	IF withFonts THEN
		CMP		#4,D7							;IS OPCODE VALID?
		BGT		IGNORESHORT						;=>NO, IGNORE SHORT DATA
		BEQ		AddFontToTbl					;bind name to new ID
	ENDIF

;		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
;		MOVE	NEWHFRAC(A2),TXHFRAC(A2)		;ELSE COPY NEW FRACTIONAL POSITION
;		MOVE	#$8000,NEWHFRAC(A2)				;AND CLEAR TO 1/2

		AND 	#3,D7							;IS THIS A LONGTEXT OPCODE ?
		BEQ.S	LONGTXT 						;YES, USE LONG FORMAT
		ROR 	#1,D7							;DO WE NEED DH ? (BIT 0)
		BCC.S	DHOK							;NO, CONTINUE
		JSR 	GETUBYTE						;GET DH 0..255
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		ADD 	D0,TEXTLOC+H(A2)				;BUMP TEXTLOC.H

DHOK	ROR 	#1,D7							;DO WE NEED DV ? (BIT 1)
		BCC.S	TEXTOP2 						;NO, CONTINUE
		JSR 	GETUBYTE						;GET DV 0..255
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		ADD 	D0,TEXTLOC+V(A2)				;BUMP TEXTLOC.V
		BRA.S	TEXTOP2 						;SHARE CODE

LONGTXT JSR 	GETLONG 						;GET TXLOC, UNMAPPED
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	D0,TEXTLOC(A2)					;SAVE IN TEXTLOC

TEXTOP2 JSR 	GETUBYTE						;GET TEXT LENGTH 0..255
		MOVE	D0,D6							;SAVE LENGTH IN D6
		PEA 	TXDATA(A6)						;PUSH ADDR OF TEXT BUF
		MOVE	D6,-(SP)						;PUSH BYTECOUNT
		JSR 	GetPicData						;GET THE TEXT

		IF		noROM THEN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD

		MOVE.L	TEXTLOC(A2),PNLOC(A3)			;COPY TEXTLOC INTO PNLOC
		PEA 	PNLOC(A3)
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_MAPPT									;MAP PNLOC.V,PNLOC.H	
		
		MOVE	D6,-(SP)						;PUSH CHARACTER COUNT
		PEA 	TXDATA(A6)						;PUSH ADDRESS OF TEXT
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	NUMER(A2),-(SP) 				;PUSH NUMER
		MOVE.L	DENOM(A2),-(SP) 				;PUSH DENOM
		MOVE.L	PStdText,A0 					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	TEXTPROC(A0),A0 				;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
		ELSE
		jmpROM	RomTextOP						; Jump into ROM
		ENDIF
		
;
; At this point we have found a non-zero fond ID which we have not seen previously
; so we must add it to the FontMappingTbl handle.  If the handle needs to be resized we do that
; here as well.

	IF withFonts THEN
fontMapChunk	equ		20*4

AddFontToTbl
		MOVE.L	PLAYSTATE(A6),A2			;POINT TO PLAYSTATE RECORD
		MOVE.L	FontMappingTbl(A2),d1		;get the fontID association table
		beq		ignoreShort					;skip opcode data if no handle
		move.l	d1,a0
		move.l	(a0),a1						;
		moveq	#0,d0						;clear out high end
		move.w	4(a1),d0					;get amnt of handle in use
		addq.w	#1,d0						;make 1 based
		add.w	d0,d0
		add.w	d0,d0						;4 bytes per entry
		addq.w	#6,d0						;hdr size
		cmp.l	(a1),d0						;same as size of handle?
		blt.s	addFontID					;no need to grow list	
		
		add.w	#fontMapChunk,d0			;bump handleSize enough for 25 more fonts
		move.l	d0,(a1)						;save the new size
		_SetHandleSize						;grow list
		MOVE.L	FontMappingTbl(A2),a0		;get the fontID association table
		move.l	(a0),a1						;get fontList handle
		tst.w	d0							;did we get it?
		beq.s	addFontID					;yes, continue
		sub.w	#fontMapChunk,(a1)			;couldn't grow it.
		bra		ignoreShort					;skip name stuff
		
addFontID
		move.l	a0,a3						;save fontMappingTbl handle in a3
		JSR 	GetWord						;get word data length
		subq	#2,d0						;get length of fond name (incl. length byte)
		MOVE	D0,D6						;SAVE LENGTH IN D6
		JSR 	GetWord						;get old fond ID
		MOVE	D0,D7						;save fond ID in D7
		PEA 	TXDATA(A6)					;PUSH ADDR OF TEXT BUF
		MOVE	D6,-(SP)					;PUSH BYTECOUNT
		JSR 	GetPicData					;get the name pstring
		
		PEA 	TXDATA(A6)					;PUSH ADDR OF font name
		PEA 	NewPt(A6)					;PUSH ADDR OF var font id
		_GetFNum							;find the appropriate id for this system
		move.w	NewPt(a6),d6				;get new fond ID
		beq.s	fontDone					;not found, so don't add to table
		cmp.w	d6,d7						;does old ID = new ID?
		beq.s	fontDone					;yes, don't add to table

		move.l	(a3),a1						;fontID association table handle in A3
		addq.w	#4,a1						;point to number of entries in use - 1
		addq.w	#1,(a1)						;bump the entry count
		move.w	(a1)+,d0					;get new entry count and point to entry array
		lsl.w	#2,d0						;
		lea		(a1,d0),a1					;point to this 0ld,New pair
		move.w	d7,(a1)+					;store old ID
		move.w	d6,(a1)						;store new ID
		
fontDone
		bra		Done
	ENDIF

;
; Load the line-layout information from the picture and save it into the Script Manager
; globals. We also want to skip any extra data that follows so the opcode can hold more
; in future versions.
;

	IF SCRIPT_CHAR_EXTRA THEN
LineLayout
		jsr		GetWord							; get the data length.
		move.w	d0,-(sp)						; save this for later.
		jsr		GetLong							; get the character extra.
		move.l	grafGlobals(a5),a0				; load quickDraw globals.				<6>
		move.l	d0,qdChExtra(a0)				; restore character extra amount.		<6>
		jsr		GetLong							; get the run slop.
		move.l	grafGlobals(a5),a0				; load quickDraw globals.				<6>
		move.l	d0,qdRunSlop(a0)				; restore run slop amount.				<6>
		
		clr.l	d0								; clear a long.
		move.w	(sp)+,d0						; load original data length.
		sub.l	#8,d0							; extra data included?
		bgt		IgCount							; yes -> ignore it for now.
		bra		Done							; finished with this opcode.
	ENDIF

;
; Load the glyph state information from the picture and save it into the low memory
; globals. If the width tables are no longer valid then flag that condition by setting
; LastSpExtra to an invalid value. We also want to skip any extra data that follows so
; the opcode can hold more in future versions.
;

	IF hasGlyphState THEN
GlyphState
		jsr		GetWord							; get data length
		move.w	d0,-(sp)						; save this for later
		
		jsr		GetUByte						; get outline preferred flag
		move.b	d0,-(sp)						; push it on the stack
		_SetOutlinePreferred					; set outline preferred state

		jsr		GetUByte						; get preserve glyph flag
		move.b	d0,-(sp)						; push it on the stack
		_SetPreserveGlyph						; set preserve glyph state

		jsr		GetUByte						; get fractional widths flag
		move.b	d0,-(sp)						; push it on the stack
		_SetFractEnable							; set fractional widths state

		jsr		GetUByte						; get scaling disabled flag
		move.b	d0,-(sp)						; push it on the stack
		_SetFScaleDisable						; set scaling disabled state
		
		clr.l	d0								; clear a long
		move.w	(sp)+,d0						; load original data length
		sub.l	#4,d0							; extra data included?
		bgt		IgCount							; yes, ignore it for now
		bra		Done							; finished with this opcode
	ENDIF

;---------------------------------------------------
;
;  Rect:  OP, RECT
;
RECTOP	CMP		#4,D7							;IS OPCODE VALID?
		BLE.S	ROK								;=>YES, CONTINUE
		MOVEQ	#8,D0							;IF RECT, SKIP 8 BYTES
		MOVEQ	#0,D1							;IF SAME, SKIP 0 BYTES
		BRA		CHKSAME							;=>CHECK SAMEFLAG AND IGNORE

ROK 	MOVE.B	D7,-(SP)						;PUSH VERB
		BSR 	GETRECT 						;GET AND PUSH DSTRECT
		IF		noROM THEN
		MOVE.L	PStdRect,A0 					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	RECTPROC(A0),A0 				;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
		ELSE
		jmpROM	RomRectOP						; Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  RRect:  OP, RECT, OVALPT
;
RRECTOP CMP		#4,D7							;IS OPCODE VALID?
		BLE.S	RROK							;=>YES, CONTINUE
		MOVEQ	#8,D0							;IF RECT, SKIP 8 BYTES
		MOVEQ	#0,D1							;IF SAME, SKIP 0 BYTES
		BRA		CHKSAME							;=>CHECK SAMEFLAG AND IGNORE

RROK	MOVE.B	D7,-(SP)						;PUSH VERB
		BSR 	GETRECT 						;GET AND PUSH DSTRECT
		IF		noROM THEN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	OVALSIZE(A2),-(SP)				;PUSH OVHT,OVWD
		MOVE.L	PStdRRect,A0					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	RRECTPROC(A0),A0				;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
		ELSE
		jmpROM	RomRRectOP						; Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  Oval:  OP, RECT
;
OVALOP	CMP		#4,D7							;IS OPCODE VALID?
		BLE.S	OVOK							;=>YES, CONTINUE
		MOVEQ	#8,D0							;IF RECT, SKIP 8 BYTES
		MOVEQ	#0,D1							;IF SAME, SKIP 0 BYTES
		BRA		CHKSAME							;=>CHECK SAMEFLAG AND IGNORE

OVOK	MOVE.B	D7,-(SP)						;PUSH VERB
		BSR 	GETRECT 						;GET AND PUSH DSTRECT
		IF		noROM THEN
		MOVE.L	PStdOval,A0 					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	OVALPROC(A0),A0 				;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
		ELSE
		jmpROM	RomOvalOP						; Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  Arc:  OP, RECT, STARTANGLE, ARCANGLE
;
ARCOP	CMP		#4,D7							;IS OPCODE VALID?
		BLE.S	ARCOK							;=>YES, CONTINUE
		MOVEQ	#12,D0							;IF NOT SAME, SKIP 12 BYTES
		MOVEQ	#4,D1							;IF SAME, SKIP 5 BYTES
		BRA		CHKSAME							;=>CHECK SAMEFLAG AND IGNORE

ARCOK	MOVE.B	D7,-(SP)						;PUSH VERB
		BSR 	GETRECT 						;GET AND PUSH DSTRECT
		JSR 	GETWORD 						;GET STARTANGLE
		MOVE	D0,-(SP)						;PUSH STARTANGLE
		JSR 	GETWORD 						;GET ARCANGLE
		IF		noROM THEN
		MOVE	D0,-(SP)						;PUSH ARCANGLE
		MOVE.L	PStdArc,A0						;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	ARCPROC(A0),A0					;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
		ELSE
		jmpROM	RomArcOP						; Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  Poly:  OP, POLY
;
;  THE SAME POLY OPCODES WERE NEVER PARSED, SO FOR COMPATIBILITY I'LL DO OLD WAY

POLYOP	CMP		#4,D7							;IS OPCODE VALID?
		BLE.S	POLYOK							;=>YES, CONTINUE
		TST.B	SAMEFLAG(A6)					;IS IT THE SAME POLY?
		BNE.S	@DONE							;=>YES, NO DATA
		BSR		GETHNDL							;ELSE READ IN THE POLYGON
@DONE	BRA		DONE							;AND RETURN

POLYOK	BSR 	GETHNDL 						;COPY POLY INTO HANDLE1
		IF		noROM THEN
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH POLYHANDLE
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	FROMRECT(A2)					;PUSH FROMRECT
		PEA 	TORECT(A2)						;PUSH TORECT
		_MAPPOLY 								;MAP POLY INTO DST COORDS
		MOVE.B	D7,-(SP)						;PUSH VERB
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH POLYHANDLE
		MOVE.L	PStdPoly,A0 					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	POLYPROC(A0),A0 				;NO, GET PROCPTR
@1		BRA 	CALL1							;CALL PROC AND QUIT
		ELSE
		jmpROM	RomPolyOP						; Jump into ROM
		ENDIF


;---------------------------------------------------
;
;  Rgn:  OP, RGN
;
RGNOP	CMP		#4,D7							;IS OPCODE VALID?
		BLE.S	RGNOK							;=>YES, CONTINUE
		TST.B	SAMEFLAG(A6)					;IS IT THE SAME RGN?
		BNE.S	@DONE							;=>YES, NO DATA
		BSR		GETHNDL							;ELSE READ IN THE RGN
@DONE	BRA		DONE							;AND RETURN

RGNOK	BSR 	GETHNDL 						;COPY RGN INTO HANDLE1
		IF		noROM THEN
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH RGN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	FROMRECT(A2)					;PUSH FROMRECT
		PEA 	TORECT(A2)						;PUSH TORECT
		_MAPRGN									;MAP RGN INTO DSTRECT COORDS
		MOVE.B	D7,-(SP)						;PUSH VERB
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH RGN
		MOVE.L	PStdRgn,A0						;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	RGNPROC(A0),A0					;NO, GET PROCPTR
@1		BRA 	CALL1							;CALL PROC, DISCARD AND QUIT
		ELSE
		jmpROM	RomRgnOP						; Jump into ROM
		ENDIF


;--------------------------------------------------------------------------
;
;  Quantities in brackets only read if high bit of rowbytes is set.
;
;  BitsRect:  	90, 	ROWBYTES, BOUNDS, [REST OF PIXMAP, COLORTABLE], 
;						SRCRECT, DSTRECT, MODE, BYTECOUNT, BITDATA
;
;  BitsRgn:   	91, 	ROWBYTES, BOUNDS, [REST OF PIXMAP, COLORTABLE], 
;						SRCRECT, DSTRECT, MODE,	MASKRGN, BYTECOUNT, BITDATA
;
;  PackBitsRect:98, 	ROWBYTES, BOUNDS, [REST OF PIXMAP, COLORTABLE], 
;						SRCRECT, DSTRECT, MODE,	BYTECOUNT, BITDATA
;
;  PackBitsRgn: 99, 	ROWBYTES, BOUNDS, [REST OF PIXMAP, COLORTABLE], 
;						SRCRECT, DSTRECT, MODE,	MASKRGN, BYTECOUNT, BITDATA
;
;  DirectBitsRect:9A, 	boguslong, ROWBYTES, BOUNDS, [REST OF PIXMAP], CLUT OPTIONAL,	<16Jun88 BAL>
;						SRCRECT, DSTRECT, MODE, BITDATA
;
;  DirectBitsRgn: 9B, 	boguslong, ROWBYTES, BOUNDS, [REST OF PIXMAP], CLUT OPTIONAL,	<16Jun88 BAL>
;						SRCRECT, DSTRECT, MODE,	MASKRGN, BITDATA
;

;  FIRST GET THE BITMAP/PIXMAP FROM THE PICTURE

; Support for 32 bit picts added 8/25/89 by KON

BITSOP	CMP		#3,D7							;CHECK OPCODE					<16Jun88 BAL>
		BGT		IGNORESHORT						;=>READ WORD LENGTH + DATA
		CMP		#1,D7							;IS IT INDEXED					<16Jun88 BAL>
		BLE.S	@IND							;YES DON'T SKIP BOGUS LONG		<16Jun88 BAL>
		JSR		GETLONG							;GET BOGUS LONG FROM PICTURE	<16Jun88 BAL>

@IND	JSR		GETWORD							;GET ROWBYTES FROM PICTURE
		MOVE	D0,SRCPIX+ROWBYTES(A6)			;SAVE ROWBYTES
		MOVEQ	#BITMAPREC-6,D1					;GET SIZE OF BITMAP
		MOVE	D0,D6							;IS IT A BITMAP OR A PIXMAP?
		BPL.S	BITSOP1							;=>IT'S A BITMAP
		MOVEQ	#PMREC-6,D1						;GET SIZE OF PIXMAP
BITSOP1	PEA		SRCPIX+BOUNDS(A6)				;PUSH ADDR OF SRCPIX.BOUNDS
		MOVE	D1,-(SP)						;PUSH BYTECOUNT
		JSR		GETPICDATA						;GET BITMAP/PIXMAP
		
; IF IT'S A PIXMAP, THEN ALLOCATE A COLOR TABLE AND GET IT FROM THE PICTURE
		
		TST		D6								;IS IT A PIXMAP?
		BPL.S	BITSOP2							;=>NO, DON'T GET TABLE
		move.l	srcPix+PMTable(a6),d6			;does it have a color table?	<KON 2NOV90>
		clr.l	srcPix+PMTable(a6)				;assume no clut					<12Jul88 BAL>
		BTST	#1,D7							;IS IT DIRECT DATA?				<16Jun88 BAL>
		bne.s	BITSOP2							;yes, no CLUT					<12Jul88 BAL>
;
; On indexed devices we convert the clut to a translation table
;
		MOVEQ	#CTREC,D0						;GET SIZE OF COLOR TABLE
		_NEWHANDLE								;GET A HANDLE FOR IT
		BNE		ABORT							;ABORT IF NO ROOM
		MOVE.L	A0,SRCPIX+PMTABLE(A6)			;SAVE COLOR TABLE HANDLE
		MOVE.L	A0,-(SP)						;PUSH COLOR TABLE HANDLE
		MOVE.L	A0,-(SP)						;AND AGAIN
		JSR		GETPICTABLE						;READ COLOR TABLE INTO HANDLE
		tst.l	d6								;NIL color table?				<KON 2NOV90>
		bne.s	Continue						;no, continue
; ??? ERROR HANDLING ???

;
; Color table was NIL on record.  If it's a dummy CTable, throw it away.  Value field
; of $4B4F in value field of 0th entry signals dummy table.
;
cTabSignature	EQU		$4B4F					;signature that PixMap has NIL color table (should be defined elsewhere)
		move.l	(sp),a0
		move.l	(a0),a2							;get ptr to color table
		cmp.w	#cTabSignature,ctTable(a2)		;signature there?
		bne.s	Continue						;no, then skip
		_DisposHandle							;throw away color table and make...
		clr.l	(sp)							;color table NIL
Continue
		MOVE.W	SRCPIX+PIXELSIZE(A6),-(SP)		;Push pixel size <27Feb87 DBG>
		JSR		CTBitMap						;COMPUTE TRANSLATION TABLE

BITSOP2	PEA 	SRCRECT(A6)						;PUSH ADDR OF SRCRECT
		MOVE	#16,-(SP)						;PUSH BYTECOUNT = 16
		JSR 	GetPicData						;GET SRCRECT,DSTRECT
		
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	DSTRECT(A6)
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_MAPRECT 								;MAP DSTRECT
		PEA 	SRCPIX(A6) 						;PUSH SRCPIX
		PEA 	SRCRECT(A6) 					;PUSH ADDR OF SRCRECT
		PEA 	DSTRECT(A6) 					;PUSH ADDR OF DSTRECT
		JSR 	GETWORD 						;GET MODE
		JSR		MAPMODE							;MAP TO EQUIVALENT MODE
		MOVE	D0,-(SP)						;PUSH MODE

		CLR.L	-(SP)							;ASSUME MASKRGN = NIL
		BTST 	#0,D7							;IS MASKRGN USED ?			<6Sep89 KON>
		BEQ.S	NOTRGN							;=> YES, USE NIL RGN

USERGN	BSR 	GETHNDL 						;GET MASKRGN INTO HANDLE1
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH MASKRGN
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	FROMRECT(A2)					;PUSH FROMRECT
		PEA 	TORECT(A2)						;PUSH TORECT
		_MAPRGN									;MAP RGN INTO DSTRECT COORDS
		MOVE.L	HANDLE1(A6),(SP)				;PASS MASKRGN
		MOVE.L	HANDLE1(A6),HANDLE2(A6) 		;AND REMEMBER MASKRGN IN HANDLE2

NOTRGN	MOVE	SRCPIX+BOUNDS+BOTTOM(A6),D6		;GET SRCPIX.BOTTOM
		SUB 	SRCPIX+BOUNDS+TOP(A6),D6		;CALC HEIGHT
		MOVE	D6,D5							;COPY HEIGHT
		MOVEQ	#0,D0							;CLEAR HIGH WORD
		MOVE	SRCPIX+ROWBYTES(A6),D0 			;GET BITMAP/PIXMAP ROWBYTES
		BPL.S	@NOTPIX							;SKIP IF NOT PIXMAP
		AND		#rbMask,D0						;CLEAR FLAG BITS
		MOVE	SRCPIX+PIXELSIZE(A6),D1			;GET PIXEL SIZE
		ADD		D1,D0							;ROUND UP TO NEAREST BYTE
		SUBQ	#1,D0							;(MINUS ONE FOR ROUNDING)
		DIVU	D1,D0							;GET 1-BIT ROWBYTES
		ADDQ	#1,D0							;MAKE SURE ROWBYTES...
		BCLR	#0,D0							;...IS EVEN
@NOTPIX
		MOVE	D0,SRCBITS+ROWBYTES(A6)			;COPY INTO SRCBITS
		MULU	D0,D5 							;CALC BITMAP SIZE
		add		#2,d5							;make sure we have enough room...
												;...for an extra long to slop over
		MOVE.L	D5,D0							;GET BYTECOUNT
		_NewHandle								;ALLOCATE BITS HANDLE
		BEQ.S	MEMOK							;CONTINUE IF NOT MEMFULL
		MOVE.L	(SP)+,A0						;POP MASKRGN (MAYBE NIL)
MemFailure										;Clean up handles and return <Halloween89 KON>
		_DisposHandle							;DISCARD IT
		TST		SRCPIX+ROWBYTES(A6)				;PIXMAP OR BITMAP <30Mar87 DBG>
		BPL.S	@NOTPIX2						;BITMAP-NO CTAB <30Mar87 DBG>
		MOVE.L	SRCPIX+PMTABLE(A6),A0			;GET COLOR TABLE
		_DisposHandle							;DISCARD IT
@NOTPIX2										; <30Mar87 DBG>
		BRA 	ABORT							;AND ABORT
MEMOK	_HLock									;LOCK HANDLE1
		MOVE.L	A0,HANDLE1(A6)					;REMEMBER IN HANDLE1		
		move.w	4(sp),d5						;get copy mode <07Sept89 KON>
		PEA		SRCPIX(A6)						;PUSH PIXMAP
		PEA		TXDATA(A6)						;PUSH XLATE TABLE <19Feb87 DBG>
		MOVE.L	A0,-(SP)						;PUSH HANDLE
		MOVE	SRCBITS+ROWBYTES(A6),-(SP)		;PUSH TARGET ROWBYTES
		move.w	d5,-(sp)						;push copy mode so we know whether... 
												;... or not to dither <07Sept89 KON>
		JSR		GETPM1Deep						;AND READ IN PIXMAP DATA
		tst.w	d0								;d0 = 0 indicates noErr
		beq.s	PixMapOK						;Error in getPM1Deep?	<Halloween89 KON>
		MOVE.L	HANDLE1(A6),A0					;Yes, clean-up and exit	<Halloween89 KON>
		bra.s	MemFailure				
		
PixMapOK
		and		#$FFFF-64,d5	;clear dither bit since we took care...
		move.w	d5,4(sp)		;of dithering in GetPM1Deep <07Sept89 KON>
		
		bclr	#1, d7			;clear bit 1 of low nibble of pict opcode
								;This bit tells whether or not it's a 32-bit
								;pixmap.  We don't need this info anymore,
								;and the rom checks the low nibble for zero
								;to determine if the pixmap is region clipped.
								;Since that won't work when we are using bit 1
								;to indicate 32-bit pixmap, we have to clear it!
								; <07Sept89 KON>
;	
; OK, now it's time to build a bit map which looks like the pixmap.  Use
; SRCBITS if it's really a PIXMAP (otherwise just use SRCPIX, since it's
; already set up).
;
DOBITS
		MOVE.L	HANDLE1(A6),A0					;GET HANDLE1
		MOVE.L	(A0),SRCPIX+BASEADDR(A6)		;FILL IN BASEADDR
		MOVE	SRCPIX+ROWBYTES(A6),D0			;GET ROWBYTES
		BPL.S	REALDO							;OLD BITMAP=>GO FOR IT!
		LEA		SRCBITS(A6),A1					;Point at SRCBITS
		MOVE.L	A1,(4+2+4+4)(SP)				;Smash source bmap parameter
		MOVE.L	(A0),(A1)+						;FILL IN BASEADDR
		ADDQ	#2,A1							;Skip ROWBYTES (done above)
		LEA		SRCPIX+BOUNDS(A6),A0			;GET BOUNDS
		MOVE.L	(A0)+,(A1)+						;COPY FIRST LONG
		MOVE.L	(A0),(A1)						;...AND SECOND
REALDO
		move.l	PStdBits_SE_Portable, a0		;	
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	BITSOK							;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	BITSPROC(A0),A0 				;NO, GET PROCPTR
BITSOK	JSR 	(A0)							;CALL BITSPROC
		MOVE.L	HANDLE1(A6),A0					;GET HANDLE1
		_HUnlock								;UNLOCK THE DATABITS
		TST		SRCPIX+ROWBYTES(A6)				;IS IT A PIXMAP?
		BPL.S	DOKILL							;=>NO, DON'T DISPOSE COLOR TABLE
		MOVE.L	SRCPIX+PMTABLE(A6),d0			;ELSE GET COLOR TABLE HANDLE
		beq.s	DoKill							;direct data, no clut
		move.l	d0,a0
		_DISPOSHANDLE							;AND DISPOSE OF IT
		IF		noROM THEN
DOKILL	TST 	#0,D7							;IS MASKRGN USED ?
		BEQ 	KILL1							;NO, DISCARD ONLY DATABITS
		BRA 	KILL2							;DISCARD MASKRGN & DATABITS
		ELSE
DOKILL	jmpROM	RomBits							;Jump into ROM
		ENDIF


;--------------------------------------------------------------------------
;
;	CTBitMap - Build bit map of black/white color mappings from a CTAB
;		PROCEDURE CTBitMap(theTable: CTabHandle; pixSize: INTEGER); <27Feb87 DBG>
;
CTBitMap
;
; Build a vector of bytes which indicates, for each of the colors in
; the pixmap's color table, whether that color should map to black or white.
;
		MOVE.L	6(SP),D0						;Table handle				<KON 2NOV90>
		move.l	d0,a0							;							<KON 2NOV90>
		bne.s	@ConvertTable					;convert table if non-zero
;
; Here we have a relative PixMap:  First invalidate all entries in destination.
;
		LEA		TXDATA(A6),A1					;Place to stick table 		<KON 2NOV90>
		MOVE.W	#256-1,D0						;Count of bytes 			<KON 2NOV90>
		MOVE.B	#$80,D2							;Marker					<KON 2NOV90>
@CLRLOOP										;
		MOVE.B	D2,(A1)+						;Clear entry to $80 		<KON 2NOV90>
		DBRA	D0,@CLRLOOP						;
;
; Make half of valid range (number of pixels) 0 and the other half one.
;
		MOVE	4(SP),D0						; Get pixel size 			<KON 2NOV90>
		MOVEQ	#1,D1							; Handy 1 bit 				<KON 2NOV90>
		ASL		D0,D1							; Compute #pixel values 	<KON 2NOV90>
		ADDQ	#1,d1							; Assumes cnt+1 at @join	<KON 15NOV90>
		LEA		TXDATA(A6),A1					; Start of table address	<KON 2NOV90>
		bra.s	@join

@ConvertTable
		MOVE.L	(A0),A0							;Table pointer
		ADDQ	#CTSize,A0						;POINT AT SIZE
		MOVE	(A0)+,D4						;GET SIZE(-1); POINT AT TABLE
;
; First, clear the entire mapping table to $80 so we can recognize pixel
; values which didn't get set by the color table.
;
		LEA		TXDATA(A6),A1					;Place to stick table <19Feb87 DBG>
		MOVE.W	#256-1,D0						;Count of bytes <27Feb87 DBG>
		MOVE.B	#$80,D2							; Marker <27Feb87 DBG>
@myCLRLOOP										; <27Feb87 DBG>
		MOVE.B	D2,(A1)+						;Clear entry to $80 <27Feb87 DBG>
		DBRA	D0,@myCLRLOOP					; <27Feb87 DBG>
;
; Now, set the corresponding bit value for every entry in the color table.
;
		LEA		TXDATA(A6),A1					;Get address again <27Feb87 DBG>
@CTLOOP
		MOVE	(A0)+,D2						;Get pixel value <19Feb87 DBG>
		jsr		RGB2Pixel						;GET BIT VALUE IN D0.B
		MOVE.B	D0,0(A1,D2.W)					;WRITE OUT THIS BYTE <19Feb87 DBG>
		DBRA	D4,@CTLOOP						;LOOP THROUGH COLOR TABLE
;
; Next, we must set a value for every pixel which isn't in the color table.
; Of all the undefined entries, the first half map to zero and the second
; to one (this approximates the ramp used by Color QuickDraw).
;
		MOVE	4(SP),D0						; Get pixel size <27Feb87 DBG>
		MOVEQ	#1,D1							; Handy 1 bit <27Feb87 DBG>
		ASL		D0,D1							; Compute #pixel values <27Feb87 DBG>
		MOVE.L	6(SP),A0						;Table handle <27Feb87 DBG>
		MOVE.L	(A0),A0							;Table pointer <27Feb87 DBG>
		ADDQ	#CTSize,A0						;POINT AT SIZE <27Feb87 DBG>
		MOVE	(A0),D4							;GET SIZE(-1) <27Feb87 DBG>
		SUB		D4,D1							;Calculate number of...<27Feb87 DBG>
@Join
		SUBQ	#1,D1							;...undefined entries <27Feb87 DBG>
		MOVE	D1,D4							;Make copy <27Feb87 DBG>
		ASR		#1,D4							;Divide by 2 <27Feb87 DBG>
		SUB		D4,D1							;Other half <27Feb87 DBG>
;
; Set all the pixels we want to set to zero, to zero.
;
@ZeroLoop										; <27Feb87 DBG>
		TST		D4								;Any left? <27Feb87 DBG>
		BEQ.S	@OneLoop						;Nope, do the ones <27Feb87 DBG>
@ZeroLoop2										; <27Feb87 DBG>
		TST.B	(A1)+							;Valid pixel?  <27Feb87 DBG>
		BPL.S	@ZeroLoop2						;Yup, do next <27Feb87 DBG>
		CLR.B	-1(A1)							;No, set to zero <27Feb87 DBG>
		SUBQ	#1,D4							;One less to set <27Feb87 DBG>
		BRA.S	@ZeroLoop						;Look for next guy <27Feb87 DBG>
;
; Now set all the one pixels to one.
;
@OneLoop										;<27Feb87 DBG>
		MOVEQ	#1,D0							; Get a one <27Feb87 DBG>
@OneLoop1										; <27Feb87 DBG>
		TST		D1								;Any left? <27Feb87 DBG>
		BEQ.S	@UndefDone						;Nope, do the ones <27Feb87 DBG>
@OneLoop2										; <27Feb87 DBG>
		TST.B	(A1)+							;Valid pixel?  <27Feb87 DBG>
		BPL.S	@OneLoop2						;Yup, do next <27Feb87 DBG>
		MOVE.B	D0,-1(A1)						;No, set to one <27Feb87 DBG>
		SUBQ	#1,D1							;One less to set <27Feb87 DBG>
		BRA.S	@OneLoop1						;Look for next guy <27Feb87 DBG>
@UndefDone										; <27Feb87 DBG>
;
; Return to the caller.
;
		MOVE.L	(SP)+,A0						;GET RETURN ADDRESS <27Feb87 DBG>
		ADD		#6,SP							;POP ARGUMENTS <27Feb87 DBG>
		JMP		(A0)							;RETURN <27Feb87 DBG>


;--------------------------------------------------------------------------
;
;  CommentOp:  OP, KIND, { SIZE, DATA }
;
COMMOP	TST.B	SAMEFLAG(A6)					;IS SAMEFLAG SET?
		BNE		IGNORESHORT						;=>YES, READ WORD LENGTH + DATA
		CMP		#1,D7							;$A0 OR $A1
		BGT		IGNORESHORT						;=>READ WORD LENGTH + DATA
	if 0 then
		BEQ		CALLUSERBOTTLEPROC
	endif
		JSR 	GETWORD 						;GET COMMENT KIND IN D0
		MOVE	D0,-(SP)						;PUSH FOR COMMENTPROC
		TST.B	D7								;IS THIS SHORT FORM ?
		BNE.S	LONGCOM 						;NO, GET MORE
	IF		noROM THEN
		CLR 	-(SP)							;YES, PUSH DATASIZE = 0
		CLR.L	-(SP)							;PUSH DATAHANDLE = NIL
		MOVE.L	PStdComment,A0					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	COMMENTPROC(A0),A0				;NO, GET PROCPTR
@1		BRA 	CALL0							;CALL PROC AND QUIT
	ELSE
		jmpROM	RomCommentOP					; Jump into ROM
	ENDIF

LONGCOM JSR 	GETWORD 						;GET DATASIZE
		MOVE	D0,-(SP)						;PUSH DATASIZE
		CLR 	D4								;INIT BYTE INDEX FOR GETHND2
		BSR.S	GETHND2 						;GET DATA INTO HANDLE1
	IF		noROM THEN
		MOVE.L	HANDLE1(A6),-(SP)				;PUSH DATA HANDLE
		MOVE.L	PStdComment,A0					;get piece of trap table
		MOVE.L	GRAFPROCS(A3),D0				;IS GRAFPROCS NIL ?
		BEQ.S	@1								;YES, USE STD PROC
		MOVE.L	D0,A0
		MOVE.L	COMMENTPROC(A0),A0				;NO, GET PROCPTR
@1		BRA 	CALL1							;CALL PROC, DISCARD AND QUIT
	ELSE
		jmpROM	RomLongCom						; Jump into ROM
	ENDIF
	if 0 then
CALLUSERBOTTLEPROC
		JSR		GETWORD							;GET DATA LENGTH
		MOVE.L	D0,D2							;SAVE IT FOR A SEC
		_NEWHANDLE
		BNE.S	NOMEMORY						;READ BYTES AND ABORT
		_HLOCK									;IT BETTER NOT MOVE!
		MOVE.L	A0,HANDLE1(A6)					;SAVE HANDLE
		MOVE.L	(A0),-(SP)						;POINTER TO MEMORY
		MOVE	D2,-(SP)						;PUSH BYTECOUNT
		JSR 	GETPICDATA						;GET SRCRECT,DSTRECT
		MOVE.L	HANDLE1(A6),A0					;GET HANDLE
		LEA		GETPICDATA,A1
		MOVE.L	PLAYSTATE(A6),A2
		MOVE.L	(A0),A0							;GET ADDRESS TO CALL
		BRA		CALL1							;CALL IT
NOMEMORY
		MOVE.L	D2,D0							;GET COUNT TO IGNORE
		BRA		IGCOUNT							;IGNORE BYTES IN D0
	endif
;-----------------------------------------------------
;
;  GET SOME BYTES AND QUIT
;
GETDONE MOVE.L	A3,-(SP) 			  	 		;PUSH DATAPTR
		MOVE	D6,-(SP) 			  	 		;PUSH BYTECOUNT
		JSR		GetPicData			   			;GET DATA FROM THEPIC
		BRA		DONE



GETRECT
;----------------------------------------------------------
;
;  LOCAL PROCEDURE TO SET UP AND PUSH DSTRECT AS FOLLOWS:
;  IF NOT SAMEFLAG, THEN GET NEXT 8 BYTES INTO THERECT.
;  THEN MAP THERECT INTO DSTRECT, AND PUSH ADDR OF DSTRECT.
;  CLOBBERS A0,D0
;
		TST.B	SAMEFLAG(A6)					;SAME RECT ?
		BNE.S	SAME1							;YES, CONTINUE

		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		PEA 	THERECT(A2) 					;PUSH ADDR OF THERECT
		MOVE	#8,-(SP)						;PUSH BYTECOUNT
		JSR 	GetPicData						;GET DATA FROM THEPIC

		IF		noROM THEN
SAME1	MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		MOVE.L	THERECT(A2),DSTRECT(A6) 		;COPY THERECT INTO DSTRECT
		MOVE.L	THERECT+4(A2),DSTRECT+4(A6)
		PEA 	DSTRECT(A6)
		PEA 	FROMRECT(A2)
		PEA 	TORECT(A2)
		_MAPRECT 								;MAP DSTRECT
		MOVE.L	(SP)+,A0						;POP RETURN ADDR
		PEA 	DSTRECT(A6) 					;PUSH ADDR OF MAPPED DSTRECT
		JMP 	(A0)							;RETURN
		ELSE
SAME1	jmpROM	RomGetRect
		ENDIF

GETHNDL	
;--------------------------------------------------------
;
;  LOCAL ROUTINE TO ALLOCATE, AND COPY HANDLE1
;
;  CLOBBERS D0-D2,A0-A1,D4,D5
;
;  TRICKY ENTRY AT GETHND2 WITH COUNT IN D0, D4 = 0
;
		MOVEQ	#2,D4							;INIT BYTE OFFSET FOR LATER
		JSR 	GETWORD 						;GET BYTECOUNT
GETHND2 
		EXT.L	D0								;MAKE COUNT LONG
		MOVE.L	D0,D5							;PUT BYTECOUNT INTO D5
		_NewHandle								;ALLOCATE HANDLE
		BNE.S	ABORT							;ABORT IF MEMFULL
		MOVE.L	A0,HANDLE1(A6)					;SAVE IN HANDLE1
		_HLock									;LOCK HANDLE1
		MOVE.L	(A0),A0 						;DE-REFERENCE IT
		MOVE	D5,(A0) 						;INSTALL SIZE WORD
		SUB 	D4,D5							;ADJUST COUNT
		PEA 	0(A0,D4)						;PUSH DATAPTR
		MOVE	D5,-(SP)						;PUSH BYTECOUNT
		JSR 	GetPicData						;GET DATA FROM THEPIC
		MOVE.L	HANDLE1(A6),A0					;GET HANDLE 1
		_HUnLock								;UNLOCK IT
		RTS 									;AND RETURN
		
		
GetPicOp
;------------------------------------------------------
;
;  LOCAL PROCEDURE TO GET NEXT OPCODE FROM PICTURE INTO D0
;
		MOVE.L	PLAYSTATE(A6),A2				;POINT TO PLAYSTATE RECORD
		CMP		#PICTVERSION,PLAYVERSION(A2)	;IS IT AN OLD PICTURE?
		BEQ.S	OLDPIC							;=>YES, GET ONE-BYTE OPCODE
		MOVE.L	GRAFGLOBALS(A5),A0				;POINT TO QUICKDRAW GLOBALS
		MOVE.L	PLAYINDEX(A0),D0				;GET CURRENT POSITION
		BTST	#0,D0							;IS IT ODD?
		BEQ.S	NOTODD							;=>NO, JUST FETCH OPCODE
		JSR		GETUBYTE						;ELSE SKIP PAD BYTE
NOTODD	JSR		GETWORD							;GET OPCODE WORD IN D0
		RTS										;AND RETURN
		
OLDPIC	JSR 	GETUBYTE						;GET OPCODE BYTE IN D0
		RTS										;AND RETURN


;-----------------------------------------------------------------
;
;  CALL BOTTLENECK PROC, DISPOSE OF ONE OR TWO HANDLES, AND QUIT
;
CALL0	JSR 	(A0)							;CALL PROC PTR
		BRA.S	DONE							;AND QUIT

CALL1	JSR 	(A0)							;CALL PROC PTR
		BRA.S	KILL1							;KILL HANDLE1 AND QUIT

;  KILL ONE OR TWO HANDLE TEMPS

KILL2	MOVE.L	HANDLE2(A6),A0					;GET HANDLE2
		_DisposHandle							;DISCARD IT

		IF		noROM THEN
KILL1	MOVE.L	HANDLE1(A6),A0					;GET HANDLE1
		_DisposHandle							;DISCARD IT
		BRA.S	DONE

ABORT	MOVE.L	SAVEDSP(A6),SP					;RESTORE STACK
		CLR.B	RESULT(A6)						;RETURN FALSE

DONE	MOVEM.L (SP)+,D3-D7/A2-A4				;RESTORE REGISTERS
		UNLINK	PARAMSIZE,'PICITEM1'			;destroys condition codes
		ELSE
KILL1	jmpROM	RomKill1						; Jump into ROM
ABORT	jmpROM	RomAbort						; Jump into ROM
DONE	jmpROM	RomDone							; Jump into ROM
		ENDIF

	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop

		ENDPROC

