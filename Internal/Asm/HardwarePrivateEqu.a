;__________________________________________________________________________________________________
;
;	File:		HardwarePrivateEqu.a
;
;	Contains:	Macintosh assembly equates THAT ARE NOT TO BE RELEASED TO THE WORLD.
;
;	Copyright:	© 1990-1993 by Apple Computer, Inc.  All rights reserved.
;
;	Change History (most recent first):
;
;	  <SM27>	  8/4/93	JDR		private sound defines are in SoundPrivate.a
;	  <SM22>	 3/31/93	chp		Synchronize SuperMario with changes from <LW2>.
;	   <LW2>	 2/24/93	chp		Added equates for the PSC wait/request multiplexer control bits
;									in VIA1.
;	  <SM13>	 8/17/92	CCH		Bumped HeapStart to $2800.
;	  <SM12>	  8/7/92	JDB		Changed Singer control register to have 0 for the output
;									attenuation and  5 for the input gain.
;	  <SM11>	07-14-92	jmp		(ag,H24) Change the name of a bit from PontiSndExtMic to
;									PontiSndIntMic
;									(jmp,H23) Added some additional DAFB equates for the WombatDAFB
;									code.
;									(BG,H22) Added one more djMEMC-related symbolic definition
;									(dj_MaxBanks).
;	  <SM10>	 6/21/92	ejb		Adding bit field definitions for dspOverrun register in PSC.
;	   <SM9>	 6/21/92	RB		Adding runtime support for EVT1 and EVT2 Cyclones. Defined
;									temporary equates for  the EVT1 Cyclone units.
;	   <SM8>	 6/18/92	KW		(BG,H21) Added djMEMC memory controller equates for Wombat and
;									WLCD.
;									(jmp,H20) Wombat has a different dot-clock chip than
;									Spike/Eclipse/Zydeco, so I added an equate to reflect this.
;	   <SM7>	 6/18/92	RB		Added equates for the new EVT2 (final offsets) of the VIA2 on
;									Cyclone. The old values are still supported under the
;									conditional forEVT1. These should be deleted once everyone moves
;									to EVT2 boards. Did the same with MUNIBase as well.
;	   <SM6>	  6/4/92	KW		(fau,P18) Added and equate for Civic_VidInDble to support Civic
;									II.
;	   <SM5>	 5/25/92	RB		Removed a forCyclone conditional. This should be the last one
;									left. Renamed MSCBank1Enable to MSCBank8M.
;	   <SM4>	 5/21/92	RB		Making changes for Cyclone. Some comments may be duplicated due
;									to the Pandora/Terror history. <P17> 5/13/92 KW (ag,H18) Added
;									Ponti Definitions. (BG,H17) Added symbol v2MicCtl to the VIA2
;									bit definitions. This is a microphone control bit that is
;									defined for Wombat. Also updated some comments from Eclipse and
;									Zydeco to the appropriate Quadra names. <P16> 4/16/92 KW (SWC,
;									H16) Set bufWorldSize to 8K so Macsbug won't load into the
;									middle of DBLite's sound buffer and get trashed when a sound is
;									played. <P15> 03/24/92 jmp Renamed one of the MMC registers to
;									something more appropriate (i.e., MMC_Interlace to
;									MMC_ClockSelect). <P14> 03/22/92 jmp Put back <P12>. <P13>
;									3/19/92 FU Rolled back changes in <P12>. <P12> 3/18/92 FU
;									(SWC,H15) Added SCSI DiskMode bit definitions for Niagra to the
;									VIA 1 list. <P11> 03/04/92 jmp Updated the comments and changed
;									the names of some of the Civic-related equates. <P10> 02/28/92
;									jmp (ejb) Turned off the DSP frame-interrupt enable bit so that
;									DSP driver doesn’t suffer frame overrun when it trys to boot the
;									DSP. <P9> 02/20/92 jmp (JC,H14) Define PatchFlags in unused by
;									of ROM header ($0014). Define PatchBits based on available
;									features in BBSStartup. Include support for Horror based and
;									Pandora (Cyclone) based ROMs. <P8> 2/19/92 chp (jmp,H13) Put a
;									“hasSonora1” conditional around the Sonora video control
;									register base address to reflect impending hardware changes to
;									Sonora. <P7> 02/07/92 jmp (HJR,H12) Added new Niagra Equates.
;									(SWC,H11) One more go-round on MSC configuration: RAM bank 1
;									needs to be disabled since there's only 2MB on DBLite LC.
;									(SWC,H10) Fixed the MSC configuration value: it needs to be
;									setup for a minimum amount of RAM so that the sound FIFO will
;									always exist in real RAM for BootBeep. (SWC,H9) Added an equate
;									for the default MSC configuration register value. Also, added
;									Civic and Civic-related equates for Cyclone. <P6> 2/5/92 RMP
;									Added MUNI equates. <P5> 1/21/92 mal Added PSC VIA2 equates <P4>
;									1/18/92 RMP Added PSC sound equates. <P3> 1/15/92 RP Fixed
;									header (sorry). <P2> 1/15/92 RP Added new VIA definition bits
;									and MMC equates.
;	   <SM3>	 5/17/92	kc		Roll in Horror Changes. Comments follow:
;	   <H16>	  4/8/92	SWC		Set bufWorldSize to 8K so Macsbug won't load into the middle of
;									DBLite's sound buffer and get trashed when a sound is played.
;	   <H15>	  3/3/92	SWC		Added SCSI DiskMode bit definitions for Niagra to the VIA 1
;									list.
;	   <H14>	 2/19/92	JC		Define PatchFlags in unused by of ROM header ($0014). Define
;									PatchBits based on available features in BBSStartup.  Include
;									support for Horror based and Pandora (Cyclone) based ROMs.
;	   <H11>	 1/23/92	SWC		One more go-round on MSC configuration: RAM bank 1 needs to be
;									disabled since there's only 2MB on DBLite LC.
;	   <H10>	 1/22/92	SWC		Fixed the MSC configuration value: it needs to be setup for a
;									minimum amount of RAM so that the sound FIFO will always exist
;									in real RAM for BootBeep.
;		<H9>	 1/22/92	SWC		Added an equate for the default MSC configuration register
;									value.
;		<H8>	12/20/91	JC		Create common Via2/RBV offset equates and temporary redefinition
;									on Sonora Specific builds to only use RBV offsets
;		<H6>	12/03/91	jmp		Added various (but not yet complete) SonoraAddr and
;									Sonora-VDACAddr equates.  Sorry to have cancelled your check-out
;									swc, but we had pressing needs.
;		<H5>	11/26/91	jmp		Added equates for the GSC.
;		<H4>	11/25/91	SAM		Added Sonora specific equate for RAMSize reg.
;		<H2>	  8/5/91	SWC		Added MSCPowerCycle, the offset to the power cycle register from
;									the base of the MSC.

;	   <T21>	  7/8/91	HJR		Rename JAWSAuxWaitS to JAWSEconoMode register to reflect its new
;									pupose in life.
;	   <T20>	 5/24/91	jmp		Added another VIA2, port A, bit-7 equate for Spike & Eclipse:
;									v2SyncOnGreen.  This bit allows us to enable & disable the
;									sync-on-green signal in ACDC.
;	   <T19>	 5/10/91	djw		Add sound input select bits for Eclipse in VIA2
;	   <T18>	  5/1/91	HJR		Added in register definitions for the MSC memory controller
;									(DB-Lite).
;	   <T17>	  4/1/91	BG		Modified the v2Keyswitch bit definition to agree with what it
;									will be on DVT Eclipse.
;	   <T14>	  3/3/91	BG		Added bit definition for Eclipse Keyswitch bit in VIA2.
;	   <T12>	 2/16/91	BG		Added Orwell constants to deal with 33MHz.
;		<T8>	 1/18/91	CCH		Added equates for Spike's VIA2.
;		<T6>	 11/7/90	BG		Made changes for new rev. of Orwell (2) permanent.
;	   <SM2>	 4/22/92	RB		Moved the start of the System heap in order to get some space
;									for vector tables. This movement of the heap from $2000 to $2100
;									is for experimentation and will need to be changed at a later
;									date.
;		<35>	12/31/91	RB		Renamed JAWSAuxWaitS to JAWSEconoMode to reflect its real
;									purpose.
;		<34>	12/29/91	RB		Updated some of the Terror constants.
;		<33>	10/28/91	SAM/KSM	Rolled in Regatta file.
;
;	Regatta Change History:
;
;		 <2>	  8/8/91	SAM		(pdw, ag) Added some equates from HardwarePrivateEqu in
;									TERROR.
;		 <1>	  8/8/91	SAM		Split off from 7.0 GM sources.
;
;	7.0 Change History:
;
;		<32>	 10/1/91	JSM		Don’t use eclipseDebug.
;		<31>	 8/30/91	DTY		Complicate matters so onMac32 stuff doesn’t get defined for
;									onMac, onMacPP, or onMacHc. (Since these aren’t defined in
;									BBSStartup anymore, this is necessary.)
;		<30>	 8/22/91	JSM		Clean up header.
;		<29>	 7/24/91	MH		Added conditional wrapper(s) to prevent duplication of public
;									interface declarations: TimeSCSIDB
;		<28>	 1/30/91	gbm		sab, #38: Change the ‘already including this file’ variable to
;									all uppercase (for security reasons)
;		<27>	11/26/90	gbm		(and bbm) On 7.0 (and other places eventually) HiIntMask will be
;									$0700 instead of $0300 all the time, not just when on a
;									non-Plus.
;		<26>	10/22/90	JJ		Rex V8: Added equates for V8 registers
;		<25>	 9/24/90	BG		Added symbolic names for the Data and Instruction Cache enable
;									bits for the CACRs of various machines.
;		<24>	 9/13/90	MSH		A couple of VIA2 assignments have changed for TIM.
;		<23>	  9/1/90	BG		Updated and added various constants to agree with the EVT1
;									version of the Eclipse board.
;		<22>	 7/11/90	gbm		Take out some things that are in SysEqu.a
;		<21>	  7/6/90	CCH		Changed default ROM wait states and RAM refresh rate for
;									Eclipse.
;		<20>	 6/27/90	CCH		Took out the conditionals around TestInRam!
;		<19>	 6/27/90	CCH		TestInRAM macro gets compiled when eclipseDebug is set.
;		<18>	 5/24/90	HJR		Update Machine equate to 7 instead of 6 for newer machines.
;		<16>	  4/4/90	HJR		Clean up some build problems.
;		<15>	  4/4/90	MSH		forrom removal.
;		<14>	  4/4/90	MSH		Merged HardwareEqu.a back into HardwarePrivateEqu.a and
;									restructured/rewrote the resultant file. This action obsoletes
;									HardwareEqu.a. All future equate additions should be done to
;									HardwarePrivateEqu.a only.
;		<13>	 3/29/90	MSH		Add VIA2 labels for Waimea.
;		<12>	 3/22/90	JJ		Force definition of onElsie=0 if onElsie is undefined.
;		<11>	 2/14/90	DAF		Added VISA register names.  Since Elsie isn't fully integrated,
;									it doesn't have  real feature conditional yet.
;		<10>	  2/9/90	BG		Modified ORWELL_INIT value to reflect the parts being used on
;									the Eclipse prototype.
;		 <9>	  2/9/90	JJ		Added RvExp, offset of RBV Expansion Register in Elsie.
;		 <8>	  2/9/90	BG		Moved EQUs for the Eclipse VIA2 out of the -ELSEIF onEclipse-,
;									as those definitions will be used even if the -onEclipse-
;									conditional stuff is not used.
;		 <7>	  2/2/90	BG		Missed one re-definition in previous change.
;		 <6>	  2/2/90	BG		Modified some bits in the Eclipse VIA2 buffer A description to
;									have relevant mnemonic names.
;		 <5>	 1/31/90	BG		Added Orwell-specific register bit definitions, address offsets
;									and configuration register initial values.
;		 <4>	 1/30/90	BG		Added Eclipse-specific hardware constant definitions.
;		 <3>	 1/18/90	SWC		Updating FMCInit and FMCRPUInit with the final values.
;		 <2>	 1/12/90	CCH		Added missing ENDIF.
;		 <1>	 1/11/90	CCH		Moved in private equates from “HardwareEqu.a”.
;
;	NOTE:
;
;		For change history versions not mentioned in the above -Change History-, refer
;		to <Sources>:Interfaces:AIncludes:HardwareEqu.a.
;

	IF &TYPE('__INCLUDINGHARDWAREPRIVATEEQU__') = 'UNDEFINED' THEN
__INCLUDINGHARDWAREPRIVATEEQU__	SET	1


  				IF  		(&TYPE('onMac') = 'UNDEFINED') THEN 
onMac 			EQU 		0
  				ENDIF

  				IF  		(&TYPE('onMacPP') = 'UNDEFINED') THEN
onMacPP   		EQU 		0
  				ENDIF

  				IF  		(&TYPE('onNuMac') = 'UNDEFINED') THEN
onNuMac   		EQU 		0
  				ENDIF

  				IF  		(&TYPE('onHafMac') = 'UNDEFINED') THEN
onHafMac   		EQU 		0
  				ENDIF

  				IF  		(&TYPE('onHcMac') = 'UNDEFINED') THEN
onHcMac   		EQU 		0
  				ENDIF

  				IF  		(&TYPE('onMac16') = 'UNDEFINED') THEN
onMac16   		EQU 		0
  				ENDIF

  				IF  		(&TYPE('onMac32') = 'UNDEFINED') THEN
onMac32   		EQU 		0
  				ENDIF

onAnything		EQU 		onMac|onMacPP|onHcMac|onHafMac|onNuMac|onMac16|onMac32


; *** If HWNonPortable is defined to be non-zero, Then a machine type must be specified!
; *** If a machine is specified, HWNonPortable must be non-zero, specified or not.
  				IF  		(&TYPE('HWNonPortable') = 'UNDEFINED') THEN
HWNonPortable 	EQU 		onAnything
  				ENDIF


;__________________________________________________________________________________________
;
; Welcome to the New Hardware Equates File.  By following some simple procedures this file
; can keep its youthful appearance for years to come.  This file is a recombination of
; HardwareEqu.a and HardwarePrivateEqu.a.  Everyone should be using this file only.  Please
; change any of your files that use either of the hardware equate files to use only this one.
; HardwareEqu.a will be left as an historical artifact for future generations.
;
; To help you navigate through this file use the "Mark" menu item, and please help to keep
; it current.  When you add a new section, add a handy mark to find it again.  Equates are
; grouped in a semi-logical way in the follwing order:
;
;		Chip Offsets - Register offsets for the 'standard' Mac peripheral chips.
;		Chip Offsets 2 - Register offsets for the 'non-standard' Mac peripheral chips.
;		VIA1 - Register offsets and pin descriptions.
;		VIA2 - Register offsets and pin descriptions.
;		RBV - Register offsets and pin descriptions.
;		VISA - Register offsets and pin descriptions.
;		Memory Controllers - Register definitions and miscellaneous equates.
;		Interrupts - Auto vector names and mask definitions.
;		Miscellaneous - The "Smorgasboard" of equates.
;		Old 16 Bit Equates - Machine dependent equates for Mac, MacPP, HcMac, and Mac16.
;
;
;__________________________________________________________________________________________





;__________________________________________________________________________________________
;
;
; Chip Offsets - Register offsets for "standard" Mac chips.  This includes the following:
;				 IWM, SWIM, SCC, SCSI (with and without DMA), ASC.
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
; IWM Offsets
;---------------------------------------------------

ph0L  			EQU 		0 						; disk address offsets from base
ph0H  			EQU 		$200
ph1L  			EQU 		$400
ph1H  			EQU 		$600
ph2L  			EQU 		$800
ph2H  			EQU 		$A00
ph3L  			EQU 		$C00
ph3H  			EQU 		$E00
mtrOff			EQU 		$1000
mtrOn 			EQU 		$1200
intDrive  		EQU 		$1400 					; enable internal drive address
extDrive  		EQU 		$1600 					; enable external drive address
q6L   			EQU 		$1800
q6H   			EQU 		$1A00
q7L   			EQU 		$1C00
q7H   			EQU 		$1E00

IWMInitMode		equ			$17						; initial IWM mode setting				<3.5>

;---------------------------------------------------
;  SWIM offsets
;---------------------------------------------------

wData 			EQU 		$0000 					;Write a data byte
wMark 			EQU 		$0200 					;Write a mark byte
wCRC  			EQU 		$0400 					;Write a 2-byte CRC (1 access does both)
wIWMConfig		EQU 		wCRC  					;Set IWM configuration
wParams   		EQU 		$0600 					;Set the 16 parameter registers
wPhase			EQU 		$0800 					;Set phase lines states and directions
wSetup			EQU 		$0A00 					;Set the current configuration
wZeroes   		EQU 		$0C00 					;Mode reg: 1's clr bits, 0's=don't care
wOnes 			EQU 		$0E00 					;Mode reg: 1's set bits, 0's=don't care
rData 			EQU 		$1000 					;Read a data byte
rCorrection   	EQU 		rData 					;Read the correction factor
rMark 			EQU 		$1200 					;Read a mark byte
rError			EQU 		$1400 					;Error register
rParams   		EQU 		$1600 					;Parameters (16 bytes deep at this addr)
rPhase			EQU 		$1800 					;Phase lines states and directions
rSetup			EQU 		$1A00 					;Read the current configuration
rStatus   		EQU 		$1C00 					;Status (returns current mode reg value)
rHandshake		EQU 		$1E00 					;Handshake register


;---------------------------------------------------
; 8530 SCC Offsets
;---------------------------------------------------

aData 			EQU 		6 						; offset for A channel data
aCtl  			EQU 		2 						; offset for A channel control
bData 			EQU 		4 						; offset for B channel data
bCtl  			EQU 		0 						; offset for B channel control
sccData   		EQU 		4 						; general offset for data from control
rxBF  			EQU 		0 						; SCC receive buffer full
txBE  			EQU 		2 						; SCC transmit buffer empty
RxCA			EQU			0						; Receive Character Available


;---------------------------------------------------
; 53C80 SCSI Register Defs, Offsets
;---------------------------------------------------

sCDR  			EQU 		$00   					; Current SCSI Read Data
sODR  			EQU 		$00   					; Output data register
sICR  			EQU 		$10   					; Initiator Command Register - READ/WRITE
iRST  			EQU 		$80   					; *RST asserted
iAIP  			EQU 		$40   					; arbitration in progress (read)
bAIP  			EQU 		6 						; bit test for arbitration in progress
aTMD  			EQU 		$40   					; assert Test Mode (write)
iLA   			EQU 		$20   					; Lost arbitration (read)
bLA   			EQU 		5 						; bit test for Lost Arbitration
aDIFF 			EQU 		$20   					; assert Differential enable (write)
iACK  			EQU 		$10   					; *ACK is asserted
iBSY  			EQU 		$08   					; *BSY is asserted
iSEL  			EQU 		$04   					; *SEL is asserted
iATN  			EQU 		$02   					; *ATN is asserted
iDB   			EQU 		$01   					; Data bus is asserted
sMR   			EQU 		$20   					; Mode Register - READ/WRITE
iBDMA 			EQU 		$80   					; Block Mode DMA
iTGT  			EQU 		$40   					; Target Mode
iPTY  			EQU 		$20   					; Enable Parity Checking
iIPTY 			EQU 		$10   					; Enable Parity interrupt
iIEOP 			EQU 		$08   					; Enable EOP interrupt
iMBSY 			EQU 		$04   					; Monitor BSY
iDMA  			EQU 		$02   					; DMA Mode
iARB  			EQU 		$01   					; Arbitration
sTCR  			EQU 		$30   					; Target Command Register - READ/WRITE
iREQ  			EQU 		$08   					; Assert *REQ
iMSG  			EQU 		$04   					; Assert *MSG
iCD   			EQU 		$02   					; Assert C/*D
iIO   			EQU 		$01   					; Assert I/*O
sCSR  			EQU 		$40   					; Current SCSI Bus Status (READ)
aRST  			EQU 		$80   					; *RST
aBSY  			EQU 		$40   					; *BSY
bBSY  			EQU 		6 						; bit test for *BSY
aREQ  			EQU 		$20   					; *REQ
bREQ  			EQU 		5 						; bit test for *REQ
aMSG  			EQU 		$10   					; *MSG
bMSG  			EQU 		4 						; bit test for *MSG
aCD   			EQU 		$08   					; C/*D
bCD   			EQU 		3 						; bit test for C/*D
aIO   			EQU 		$04   					; I/*O
bIO   			EQU 		2 						; bit test for I/*O
aSEL  			EQU 		$02   					; *SEL
bSEL  			EQU 		1 						; bit test for *SEL
aDBP  			EQU 		$01   					; *DBP
sSER  			EQU 		$40   					; Select Enable Register (WRITE)
sBSR  			EQU 		$50   					; Bus & Status Register (READ)
iEDMA 			EQU 		$80   					; End of DMA
bEDMA 			EQU 		7 						; bit test for end of DMA
iDMAR 			EQU 		$40   					; DMA Request
bDMAR 			EQU 		6 						; bit test for DMA Req
iPERR 			EQU 		$20   					; Parity Error
iIREQ 			EQU 		$10   					; Interrupt Request
bIREQ 			EQU 		4 						; bit test for interrupt
iPM   			EQU 		$08   					; Phase Match
bPM   			EQU 		3 						; bit test for Phase Match
iBERR 			EQU 		$04   					; Bus Error
ATN   			EQU 		$02   					; *ATN
ACK   			EQU 		$01   					; *ACK
bACK  			EQU 		0 						; bit test for ACK
sDMAtx			EQU 		$50   					; DMA Transmit Start (WRITE)
sIDR  			EQU 		$60   					; Data input register (READ)
sTDMArx   		EQU 		$60   					; Start Target DMA receive (WRITE)
sRESET			EQU 		$70   					; Reset Parity/Interrupt (READ)
sIDMArx   		EQU 		$70   					; Start Initiator DMA receive (WRITE)


;---------------------------------------------------
;  SCSI DMA chip register offsets
;---------------------------------------------------

;  Note that the 53C80 registers are provided on the SCSI DMA chip.  The registers
;  described here are in addition to the 53C80 registers.

sDCTRL			EQU			$80
bDMAEN			EQU			0						; bit to enable SCSI DMA
iDMAEN			EQU			$0001					; mask to enable SCSI DMA
bINTREN			EQU			1						; bit to enable SCSI DMA interrupts
iINTREN			EQU			$0002					; mask to enable SCSI DMA interrupts
bTIMEEN			EQU			2						; bit to enable watchdog timer intr's
iTIMEEN			EQU			$0004					; mask to enable watchdog timer intr's
bHSKEN			EQU			3						; bit to enable hardware-handshaking (write)
iHSKEN			EQU			$0008					; mask to enable hardware-handshaking (write)
bRESET			EQU			4						; bit to reset SCSI DMA chip (write)
iRESET			EQU			$0010					; mask to reset SCSI DMA chip (write)
bFIFO			EQU			4						; bit indicating bytes left in FIFO (read)
iFIFO			EQU			$0010					; mask indicating bytes left in FIFO (read)
bTEST			EQU			5						; bit to enable SCSI Test Mode (write)
iTEST			EQU			$0020					; mask to enable SCSI Test Mode (write)
bSCSIP			EQU			6						; bit indicating SCSI intr pending (read)
iSCSIP			EQU			$0040					; mask indicating SCSI intr pending (read)
bTIMEP			EQU			7						; bit indicating timer intr pending (read)
iTIMEP			EQU			$0080					; mask indicating timer intr pending (read)
bDMABERR		EQU			8						; bit indicating DMA bus error (read)
iDMABERR		EQU			$0100					; mask indicating DMA bus error (read)
iARBID			EQU			$0E00					; mask to get target ID for arbitration
bARBIDEN		EQU			12						; bit to enable hardware arbitration
iARBIDEN		EQU			$1000					; mask to enable hardware arbitration
bWONARB			EQU			13						; bit indicating successful arbitration
iWONARB			EQU			$2000					; mask indicating successful arbitration
iINFIFO			EQU			$C000					; mask to get bytes left in FIFO (read)

sDCNT			EQU			$C0

sDADDR			EQU			$100

sDTIME			EQU			$140

sTEST			equ			$180

;__________________________________________________________________________________________
;
;
; Chip Offsets - Register offsets for "non standard" Mac chips.  This includes the following:
;				 OSS and IOP.
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
;  OSS (Operating System Support) Chip Address & Offsets
;---------------------------------------------------

OSSMskFirst		equ			$000					;offset to first interrupt mask register
OSSMskSlot9		equ			OSSMskFirst				;offset to slot 9 interrupt mask register
OSSMskSlotA		equ			$001					;offset to slot A interrupt mask register
OSSMskSlotB		equ			$002					;offset to slot B interrupt mask register
OSSMskSlotC		equ			$003					;offset to slot C interrupt mask register
OSSMskSlotD		equ			$004					;offset to slot D interrupt mask register
OSSMskSlotE		equ			$005					;offset to slot E interrupt mask register
OSSMskPSwm		equ			$006					;offset to SWIM PIC interrupt mask register
OSSMskPScc		equ			$007					;offset to SCC PIC interrupt mask register
OSSMskSnd		equ			$008					;offset to Sound interrupt mask register
OSSMskScsi		equ			$009					;offset to SCSI interrupt mask register
OSSMsk60Hz		equ			$00A					;offset to 60 Hz interrupt mask register
OSSMskVia1		equ			$00B					;offset to VIA1 interrupt mask register
OSSMskRTC		equ			$00C					;offset to RTC interrupt mask register
OSSMskADB		equ			$00D					;offset to ADB interrupt mask register (not used)		<5.1>
OSSMskRPU		equ			$00E					;offset to RPU interrupt mask register					<4.8>
OSSMskLast		equ			OSSMskRPU				;offset to last interrupt mask register

rpuReset		EQU			$010					; RPU write offset to reset serial ptr					<4.9>

OSSIntStat		equ			$202					;offset to interrupt status register. Bits are:			<3.7>
													;  15:  interrupt 15 (spare) pending
													;  14:  interrupt 14 (RPU) pending						<4.8>
													;  13:  interrupt 13 (spare) pending					<5.1>
													;  12:  interrupt 12 (RTC) pending
													;  11:  interrupt 11 (VIA1) pending
													;  10:  interrupt 10 (60 Hz) pending
													;   9:  interrupt 9 (SCSI) pending
													;   8:  interrupt 8 (sound) pending
													;   7:  interrupt 7 (SCC PIC) pending
													;   6:  interrupt 6 (SWIM PIC) pending
													;   5:  interrupt 5 (slot E) pending
													;   4:  interrupt 4 (slot D) pending
													;   3:  interrupt 3 (slot C) pending
													;   2:  interrupt 2 (slot B) pending
													;   1:  interrupt 1 (slot A) pending
													;   0:  interrupt 0 (slot 9) pending

;••••• NOTE: In the new OSS, the interrupt status register is a long word starting at $200.			<3.7>
;•••••		 Since only the low-order word is currently used, making a single change here			<3.7>
;•••••		 has less impact on the ROM sources.  When we permanently switch over to the			<3.7>
;•••••		 new OSS hardware, then it may make sense to fix this equate and change all its			<3.7>
;•••••		 uses from MOVE.Ws to MOVE.Ls.															<3.7>

OSSRomCntl		equ			$204					;offset to ROM control register.  Bits are:
													;  <to be specified - see Steve Ray's spec>				<2.0>

OSSPwrOff		equ			OSSRomCntl				;power off is now a bit in the ROM control register		<5.1>
OSSPwrOffBit	equ			7						;    7:  write a 1 here to power off the machine		<2.1><3.7>

OSSCntrCntl		equ			$205					;offset to counter control register.  Bits are
													;  7-2:  unused
													;    1:  test control.  A 1 causes each 4 bit
													;        counter segment to count in parallel
													;    0:  counter hold.  A 1 holds current value
													;        so all 64 bits can be read.  Hold doesn't
													;        affect counting, though!

OSSInpStat		equ			$206					;offset to input status register.  Bits are
													;  7-2:  not used, read as zero
													;    1:  SCC write request. Not used if PIC present
													;    0:  mini-phono device plugged in flag.  A 1
													;        means a device IS plugged in.

OSS60HzAck		equ			$207					;offset to 'Clear 60 Hz interrupt flag' register.  Both	<3.7>
													; writes and reads clear it, so might as well write it.

OSSCounter		equ			$208					;offset to 64 bit counter register.  Low order 8
													;.bits are always read as zero (maybe not in future...)

;  Bit numbers in OSS interrupt status register

OSSIntIOPSWIM	equ			6						;bit # of SWIM IOP in interrupt status register
OSSIntIOPSCC	equ			7						;bit # of SCC IOP in interrupt status register
OSSIntSound		equ			8						;bit # of ASC in interrupt status register
OSSIntSCSI		equ			9						;bit # of SCSI in interrupt status register
OSSIntVBL60Hz	equ			10						;bit # of 60Hz VBL in interrupt status register
OSSIntVia1		equ			11						;bit # of VIA 1 in interrupt status register
OSSIntRTC		equ			12						;bit # of RTC in interrupt status register
OSSIntADB		equ			13						;bit # of ADB in interrupt status register
OSSIntRPU		equ			14						;bit # of RPU in interrupt status register		<4.8>
OSSIntLast		equ			14						;bit # of last interrupt source

OSSRomInit		EQU			$D						; initial value for ROM control register<3.5>


;---------------------------------------------------
;  IOP (Input Output Processor) Chip Offsets and bit definitions
;---------------------------------------------------

iopRamAddrH		equ			$0000-$20				; high byte of shared RAM address register
iopRamAddrL		equ			$0002-$20				; low byte of shared RAM address register
iopRamAddr		equ			iopRamAddrL-1			; WORD access to shared RAM address register

iopRamData		equ			$0008-$20				; shared RAM data register (byte, word, or long)
iopStatCtl		equ			$0004-$20				; IOP Status and Control register

;	bit numbers within the iopStatCtl register
iopInBypassMode	equ			0						; IOP is in BYPASS mode
iopIncEnable	equ			1						; enable addr pointer increment
iopRun			equ			2						; 0 -> reset IOP, 1 -> run IOP
iopGenInterrupt	equ			3						; interrupt the IOP
iopInt0Active	equ			4						; interrupt 0 active
iopInt1Active	equ			5						; interrupt 1 active
iopBypassIntReq	equ			6						; peripheral chip interrupt request in bypass mode
iopSCCWrReq		equ			7						; 0 -> SCC REQ active, 1 -> inactive

;	commands bytes to write to the iopStatCtl register
setIopIncEnable	equ			(1<<iopIncEnable)|\		; set increment enable
							(1<<iopRun)				; leave iop running

clrIopIncEnable	equ			(0<<iopIncEnable)|\		; reset increment enable
							(1<<iopRun)				; leave iop running

clrIopInt0		equ			(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled

clrIopInt1		equ			(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled

setIopGenInt	equ			(1<<iopGenInterrupt)|\	; interrupt the IOP
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled

resetIopRun		equ			(0<<iopRun)|\			; stop iop from running
							(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopIncEnable)		; set increment enable

setIopRun		equ			(1<<iopRun)|\			; start iop running
							(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopIncEnable)		; set increment enable



;__________________________________________________________________________________________
;
;
; VIA1 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
; are grouped together.  New definitions for VIA1 pins are added such that the grouping is
; maintained.
;
;
;__________________________________________________________________________________________

;---------------------------------------------------
; 6522 VIA1 (and VIA2) register offsets
;---------------------------------------------------

vBufB 			EQU 		0 						; BUFFER B
vBufAH			EQU 		$200  					; buffer a (with handshake) [ Dont use! ]
vDIRB 			EQU 		$400  					; DIRECTION B
vDIRA 			EQU 		$600  					; DIRECTION A
vT1C  			EQU 		$800  					; TIMER 1 COUNTER (L.O.)
vT1CH 			EQU 		$A00  					; timer 1 counter (high order)
vT1L  			EQU 		$C00  					; TIMER 1 LATCH (L.O.)
vT1LH 			EQU 		$E00  					; timer 1 latch (high order)
vT2C  			EQU 		$1000 					; TIMER 2 LATCH (L.O.)
vT2CH 			EQU 		$1200 					; timer 2 counter (high order)
vSR   			EQU 		$1400 					; SHIFT REGISTER
vACR  			EQU 		$1600 					; AUX. CONTROL REG.
vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
vIFR  			EQU 		$1A00 					; INT. FLAG REG.
vIER  			EQU 		$1C00 					; INT. ENABLE REG.
vBufA 			EQU 		$1E00 					; BUFFER A
;(see below) vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>

;---------------------------------------------------
; VIA IFR/IER bits
;---------------------------------------------------

ifCA2 			EQU 		0 						; CA2 interrupt
ifCA1 			EQU 		1 						; CA1 interrupt
ifSR  			EQU 		2 						; SR shift register done
ifCB2 			EQU 		3 						; CB2 interrupt
ifCB1 			EQU 		4 						; CB1 interrupt
ifT2  			EQU 		5 						; T2 timer2 interrupt
ifT1  			EQU 		6 						; T1 timer1 interrupt
ifIRQ 			EQU 		7 						; any interrupt


;---------------------------------------------------
; VIA1 Port A definitions
;---------------------------------------------------

;(see below) vSound			EQU 		$7    					; sound volume bits (0..2)	(output)

;(see below) vTestJ			EQU 		0 						; Burn In Test jumper		(input)

;(see below) vCpuId0			EQU			1						; CPU Identification bit 0	(input)
;(see below) vCpuId1			EQU			2						; CPU Identification bit 1	(input)
;(see below) vSync 			EQU 		3 						; Synchronous modem
;(see below) vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
;(see below) vCpuId2			EQU			4						; CPU Identification bit 2
vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
;(see below) vHeadSel  		EQU 		5 						; head select line for Sony
;(see below) vCpuId3			EQU			6						; CPU Identification bit 3
;(see below) vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
;(see below) vSCCWrReq 		EQU 		7 						; SCC write/request line

;---------------------------------------------------
; VIA1 Port B definitions
;---------------------------------------------------

vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
;(see below) vRTCData  		EQU 		0 						; real time clock data
vRMP0			EQU			0						; Reserved for RMP (PSC only)
;(see below) vRTCClk   		EQU 		1 						; real time clock clock pulses
vRMP1			EQU			1						; Reserved for RMP (PSC only)
;(see below) vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vRMP2			EQU			2						; Reserved for RMP (PSC only)
;(see below) vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
;(see below) vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vViafullbit		EQU			4						; Egret via full bit					<6>
vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
;(see below) vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
;(see below) vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
;(see below) vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
;(see below) vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
vJMPDude7		EQU			7						; Reserved for JMP (PSC only)



;__________________________________________________________________________________________
;
;
; VIA2 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
; are grouped together.  New definitions for VIA2 pins are added such that the grouping is
; maintained.
;
;
;__________________________________________________________________________________________

;---------------------------------------------------
; VIA2 Port A definitions
;---------------------------------------------------

v2IRQ1			EQU 		0 						; slot 1 interrupt
v2EnetIRQ		EQU			0						; on-board ethernet								<8><23>
v2IRQ2			EQU 		1 						; slot 2 interrupt
v2IRQ3			EQU 		2 						; slot 3 interrupt
v2IRQ4			EQU 		3 						; slot 4 interrupt
v2IRQ5			EQU 		4 						; slot 5 interrupt
v2IRQ6			EQU 		5 						; slot 6 interrupt
v2RAM0			EQU 		6 						; RAM size bit 0
v2LCDIRQ		EQU			6						; on-board LCD video
v2VideoIRQ		EQU			6						; on-board video								<8><23>
v2RAM1			EQU 		7 						; RAM size bit 1
v2CardIn		EQU			7						; on-board video
v2SyncOnGreen	EQU			7						; for enabling/disabling Sync-on-Green (DAFB)	<T20>

;---------------------------------------------------
; VIA2 Port B definitions
;---------------------------------------------------

v2ConfigLE		EQU			0						; DFAC config latch enable						<T8>
v2CDis			EQU 		0 						; cache disable (when 1)	<3.3>
v2Keyswitch		EQU			0						; 900/950 ONLY - keyswitch shadow bit (1=SECURE)<T14><T17><SM4> rb
v2BusLk   		EQU 		1 						; Bus lockout
v2PMack			EQU 		1 						; Power manager handshake acknowledge
v2PowerOff		EQU 		2 						; soft power off signal (when 0)
													; (also 900/950 keyswitch OFF bit)				<T17><SM4> rb
v2PMreq			EQU 		2 						; Power manager handshake request
v2ConfigData 	EQU 		3 						; DFAC config data								<T8>
v2FC3  			EQU 		3 						; PMMU FC3 indicator
vFC3  			EQU 		3 						; PMMU FC3 indicator
v2SndInSel0		EQU			3						; Eclipse only - sound input select bit 0		<t19><H17>
v2ConfigClk		EQU 		4 						; DFAC config clock								<T8>
v2TM1A			EQU 		4 						; bit for NUBus
v2TM0A			EQU 		5 						; and another
v2Speed			EQU 		5 						; 25/33 Mhz 68040 input (0=25MHz, 1=33 MHz)
v2MicCtl		EQU			5						; microphone control on Wombats					<H17><SM4> rb
v2HMMU			EQU			5 						; HMMU 24/32									<15> HJR
v2CDis2			EQU			6						; On Tim the CDIS is on pb6						<15> HJR
v2SndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio
v2SndInSel1		EQU			6						; Q900/950 only - sound input select bit 1		<t19><SM4> rb
v2VBL 			EQU 		7 						; pseudo VBL signal
v2ModemRST		EQU			7						; Modem.Reset									<15> HJR



													; temporary Cyclone equates <SM4> rb, start, <SM5> rb


; <SM7> rb, • TEMP EQUATES

CycloneEVT1Reg	EQU			$A55A2800				; id which identifies an EVT1 cyclone in CPURegID <SM9> rb
PSCVIA2SIntEVT1	EQU			$000					; Slot interrupt reg. offset					<SM9> rb
PSCVIA2IFREVT1	EQU			$004					; VIA2 interrupt flag reg. offset				<SM9> rb
PSCVIA2IEREVT1	EQU			$008					; VIA2 interrupt enable reg. offset				<SM9> rb

PSCVIA2SInt		EQU			$1E00					; Slot interrupt reg. offset					<SM7> rb
PSCVIA2IFR		EQU			$1A00					; VIA2 interrupt flag reg. offset				<SM7> rb
PSCVIA2IER		EQU			$1C00					; VIA2 interrupt enable reg. offset				<SM7> rb


; PSC VIA2 Slot Interrupt Register equates
PSCSlotC		EQU			3						; slot C int.
PSCSlotD		EQU			4						; slot D int.
PSCSlotE		EQU			5						; slot E int.
PSCOVBVBL		EQU			6						; on-board video vbl int.

; PSC VIA2 Interrupt Flag and Interrupt Enable Registers equates
PSCSCSI0		EQU			0						; SCSI int., same as bit 3
PSCSlot			EQU			1						; any slot int.
PSCMUNI			EQU			2						; MUNI int.
PSCSCSI3		EQU			3						; SCSI int.
PSCFDC			EQU			5						; floppy int.
PSCSNDFRM		EQU			6						; sound frame int.
PSCANY			EQU			7						; any of the above

													; <SM4> rb, end, <SM5> rb


;----------
;RBV (Ram Based Video) register definitions
;----------

RvDataB			EQU			$000					; VIA2 data reg. B equivalent	<v1.4><2.5>
RvExp			EQU			$001					; RBV Expansion Register		<3>
RvSInt			EQU			$002					; Slot interrupts reg.			<v1.4><2.5>
RvIFR			EQU			$003					; interrupt flag reg.			<v1.4><2.5>
RvMonP			EQU			$010					; monitor parameters reg.		<v1.4><2.5>
RvChpT			EQU			$011					; chip test reg.				<v1.4><2.5>
RvSEnb			EQU			$012					; Slot interrupt enable reg.	<v1.4><2.5>
RvIER			EQU			$013					; interrupt flag enable reg.	<v1.4><2.5>

;----------
;Common Via 2 and RBV (Ram Based Video) register offsets
;----------


Rv2DataB		EQU			vBufB++RvDataB			; RBV/VIA2 data reg. B equivalent	<H8>
Rv2Exp			EQU			RvExp					; RBV Expansion Register			<H8>
Rv2SInt			EQU			RvSInt					; Slot interrupts reg.				<H8>
Rv2IFR			EQU			vIFR++RvIFR				; RBV/VIA2 interrupt flag reg.		<H8>
Rv2MonP			EQU			RvMonP					; monitor parameters reg.			<H8>
Rv2ChpT			EQU			RvChpT					; chip test reg.					<H8>
Rv2SEnb			EQU			RvSEnb					; Slot interrupt enable reg.		<H8>
Rv2IER			EQU			vIER++RvIER				; iRBV/VIA2 interrupt enable reg.	<H8>


;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====									<v1.4>
RvCDis			EQU 		0 						; cache disable (when 1)					<v1.4><3.3>
RvBusLk   		EQU 		1 						; Bus lockout								<v1.4>
RvPowerOff		EQU 		2 						; soft power off signal (when 0)			<v1.4>
RvCFlush		EQU 		3 						; Flush external cache (when 0)				<v1.4>
RvTM1A			EQU 		4 						; bit for NUBus								<v1.4>
RvTM0A			EQU 		5 						; and another								<v1.4>
RvSndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio		<v1.4>
													; jack in use								<v1.4>
RvPGCTest		EQU			7						; 1 = generate good parity, 0 = generate errors

;  ======  Future Expansion   Address: $50026001	 =====										<v1.4>

;  ======  Slot Interrupts   Address: $50026002	 =====											<v1.4>
RvIRQ1			EQU 		0 						; slot 1 interrupt							<v1.4>
RvIRQ2			EQU 		1 						; slot 2 interrupt							<v1.4>
RvIRQ3			EQU 		2 						; slot 3 interrupt							<v1.4>
RvIRQ4			EQU 		3 						; slot 4 interrupt							<v1.4>
RvIRQ5			EQU 		4 						; slot 5 interrupt							<v1.4>
RvIRQ6			EQU 		5 						; slot 6 interrupt							<v1.4>
RvIRQ0			EQU 		6 						; slot 0 interrupt or internal video 		<v1.4>
													; blanking interrupt						<v1.4>
;RvResr			EQU 		7 						; reserved 									<v1.4>

;  ======  Interrupt Flags   Address: $50026003	 =====											<v1.4>
RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt					<v1.4>
RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int					<v1.4>
RvExpIRQ		EQU			2						; 1 = expansion int. (reserved)				<v1.4>
RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt					<v1.4>
RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup				<v1.4>
;RvResr			EQU 		5 						; reserved 									<v1.4>
;RvResr			EQU 		6 						; reserved									<v1.4>
;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt			<v1.4>
													; on WRITE, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;  ======  Monitor Parameters   Address: $50026010	 =====										<v1.4>
RvColor1		EQU			0						; (lsb) R/W 000 = 1bit, 001 = 2 bit			<v1.4>
RvColor2		EQU			1						; 		R/W 010 = 4bit, 011 = 8 bit			<v1.4>
RvColor3		EQU			2						; (msb) Read 1xx = Reserved					<v1.4>
RvMonID1		EQU			3						; READ 000,011,100=reserved; x01=15" monitor<v1.4>
RvMonID2		EQU			4						; 010=Mod'IIGSmonitor;110=MacII monitors	<v1.4>
RvMonID3		EQU 		5 						; 111= 9" build in monitor					<v1.4>
RvVIDOff		EQU 		6 						; 1 = Video off								<v1.4>
RvVID3St		EQU			7						; 1 = all video outputs tri-stated			<v1.4>

;  ======  Chip Test   Address: $50026011	 =====												<v1.4>
RvC60			EQU			0						; 1 = C60 clock run 128 x normal			<v1.4>
RvSpd1			EQU			1						; (lsb) 00 = normal, 01=medium				<v1.4>
RvSpd2			EQU			2						; (msb) 10 = fast, 11 = very fast			<v1.4>
RvHndShk3		EQU			3						; 1=VID.REQ & VID.RES tri-stated			<v1.4>
RvIOClk3		EQU			4						; 1=C16M, C8M, C3.7M tri-stated				<v1.4>
RvC30M			EQU 		5 						; 1=30.24 mHz clock for all monitors		<v1.4>
RvSDTClk		EQU 		6 						; 1 = Dot clock halted						<v1.4>
RvTstRes		EQU			7						; 1 = reset video counters					<v1.4>

;  ======  Slot Interrupts Enable   Address: $50026012	 =====									<v1.4>
RvIRQ1En		EQU 		0 						; slot 1 interrupt enabled					<v1.4>
RvIRQ2En		EQU 		1 						; slot 2 interrupt enabled					<v1.4>
RvIRQ3En		EQU 		2 						; slot 3 interrupt enabled					<v1.4>
RvIRQ4En		EQU 		3 						; slot 4 interrupt enabled					<v1.4>
RvIRQ5En		EQU 		4 						; slot 5 interrupt enabled					<v1.4>
RvIRQ6En		EQU 		5 						; slot 6 interrupt enabled					<v1.4>
RvIRQ0En		EQU 		6 						; slot 0 interrupt or internal video enabled<v1.4>
;RvSetClr		EQU			7						; on READs, always reads 0					<v1.4>
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;  ======  Interrupt Flags Enable   Address: $50026013	 =====
RvSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled			<v1.4>
RvAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled		<v1.4>
RvExpIRQEn		EQU			2						; 1 = expansion int. (reserved) enabled		<v1.4>
RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled			<v1.4>
RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled	<v1.4>
;RvResr			EQU 		5 						; reserved 									<v1.4>
;RvResr			EQU 		6 						; reserved									<v1.4>
;RvSetClr		EQU			7						; on READs, always reads 1					<v1.4>
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;----------
; VDAC register definitions
;----------

vDACwAddReg		EQU			$0000					;   offset from vDACBase for write address reg
vDACrAddReg		EQU			$000C					;   offset from vDACBase for read address register <v4.2>
vDACwDataReg	EQU			$0004					;   offset from vDACBase for write data reg

vDACPixRdMask	EQU			$0008					;   offset from vDACBase for pixel mask


;__________________________________________________________________________________________
;
;
; VISA Pin Definitions and Register Offsets - Multiple names for the same pin are grouped
; together.  New definitions for VISA pins are added such that the grouping is maintained.
;
;
;__________________________________________________________________________________________


;----------
; VISA register definitions - generally, these equates are a precise subset
;		of the RBV equates.
;----------

; these registers are accessed off of VIA1 lomem
VsData1A		EQU		  	$1E00					; VIA1 data reg A
VsData1B		EQU			$0000					; VIA1 data reg B

; these registers are accessed off of VISA lomem
VsData2B		EQU			$000					; VIA2 data reg B equivalent
VsExp			EQU			$001					; VISA Expansion Register
VsSInt			EQU			$002					; Slot Interrupt Register
VsIFR			EQU			$003					; Interrupt Flag Register
VsMonP			EQU			$010					; Monitor Parameters Register
VsSEnb			EQU			$012					; Slot Interrupt Enable Register
VsIER			EQU			$013					; Interrupt Flag Enable Register

;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
VsFC3			EQU			3						; select 32-bit map.  0=24 bit, 1=32 bit
;*VsResr		EQU			4						; reserved
;*VsResr		EQU			5						; reserved
VsSndExt		EQU			6						; Always reads as 1 - play sounds in Mono
;*VsResr		EQU			7						; reserved

;  ======  Future Expansion   Address: $50026001	 =====
VsA2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
VsVResEn		EQU			1						; 1=enable vertical counter reset for video genlock
VsFlWrEn	 	EQU			2						; 1=enable writes to flash EEPROM
Vs1BV			EQU			3						; 1=low base for 1-bit mode, 0=high base
VsPg2			EQU			4						; 1=main video page, 0=sec video page
;*VsResr		EQU			5						; reserved
VsSiz0			EQU			6						; RAM size control bit 00=1MB, 01=1.5MB
VsSiz1			EQU			7						; 	10=3MB,11=9MB

;  ======  Slot Interrupts   Address: $50026002	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
;*VsResr		EQU			3						; reserved
;*VsResr		EQU			4						; reserved
VsSIRQ			EQU			5						; expansion slot interrupt
VsVBLInt		EQU			6						; slot zero (built-in) VBL interrupt
;*VsResr		EQU			7						; reserved


;  ======  Interrupt Flags   Address: $50026003	 =====
VsSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrup
VsAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
;*VsResr		EQU			2						; reserved
VsSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
VsSndIRQ		EQU			4						; 1 = Apple Sound Chip interrupt
;RvResr			EQU 		5 						; reserved
;RvResr			EQU 		6 						; reserved
RvSetClr		EQU			7						; on READ, 1 = any enabled interrupt
													; on WRITE, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Monitor Parameters   Address: $50026010	 =====
;*VsResr		EQU			0						; (lsb)
VsColor			EQU			1						; (compat w/RBV) R/W 000 = 1bit, R/W 010 = 4bit
;*VsResr		EQU			2						; (msb)
VsMonConn		EQU			3						; (lsb)1=no monitor connected
;*VsResr		EQU			4						; (compat w/RBV)
VsMonSel		EQU 		5 						; (msb) Monitor select 1=Jersey, 0=Rubik
;*VsResr		EQU 		6 						; reserved
;*VsResr		EQU			7						; reserved


;  ======  Slot Interrupts Enable   Address: $50026012	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
;*VsResr		EQU			3						; reserved
;*VsResr		EQU			4						; reserved
VsExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
VsIntIRQEn		EQU 		6 						; internal video interrupt enabled
VsSetClr		EQU			7						; on READs, always reads 0
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Interrupt Flags Enable   Address: $50026013	 =====
VsSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled
VsAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled
;*VsResr		EQU			2						; reserved
VsSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
VsSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
;VsResr			EQU 		5 						; reserved
;VsResr			EQU 		6 						; reserved
;RvSetClr		EQU			7						; on READs, always reads 1
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's


;----------
; V8 register definitions - generally compatible with the VISA equates above, but a few equates
;	have changed names.
;----------

; these registers are accessed off of the V8 lomem
V8Exp			EQU			$001					; V8 Expansion Register
V8SInt			EQU			$002					; V8 Slot Interrupt Register
V8MonP			EQU			$010					; Monitor Parameters Register
V8SEnb			EQU			$012					; Slot Interrupt Enable Register

;  ======  Future Expansion   Address: $50F26001	 =====
V8A2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
V8512Row		EQU			1						; 1=V8 rowbytes is 256, 0=rowbytes is 512
V8vRAMIn	 	EQU			2						; 1=refresh video from vRAM, 0=refresh from dRAM
;*V8Resr		EQU			3						; no 1BV on V8
;*V8Resr		EQU			4						; no VP2 on V8
V8Siz0			EQU			5						; RAM size control bit 0
V8Siz1			EQU			6						; RAM size control bit 1
V8Siz2			EQU			7						; RAM size control bit 2

;  ======  Monitor Parameters   Address: $50F26010	 =====
V8Col0			EQU			0						; Video depth control bit 0
V8Col1			EQU			1						; Video depth control bit 1
V8Col2			EQU			2						; Video depth control bit 2
V8MonID1		EQU			3						; Monitor sense ID bit 1
V8MonID2		EQU			4						; Monitor sense ID bit 2
V8MonID3		EQU			5						; Monitor sense ID bit 3
;*VsResr		EQU 		6 						; reserved
;*VsResr		EQU			7						; reserved

;  ======  Slot Interrupts Enable   Address: $50F26012	 =====
;*V8Resr		EQU			0						; reserved
;*V8Resr		EQU			1						; reserved
;*V8Resr		EQU			2						; reserved
;*V8Resr		EQU			3						; reserved
;*V8Resr		EQU			4						; reserved
V8ExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
V8IntIRQEn		EQU 		6 						; internal video interrupt enabled
;*V8Resr		EQU			7						; reserved


;----------
; Elsie VDAC register definitions
;----------

; VISA/Bt450 registers

VsDACwAddReg	EQU			$0000					;   offset from vDACBase for write address reg
VsDACwDataReg	EQU			$0001					;   offset from vDACBase for write data reg

; V8/Ariel registers

V8DACrAddReg	EQU			$0000					; offset for read address reg
V8DACwAddReg	EQU			$0000					; offset for write address reg
V8DACrDataReg	EQU			$0001					; offset for read data reg
V8DACwDataReg	EQU			$0001					; offset for write data reg
V8DACrCntlReg	EQU			$0002					; offset for read control reg
V8DACwCntlReg	EQU			$0002					; offset for write control reg
V8DACrKeyReg	EQU			$0003					; offset for read key color reg
V8DACwKeyReg	EQU			$0003					; offset for write key color reg

V8vRAMBase		EQU			$50F40000				; base address of V8 VRAM, if present

; End of VISA changes								<4> <cv>


;----------
; DAFB register definitions (offsets from DAFBBase in ProductInfo) ($F980 0000)
;----------

DAFB_BaseOffset		EQU			$0				; DAFB offset from DAFBBase
DAFB_ParmSize		EQU			$5				; size of DAFB programmed subset
DAFB_NumRegs		Equ			(16-4)			; Number of DAFB registers (Color Regs are really vRAM).

DAFB_VidBaseHi		EQU			$0				; DAFB video base address, bits 20:9
DAFB_VidBaseLo		EQU			$4				; DAFB video base address, bits 8:5 (4:0 always zero)
DAFB_RowWords		EQU			$8				; DAFB rowlongs size
DAFB_ClkCfg			EQU			$C				; DAFB clock configuration
DAFB_Config			EQU			$10				; DAFB general configuration
DAFB_BlkWrtEn		EQU			$14				; DAFB block write enable
DAFB_PgMdEn			EQU			$18				; DAFB page mode enable
DAFB_Sense			EQU			$1C				; DAFB sense line
DAFB_Reset			EQU			$20				; DAFB reset control
DAFB_SCSIch0		EQU			$24				; Turbo SCSI channel 0 control (not used)
DAFB_SCSIch1		EQU			$28				; Turbo SCSI channel 1 control (not used)
DAFB_Test			EQU			$2C				; DAFB test control

DAFB_CRB0			EQU			$30				; vRAM Color Register, bank 0
DAFB_CRB1			EQU			$34				; vRAM Color Register, bank 1
DAFB_CRB2			EQU			$38				; vRAM Color Register, bank 2
DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3

;----------
; Swatch (in DAFB) register definitions (offsets from DAFBBase in ProductInfo)
;----------

Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
Swatch_BaseOffset1	EQU			$124			; parameter offset
Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
Swatch_NumRegs		Equ			30				; Number of Swatch registers.

Swatch_Mode			EQU			$100			; Swatch general control
Swatch_IntMsk		EQU			$104			; Swatch interrupt control
Swatch_IntStat		EQU			$108			; Swatch interrupt status
Swatch_ClrCrsrInt	EQU			$10C			; Swatch clear cursor interrupt (not used in this form)
Swatch_ClrAnimInt	EQU			$110			; Swatch clear animation interrupt (not used in this form)
Swatch_ClrVBLInt	EQU			$114			; Swatch clear VBL interrupt (not used in this form)
Swatch_CrsrLine		EQU			$118			; Swatch cursor interrupt trigger line
Swatch_AnimLine		EQU			$11C			; Swatch animation interrupt trigger line
Swatch_Test			EQU			$120			; Swatch counter test
Swatch_HSyncRegs	EQU			$124			; Swatch horizontal sync registers (set as a group)
Swatch_HSerr		Equ			$124			;   HSerr
Swatch_Hlfln		Equ			$128			;   Hlfln
Swatch_HEq			Equ			$12C			;   HEq
Swatch_HSP			Equ			$130			;   HSP
Swatch_HBWay		Equ			$134			;   HBWay
Swatch_HBrst		Equ			$138			;   HBrst
Swatch_HBP			Equ			$13C			;   HBP
Swatch_HAL			Equ			$140			;   HAL
Swatch_HFP			Equ			$144			;   HFP
Swatch_HPix			Equ			$148			;   HPix
Swatch_VSyncRegs	EQU			$14C			; Swatch vertical sync registers (set as a group)
Swatch_VHLine		Equ			$14C			;	VHLine
Swatch_VSync		Equ			$150			;	VSync
Swatch_VBPEq		Equ			$154			;	VBPEq
Swatch_VBP			Equ			$158			;	VBP
Swatch_VAL			Equ			$15C			;	VAL
Swatch_VFP			Equ			$160			;	VFP
Swatch_VFPEq		Equ			$164			;	VFPEq
Swatch_TimeAdj		EQU			$168			; Swatch miscellaneous timing adjust
Swatch_ActLine		EQU			$16C			; Swatch active video line (read-only)

;----------
; ACDC register definitions (offsets from DAFBBase in ProductInfo, also in vDACBase)
;----------

ACDC_AddrReg		EQU			$200			; set position in ACDC internal RAM
ACDC_DataReg		EQU			$210			; read/write data in ACDC internal RAM
ACDC_ConfigReg		EQU			$220			; ACDC offset from DAFBBase
ACDC_ParmSize		EQU			$1				; size of ACDC parameter list


;----------
; National Clock Chip register definitions (offsets from DAFBBase in ProductInfo)
;----------

Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
Clk_ParmSize		EQU			$10 			; size of National parameter list
Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)

;----------
; Misc. DAFB Parms
;----------
Misc_ParmSize		Equ			$4				; Just for consistency with other DAFB parms.


;----------
; GSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H5> jmp
;----------
GSCDeviceID			Equ		$00						; Device revision register; read only.
GSCPanelID			Equ		$01						; “Senseline” read/write register.
GSCPanelControl		Equ		$02						; Switches r/w sense of PanelID reg.
GSCPanelSetup		Equ		$03						; Panel intialization register.
GSCGrayScale		Equ		$04						; The depth-switching register.
GSCPolyAdj			Equ		$05						; Allows for grayscale adjustment.
GSCPanelAdj			Equ		$06						; Allows for panel adjustment.
GSCACDClk			Equ		$07						; Who knows?
GSCRefreshRate		Equ		$08						; Refresh cycles per scanline.
GSCBlankShade		Equ		$09						; Shade of gray for depth switches.
GSCPanelSkew		Equ		$0A						; Who knows?

GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
GSCDiag1			Equ		$1E
GSCDiag2			Equ		$1F


;----------
; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
;----------

SonoraVIA2Base	Equ			$26000					; Base address of VIA2

SonoraVIA2Data	Equ			$00						; VIA2 Data Register
SonoraRAMSize	EQU			$01						; DRAM config
SonoraSlotIFR	Equ			$02						; Slot Interrupt Flags Register
SonoraVIA2IFR	Equ			$03						; VIA2 Interrupt Flags Register
SonoraVRAMSize	Equ			$04						; VRAM config
SonoraSpeedReg	Equ			$05						; System CPU Speed (waitstate) Register
SonoraSlotIER	Equ			$12						; Slot Interrupt Enable Register
SonoraVIA2IER	Equ			$13						; Interrupt Flag Register
SonoraVdCtlBase	Equ			$28000					; Base address of video control registers

SonoraVdModeReg	Equ			$00						; Monitor code and video blanking register
SonoraVdColrReg Equ			$01						; Framebuffer pixel depth control register
SonoraVdSenseRg	Equ			$02						; Senseline register

; Bits for Misc Sonora Regs
;
SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			 0 = 1-bits in bits 0-6 write 0's

; Bits for SonoraSlotIER
;
SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL

;----------
; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
;----------
ArielAddrReg	Equ			0						; Offset to r/w address register
ArielDataReg	Equ			1						; Offset to r/w data register
ArielConfigReg	Equ			2						; Offset to r/w control register
ArielKeyReg		Equ			3						; Offset to r/w key color register


;----------
; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
;----------

MMC_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
MMC_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].

MMC_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
MMC_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].

MMC_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
MMC_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
MMC_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].

MMC_DSPspeed	EQU			$1C						; DSP clock speed [M7].

MMC_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
MMC_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
MMC_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
MMC_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].

MMC_EPROMmode	EQU			$30						; EPROM mode [M12].

MMC_DRAMrange2	EQU			$34						; DRAM bank range 0 [M13].
MMC_DRAMrange1	EQU			$38						; DRAM bank range 1 [M14].
MMC_DRAMrange0	EQU			$3C						; DRAM bank range 2 [M15].

MMC_CPUID0		EQU			$40						; CPU ID 0 [M16].
MMC_CPUID1		EQU			$44						; CPU ID 1 [M17].

MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].

MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].

;----------
; MUNI (NuBus) register definitions																<P6>
;----------

; <SM7> rb, • TEMP for EVT1							;											<SM7> rb

MUNIBaseEVT1	EQU			$50F30800				; Base address of Muni for EVT1				<SM9> rb


MUNIBase		EQU			$50F30000				; Base address of Muni.						<SM7> rb



MUNI_IntCntrl	EQU			$00						; Interrupt control register.
MUNI_IntStatus	EQU			$04						; Interrupt status register.
MUNI_Control	EQU			$08						; System control register.
MUNI_BlkAttmpt	EQU			$0C						; Block attempt register.
MUNI_Status		EQU			$10						; Status register.
MUNI_Test		EQU			$14						; Test control register.

;----------
; Civic register definitions (offsets from CivicAddr in ProductInfo) ($50F3 6000)
;----------

Civic_VBLInt	Equ			$000					; Read-only VBL flag register
Civic_VBLEnb	Equ			$110					; Enables VBL interrupt.
Civic_VBLClr	Equ			$120					; Clear VBL interrupt.

Civic_Enable	Equ			$004					; Enables Civic’s timing generator (Casio).
Civic_Reset		Equ			$10C					; Resets Casio.

Civic_VDCInt	Equ			$008					; Read-only VDC flag register.
Civic_VDCClr	Equ			$00C					; Clears VDC interrupt.
Civic_VDCEnb	Equ			$010					; Enables VDC interrupt.
Civic_VDCClk	Equ			$018					; Enables VDC clock.

Civic_VidInSize	Equ			$014					; Controls video-in Rows (1024 vs. 1536 bytes).

Civic_VidInDble	Equ			$208					; Controls whether Civic Doubles each Video-in Field

Civic_ScanCtl	Equ			$01C					; Controls progressive vs. interlaced scans.

Civic_GSCDivide	Equ			$020					; Controls graphics clock divide count.
Civic_VSCDivide	Equ			$02C					; Controls video-in clock divide count.

Civic_VRAMSize	Equ			$040					; Controls VRAM sizing (1 vs. 2 Mbytes).

Civic_RfrshCtl	Equ			$044					; Controls the refresh mode.

Civic_BusSize	Equ			$04C					; Controls the bus size (32 vs. 64 bits).

Civic_SpeedCtl	Equ			$050					; Controls the timing (25 vs. 33 MHz).

Civic_ConvEnb	Equ			$054					; Enables convolution.

Civic_ReadSense	Equ			$088					; Sense-line registers.
Civic_SenseCtl	Equ			$058					;
Civic_Sense0	Equ			$05C					;
Civic_Sense1	Equ			$060					;
Civic_Sense2	Equ			$064					;
Civic_SenseTst	Equ			$068					;

Civic_SyncClr	Equ			$06C					; Disables RGB (Sync) output.

Civic_BaseAddr	Equ			$0C0					; Base address of active video.
Civic_RowWords	Equ			$094					; Row long words of active video.

Civic_AdjF1		Equ			$128					; Timing adjust registers.
Civic_AdjF2		Equ			$124					;
Civic_Piped		Equ			$440					;

Civic_HSerr		Equ			$180					; Horizontal timing registers.
Civic_HlfLn		Equ			$280					;
Civic_HEq		Equ			$2C0					;
Civic_HSP		Equ			$300					;
Civic_HBWay		Equ			$340					;
Civic_HAL		Equ			$380					;
Civic_HFP		Equ			$3C0					;
Civic_HPix		Equ			$400					;

Civic_VHLine	Equ			$480					; Vertical timing registers.
Civic_VSync		Equ			$4C0					;
Civic_VBPEqu	Equ			$500					;
Civic_VBP		Equ			$540					;
Civic_VAL		Equ			$580					;
Civic_VFP		Equ			$640					;
Civic_VFPEqu	Equ			$680					;
Civic_CurLine	Equ			$6C0					;

Civic_VInHAL	Equ			$1C0					; Video-in timing registers.
Civic_VInHFPD	Equ			$200					;
Civic_VInHFP	Equ			$240					;
Civic_VInVAL	Equ			$5C0					;
Civic_VInVFP	Equ			$600					;

Civic_HLDB		Equ			$114					; Horizontal test/control registers.
Civic_HHLTB		Equ			$118					;
Civic_HActHi	Equ			$11C

Civic_VLDB		Equ			$100					; VSync test/control registers.
Civic_VHLTB		Equ			$104					;
Civic_VActHi	Equ			$108					;

Civic_TestEnb	Equ			$12C					; Enables Casio test mode.
Civic_CntTest	Equ			$140					; Count test register.

;----------
; Sebastian register definitions (offsets from SebastianAddr in ProductInfo) ($50F3 0000)
;----------

SebastAddrReg	Equ			$000					; CLUT/DAC Address register.
SebastDataReg	Equ			$010					; CLUT/DAC Data register.
SebastPCBR		Equ			$020					; CLUT/DAC Pixel Bus Control register.

;----------
; Endeavor register definitions
;----------

Endeavor		Equ			$50F2E000				; Base address of Endeavor in Cyclone.

EndeavorM		Equ			$000					; 8-bit numerator.
EndeavorN		Equ			$010					; 8-bit denominator.
EndeavorClk		Equ			$020					; Clock select (A or B).

;----------
; MSC register definitions (offsets from MSCAddr in ProductInfo) ($50F2 6000)
;----------

MSCSlotIFR		EQU			$02						; slots interrupt flags
MSCVIA2IFR		EQU			$03						; VIA 2 interrupt flags
MSCConfig		EQU			$10						; RAM, clock configuration
MSCSlotIER		EQU			$12						; slots interrupt enables
MSCVIA2IER		EQU			$13						; VIA 2 interrupt enables
MSCClkCntl		EQU			$21						; peripherals clock control
MSCSndCntl		EQU			$22						; sound control
MSCFlashWrEnb	EQU			$23						; flash ROM write enable
MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>

;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
MSCExpansion	EQU			0						; 0 = enable on-board external cache (not currently used)
;v2PMack		EQU 		1 						; Power manager handshake acknowledge
;v2PMreq		EQU 		2 						; Power manager handshake request
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;reserved7		EQU			7						; reserved

;  ======  Slot Interrupt Flags			Address: $50F26002	 =====
;reserved0		EQU			0						; reserved
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;RvIRQE			EQU 		5 						; slot E interrupt
;RvIRQLCD		EQU			6						; LCD display VBL interrupt
;reserved7		EQU			7						; reserved

;  ======  VIA 2 Interrupt Flags		Address: $50F26003	 =====
;RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt
;RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
;reserved2		EQU			2						; reserved
;RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
;RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt

;  ======  MSC Configuration			Address: $50F26010	 =====
MSC25MHz		EQU			0						; 1 = 25MHz system, 0 = 33MHz system
MSCEconoBit		EQU			1						; 1 = econo-mode enabled (switches to 16MHz)
MSCFastROM		EQU			2						; 1 = 100ns ROMs installed, 0 = 120ns ROMs installed
;reserved3		EQU			3						; reserved
MSCBank8M		EQU			4						; 1 = banks 4-7 are 8MB, 0=banks 4-7 are 2MB
MSCSize0		EQU			5						; RAM size bit
MSCSize1		EQU			6						; RAM size bit
MSCSize2		EQU			7						; RAM size bit

;  ======  Slot Interrupt Enables		Address: $50F26012	 =====
;reserved0		EQU			0						; reserved
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;RvIRQEEn		EQU 		5 						; slot E interrupt enabled
;RvIRQLCDEn		EQU			6						; LCD display VBL interrupt enabled
;RvSetClr		EQU			7						; on READs, always reads 0

;  ======  VIA 2 Interrupt Enables		Address: $50F26013	 =====
;RvSCSIDRQEn	EQU			0						; 1 = SCSI DRQ interrupt enabled
;RvAnySlotEn	EQU			1						; 1 = any slot(0-6).IRQ int. enabled
;reserved2		EQU			2						; reserved
;RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
;RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;RvSetClr		EQU			7						; on READs, always reads 0
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Peripherals Clock Control	Address: $50F26021	 =====
MSCIOClk		EQU			0						; 1=15.6672MHz I/O clock running, 0=stopped
MSCSCCClk		EQU			1						; 1=3.672MHz SCC clock running, 0=stopped
MSCSCSIReset	EQU			2						; 1=SCSI reset not asserted, 0=reset asserted (clocks stop)
MSCLCDReset		EQU			3						; 1=LCD reset not asserted, 0=reset asserted (clocks stop)
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;reserved7		EQU			7						; reserved

;  ======  Sound Control				Address: $50F26022	 =====
MSCSndPower		EQU			0						; 1=DFAC power on, 0=DFAC power off
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
MSCSndBusy		EQU			6						; 1=access to FIFO since last access to this register
MSCSndLatch		EQU			7						; 1=DFAC is powered up and initialized


MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
							(0<<MSCEconoBit)|\		; econo-mode disabled						<H9>
							(0<<MSCFastROM)|\		; 120ns ROMs installed						<H9>
							(0<<MSCBank8M)|\		; assume 2MB each in banks 4-7				<H19>
							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>



;__________________________________________________________________________________________
;
;
; Memory Controllers - Register Definitions and Misc Equates for Memory Controllers.  Included
; are: FMC, ORWELL, JAWS, Niagra, Ponti, djMEMC, Pratt
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
;  FMC (Fitch Memory Controller) Equates
;---------------------------------------------------

FMCConfig		equ			$0						; offset to configuration register.  It is a 16
													; bit wide register with a 1 bit wide data port
													; on d24, so do byte writes (and rotates) and
													; let dynamic bus sizing replicate it on d24-31.

FMCLatch		equ			$10						; offset to 'latch config data' register (latches
													; on a write to here)
FMCInit			EQU			$F3EF					; config reg initial value				<4.5><4.6><4.9><1>
FMCRPUInit		EQU			$F3FF					; config reg initial value (parity)		<1>


;---------------------------------------------------
;  Orwell Memory Controller Equates	<5>
;---------------------------------------------------

;	Orwell only has one input/output data bit.  So to store or retrieve any configuration register
;	information, you must read/write a succession of long-word addresses, starting at the addresses
;	below, with the ONLY valid data bit being {reg}:0.  Valued being read must be assembled one bit
;	at a time; values being written must be loaded into the config registers 1 bit at a time.  The
;	new config. register values do not become active until a "latch" register address associated
;	with the config. register is written.
;
;	The below addresses correspond to longword addresses where bit 0 of whatever data register used to
;	read/write the location will be stored.  The Orwell configuration register is a 34-bit register,
;	with each bit written to/read by addressing the appropriate longword offset.
;
;	The configuration register can be thought of like this:
;
;		+---------------------------------------------------------------------------------------------+
;		| PAR_ODD | PAR_ENB | REFRESH | ROM_SPEED | DRAM_SPEED | CLK_SPEED | BANK_D | BANK_C | BANK_B |
;		+---------------------------------------------------------------------------------------------+
;			28        27     26     24 23       21  20       19     18      17   12  11    6  5      0
;
;																												<T6>
;		+---------------------------------------------------------------------+									<T6>
;		|    RAS    | Optional WRITE | Optional Read  | Optional Read  | Page |									<T6>
;		| Precharge |   wait state   | 2nd wait state | 1st wait state | Mode |									<T6>
;		+---------------------------------------------------------------------+									<T6>
;			 33            32                31               30          29									<T6>

;			***		Register Offsets	***

OrCfgRegAddr		EQU			0						; starting offset of config reg. bits
OrCfgRegSize		EQU			34						; number of bits in the configuration register				<T6>

OrBankFieldSize		EQU			6						; each bank config. reg. field is 6 bits wide
OrBankBCfgAddr		EQU			OrCfgRegAddr			; starting offset of BankB(5:0)
OrBankCCfgAddr		EQU			OrBankBCfgAddr+(4*OrBankFieldSize); starting offset of BankC(5:0)
OrBankDCfgAddr		EQU			OrBankCCfgAddr+(4*OrBankFieldSize); starting offset of BankD(5:0)
OrClkSpeedAddr		EQU			OrBankDCfgAddr+(4*OrBankFieldSize); starting address of Clock_Speed
														; ... Clock_Speed is 1 bit (0=25MHz)
OrDRAMSpeedAddr		EQU			OrClkSpeedAddr+4		; starting address of DRAM Speed(1:0)
OrDRAMFieldSize		EQU			2						; DRAM speed config reg. field is 2 bits wide
OrROMSpeedAddr		EQU			OrDRAMSpeedAddr+(4*OrDRAMFieldSize); starting address of ROM Speed(2:0)
OrROMFieldSize		EQU			3						; ROM speed config reg. field is 3 bits wide
OrRefreshAddr		EQU			OrROMSpeedAddr+(4*OrROMFieldSize); starting address of Refresh Rate(2:0)
OrRefreshSize		EQU			3						; Refresh speed config reg. field is 3 bits wide
OrParityEnbAddr		EQU			OrRefreshAddr+(4*OrRefreshSize); starting address of parity enable/disable
														; ... Parity_Enable is 1 bit (0=parity OFF)
OrParityTypAddr		EQU			OrParityEnbAddr+4		; starting address of parity type (even/odd)
														; ... Parity_Type is 1 bit (0=parity EVEN)
OrPageMode			EQU			OrParityTypAddr+4		;															<T6>
OrWaitRead1			EQU			OrPageMode+4			;															<T6>
OrWaitRead2			EQU			OrWaitRead1+4			;															<T6>
OrWaitWrite1		EQU			OrWaitRead2+4			;															<T6>
OrRASPrecharge		EQU			OrWaitWrite1+4			;															<T6>

OrLatchOffset		EQU			$A0						; offset from start of config reg. where latches live		<T6>
OrwellLatches		EQU			OrCfgRegAddr+OrLatchOffset; starting address of Latch Addresses						<T6>

OrLoadBanks			EQU			OrwellLatches			; Load Bank Config Reg. Latch address						<T6>
OrLoadSpeeds		EQU			OrLoadBanks+4			; Load Clock, DRAM and ROM Speeds Latch address
OrLoadRefresh		EQU			OrLoadSpeeds+4			; Load Refresh interval Latch address
OrLoadParity		EQU			OrLoadRefresh+4			; Load Parity enable/disable and type Latch address

OrLoadMode			EQU			OrLoadParity+4			; Load Page Mode On/Off address								<T6>
OrLoadWaitStates	EQU			OrLoadMode+4			; Load Read/Write extra waitstates address					<T6>
OrLoadPrecharge		EQU			OrLoadWaitStates+4		; Load RAS precharge address								<T6>

OrParityStatus		EQU			$100					; A0-BC = LS 8 bits, C0-DC   = LM 8 bits					<T6>
														; E0-FC = HM 8 bits, 100-11C = MS 8 bits
OrParErrInByte0		EQU			$180					; =1 if parity error occurred in byte 0
OrParErrInByte1		EQU			$184					; =1 if parity error occurred in byte 1
OrParityError		EQU			$188					; =1 if parity error occurred (period)

;			***		Initializing Values at Bootup Time		***

ORINITBankB			EQU			$10						; 10=Bank B at 64MB
ORINITBankC			EQU			$20						; 20=Bank C at 128MB
ORINITBankD			EQU			$30						; 30=Bank D at 192MB

ORINITClock25		EQU			1						; 1=25MHz, 0=33MHz											<T12>
ORINITClock33		EQU			0						;															<T12>
ORINITDRAMSpeed		EQU			1						; 0=100ns, 1=80ns, 2=60ns							<10>
ORINITROMSpeed25	EQU			2						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
ORINITROMSpeed33	EQU			4						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
ORINITREFRESH25		EQU			2						; 0=25MHz 7.8µsec,  1=33MHz, 7.8µsec				<21>	<T12>
														; 2=25MHz 15.6µsec, 3=33MHz 15.6µsec				<21>	<T12>
ORINITREFRESH33		EQU			3						;													<21>	<T12>
ORINITParity		EQU			0						; 0=parity OFF, 1=parity ON
ORINITParType		EQU			1						; 0=even, 1=odd

;	Additional (programmable) wait states for reads and writes

ORINITPageMode		EQU			0						; 0=off, 1=on												<T6>
ORINITWaitRd1		EQU			0						; 0=off, 1=on (unless Rd2 = 1, in which case it is interpreted as off)<T6>
ORINITWaitRd2		EQU			0						; 0=off, 1=on (unless Rd1 = 1, in which case it is interpreted as off)<T6>
ORINITWaitWr1		EQU			0						; 0=off, 1=on												<T6>
ORINITRAS25			EQU			0						; 0=2 cycles, 1=3 cycles 									<T6>
ORINITRAS33			EQU			1						;															<T12>

;	These are 32-bit constants that hold all but 2 bits of the initial defaults we									  .
;	would want to jam into the Orwell configuration register.  These are arranged									  .
;	in order the register is memory-mapped to facilitate the code that sticks them									  .
;	in the register.  There are two bits that don't fit in a 32-bit constant, the									  .
;	optional -OrWaitWrite1- and the not-so-optional -OrRASPrecharge-.  Those values									  .
;	are used and initialized separately.																			  .

ORWELL_INIT25		EQU			\						;															<T6><T12>
								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
								(ORINITParType<<28)|\	; initial parity even/odd value
								(ORINITParity<<27)|\	; initial parity on/off value
								(ORINITREFRESH25<<24)|\	; initial refresh rate value								<T12>
								(ORINITROMSpeed25<<21)|\; initial ROM speed value									<T12>
								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
								(ORINITClock25<<18)|\	; initial clock speed value									<T12>
								(ORINITBankD<<12)|\		; initial Bank D starting address value
								(ORINITBankC<<6)|\		; initial Bank C starting address value
								(ORINITBankB)			; initial Bank B starting address value
ORWELL_INIT33		EQU			\						;															<T6><T12> thru next <T12>
								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
								(ORINITParType<<28)|\	; initial parity even/odd value
								(ORINITParity<<27)|\	; initial parity on/off value
								(ORINITREFRESH33<<24)|\	; initial refresh rate value
								(ORINITROMSpeed33<<21)|\; initial ROM speed value
								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
								(ORINITClock33<<18)|\	; initial clock speed value
								(ORINITBankD<<12)|\		; initial Bank D starting address value
								(ORINITBankC<<6)|\		; initial Bank C starting address value
								(ORINITBankB)			; initial Bank B starting address value						<T12>


;---------------------------------------------------
; JAWS Memory Controller Equates
;---------------------------------------------------

JAWSRAMWaitS	EQU			$00000					; RAM wait state control register offset
JAWSEconoMode	EQU			$04000					; Econo-Mode register offset									<21> HJR
JAWSROMWaitS	EQU			$06000					; ROM wait state control register offset

JAWSMemConfigA	EQU			$10000					; Contiguous memory (knitting) registers
JAWSMemConfigB	EQU			$12000					; Contiguous memory (knitting) registers
JAWSMemConfigC	EQU			$14000					; Contiguous memory (knitting) registers

JAWSPowerCycle	EQU			$20000					; CPU power off control register
JAWSSetCPUClock	EQU			$22000					; Controls the CPU clock frequency
JAWSPCBLevel	EQU			$30000					; Selects between SCC and SCC/SCSI combo
JAWSLockRAM		EQU			$32000					; Puts RAM in self refresh state
JAWSGetCPUClock	EQU			$34000					; Returns the CPU clock frequency

;---------------------------------------------------
; Niagra Memory Controller Equates
;---------------------------------------------------

NiagraVidCntCtr	EQU			$02000					; Video count options 									<21> HJR
NiagraGUR		EQU			$16000					; General Utility Registers (ponti register access)<SM4> rb
NiagraVidAcc1	EQU			$22000					; Video Accesses thru 64
NiagraVidAcc2	EQU			$24000					; Video Accesses thru 512
NiagraVidAcc3	EQU			$26000					; Video Accesses thru 2K
NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
NiagraFPUAcc	EQU			$34000					; FPU access detected
NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency

;---------------------------------------------------								<SM4> rb, start
; Ponti Register Equates  (NiagraGUR register space + offset
;---------------------------------------------------

PontiSPIMdmCtl		EQU			$000
PontiSndCtl			EQU			$400
PontiSPISftReg		EQU			$800
PontiLmpSftCtl		EQU			$C00

; Ponti PontiSPIMdmCtl bit definitions
PontiSPIMdmId		EQU			0				; (1 = SPI modem connected)
PontiSPIAck			EQU			2				; (1 = ack idle)
PontiSPIReq			EQU			3				; (1 = req idle)
PontiSPIIrq			EQU			4				; (1 = interrupting)

; Ponti PontiSoundCtl bit definitions
PontiSndSPIIrqMsk	EQU			0				; (1 = mask int)			- irq mask for PontiSPIIrq
PontiSndIntMic		EQU			1				; (1 = using internal mic)	- flag to check which mike is used	<H22>
PontiSndLatchClr	EQU			2				; (pulse high to clear)		- line directly to latch
PontiSndLatchData	EQU			3				; (1 = snd ckt used)		- output value of the sound latch
PontiSndPWMOff		EQU			4				; (1 = PWM off)				- ultimate off to remove "pop"
PontiSndPwrOn		EQU			5				; (1 = power snd ckt)		- sw equal of latch output
PontiSndMux0		EQU			6				; (1 = ???)
PontiSndMux1		EQU			7				; (1 = modem sound {regardless of Mux0})

; Ponti PontiLmpSftCtl bit definitions
PontiLmpOff			EQU			0				; (1 = backlight on) 		- turn on the backlight tube
PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control loop
PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register
												;									<SM4> rb, end
;-------------------------------------																		<H21> thru next <H21>
;	djMEMC memory controller equates
;-------------------------------------

;	This hard-coded I/O address is in here because there is no more room in the
;	Universal tables to hold this information.

MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps

MEMCRegisterStart	EQU		0
MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
dj_OneBufferedBusBit EQU	5
;	djMEMC supports up to a maximum of 10 (TEN) DRAM banks
dj_MaxBanks			EQU		10						;														<H22>

MEMCDRAMCfg0		EQU		MEMCIntleaveEnable+4	; Bank 0 cfg reg
MEMCDRAMCfg1		EQU		MEMCDRAMCfg0+4			; Bank 1 cfg reg
MEMCDRAMCfg2		EQU		MEMCDRAMCfg1+4			; Bank 2 cfg reg
MEMCDRAMCfg3		EQU		MEMCDRAMCfg2+4			; Bank 3 cfg reg
MEMCDRAMCfg4		EQU		MEMCDRAMCfg3+4			; Bank 4 cfg reg
MEMCDRAMCfg5		EQU		MEMCDRAMCfg4+4			; Bank 5 cfg reg
MEMCDRAMCfg6		EQU		MEMCDRAMCfg5+4			; Bank 6 cfg reg
MEMCDRAMCfg7		EQU		MEMCDRAMCfg6+4			; Bank 7 cfg reg
MEMCDRAMCfg8		EQU		MEMCDRAMCfg7+4			; Bank 8 cfg reg
MEMCDRAMCfg9		EQU		MEMCDRAMCfg8+4			; Bank 9 cfg reg

MEMCmemTop			EQU		MEMCDRAMCfg9+4			; Top of stitched RAM
MEMCconfig			EQU		MEMCmemTop+4			; "Multiple bit DRAM/ROM configuration register"
MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register


;__________________________________________________________________________________________
;
;
; Interrupt Vector Definitions and Masks
;
;
;__________________________________________________________________________________________



;---------------------------------------------------
; Interrupt Masks
;---------------------------------------------------

;(see below) hiIntMask 		EQU 		$0700					; programmer switch only
;(see below) pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
;(see below) sccIntMask		EQU 		$0400					; SCC interrupt level
;(see below) sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
;(see below) slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
;(see below) viaIntMask		EQU 		$0100					; VIA1 interrupt level
;(see below) loIntMask 		EQU 		$0100


;---------------------------------------------------
; Hardware Base Addresses
;---------------------------------------------------

;(see below) WrOffs			EQU			0						; SCSI write addrs are same as read base
;(see below) MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
;(see below) MskVIA1			EQU			1						; VIA 1 is level 1
;(see below) MskADB			EQU			1						; ADB is level 1
;(see below) Msk60Hz			EQU			1						; 60 Hz is level 1
;(see below) MskSCSI			EQU			2						; SCSI is level 2
;(see below) MskSound		EQU			2						; sound is level 2						<4.5>
;(see below) MskSlots		EQU			2						; slots are level 2 interrupts
;(see below) MskRTC			EQU			3						; RTC is level 3
;(see below) MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
;(see below) MskPwrOff		EQU			6						; Poweroff button is level 6
;(see below) MskNMI			EQU			7						; NMI switch is level 7


; ---------------------------------------------------------------------------------------------------	<T8>
;		Bit definitions for the Cache Control Register (CACR) on various CPUs							<T8>
; ---------------------------------------------------------------------------------------------------	<T8>
;
;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)										<T8>
;			+------------------------------------------------+											<T8>
;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |											<T8>
;			+------------------------------------------------+											<T8>
;			  31                  4    3      2     1     0												<T8>
;
;				C   =  Clear Cache																		<T8>
;				CE  =  Clear Entry																		<T8>
;				F   =  Freeze Cache																		<T8>
;				E   =  Enable (Inst.) Cache																<T8>
;
;
;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)										<T8>
;			+------------------------------------------------------------------------------------+		<T8>
;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |		<T8>
;			+------------------------------------------------------------------------------------+		<T8>
;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0		<T8>
;
;				WA  =	Write Allocate																	<T8>
;				DBE =	Data Burst Allocate																<T8>
;				CD	=	Clear Data Cache																<T8>
;				CED	=	Clear Entry in Data Cache														<T8>
;				FD	=	Freeze Data Cache																<T8>
;				ED	=	Enable Data Cache																<T8>
;				IBE	=	Instruction Burst Enable														<T8>
;				CI	=	Clear Instruction Cache															<T8>
;				CEI	=	Clear Entry in Instruction Cache												<T8>
;				FI	=	Freeze Instruction Cache														<T8>
;				EI	=	Enable Instruction Cache														<T8>
;
;
;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)									<T8>
;			+-------------------------------------+														<T8>
;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |														<T8>
;			+-------------------------------------+														<T8>
;			   31    30     16    15    14     0														<T8>
;
;				DE	=	Enable Data Cache																<T8>
;				IE	=	Enable Instruction Cache														<T8>
;

;	MC68040 CACR bits of note:

CACR_IE_040				EQU		15				; bit # of instruction cache enable/disable on 040s		<T8>
CACR_DE_040				EQU		31				; bit # of data cache enable/disable on 040s			<T8>

;	MC68020 and MC68030 CACR bits of note:

CACR_EI_020_030			EQU		0				; bit # of inst. cache enable/disable on 020/030s		<T8>
CACR_FI_020_030			EQU		1				; bit # of inst. cache freeze on 020/030s				<T8>
CACR_CEI_020_030		EQU		2				; bit # of inst. cache flush entry on 020/030s			<T8>
CACR_CI_020_030			EQU		3				; bit # of inst. cache flush on 020/030s				<T8>
CACR_IBE_030			EQU		4				; bit # of data cache burst enable on 030s				<T8>
CACR_ED_030				EQU		8				; bit # of data cache enable/disable on 030s			<T8>
CACR_FD_030				EQU		9				; bit # of data cache freeze on 030s					<T8>
CACR_CED_030			EQU		10				; bit # of data cache flush entry on 030s				<T8>
CACR_CD_030				EQU		11				; bit # of data cache flush on 030s						<T8>
CACR_DBE_030			EQU		12				; bit # of data cache burst enable on 030s				<T8>
CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>

;__________________________________________________________________________________________
;
;
; Miscellaneous Equates - Look Here If You Can't Find It Anywhere Else.
;
;
;__________________________________________________________________________________________



;(see below) Machine   		EQU 		7						; new Machine number for patches			<18>

;---------------------------------------------------
; System Software Information
;---------------------------------------------------

;(see below) numOsTrap 		EQU 		256   					; number of os traps
;(see below) ToolTable 		EQU 		$0E00 					; start of toolbox trap table
;(see below) numTbTrap 		EQU 		1024   					; number of toolbox traps
;(see below) numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
;(see below) HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
;(see below) defSysHeap		EQU 		$18000    				; Default size of the system heap
;(see below) nDfltStackSize	EQU 		$6000 					; Default stack size

**** maybe not so temporary to allow things to build ****									<3.5>
;(see below) oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
	IF BlackBirdDebug THEN
;(see below) ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
	ELSE
;(see below) ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
	ENDIF
;(see below) snd2MemTop		EQU 		$300  					; SoundLow to Memtop
;(see below) pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
;(see below) bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>

;---------------------------------------------------								<SM4> rb, start
;  Sound parameters																			<P4>
;---------------------------------------------------
sampleSize		equ			4				; number of bytes per sample
bufferSize		equ			960				; number of samples per buffer
sampleRate		equ			24 * 1024		; 24KHz sample rate

;---------------------------------------------------
;  PSC Hardware Defs
;---------------------------------------------------

; === Hardware Base Addresses ===
PSCBase			equ			$50f31000		; Base address of the PSC

;---------------------------------------------------
;  PSC Sound Register Offsets
;---------------------------------------------------
sndComCtl		equ			$200			; [word] sound and communications control
singerCtl		equ			$204			; [long] singer sound CODEC control
singerStat		equ			$208			; [long] singer sound CODEC status  (read only)
sndPhase		equ			$20c			; [long] sound subsystem phase  (read only)
sndInBase		equ			$210			; [long] sound input double-buffer base address
sndOutBase		equ			$214			; [long] sound output double buffer base address
sndSize			equ			$218			; [word] sound input and output buffer size
dspOverRun		equ			$21C			; [byte] DSP overrun status register.

;---------------------------------------------------
;  PSC Sound Register Bit Definitions
;---------------------------------------------------
; === sndComCtl register ===
pSubFrmInSel	equ			0				; singer sound CODEC input subframe select
pSubFrmInSel1	equ			0				; singer sound CODEC input subframe select, lsbit
pSubFrmInSel2	equ			1				; singer sound CODEC input subframe select, msbit

pSubFrmOutSel	equ			2				; singer sound CODEC output subframe select
pSubFrmOutSel1	equ			2				; singer sound CODEC output subframe select, lsbit
pSubFrmOutSel2	equ			3				; singer sound CODEC output subframe select
pSubFrmOutSel3	equ			4				; singer sound CODEC output subframe select
pSubFrmOutSel4	equ			5				; singer sound CODEC output subframe select, msbit

pFrmIntEn		equ			6				; frame interrupt enable
pSndInEn		equ			7				; sound input DMA enable
pSndOutEn		equ			8				; sound output DMA enable

pSndRate		equ			9				; singer sound CODEC sampling rate control
pSndRate1		equ			9				; singer sound CODEC sampling rate control, lsbit
pSndRate2		equ			10				; singer sound CODEC sampling rate control, msbit

pComRate		equ			11				; communications CODEC sampling rate contrl
pComRate1		equ			11				; communications CODEC sampling rate contrl, lsbit
pComRate2		equ			12				; communications CODEC sampling rate contrl, msbit
;				equ			13				; unused
;				equ			14				; unused
;				equ			15				; unused


sndComCtlInit 	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
							(0<<pSubFrmOutSel)|\	; Ouput subframe zero selected
							(0<<pFrmIntEn)|\		; frame interrupts disabled
							(0<<pSndInEn)|\			; sound input disabled
							(0<<pSndOutEn)|\		; sound output disabled
							(0<<pSndRate)|\			; 24KHz sampling rate selected
							(0<<pComRate)			; communications CODEC, we just don't care

soundOutEnable	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
							(1<<pSubFrmOutSel)|\	; Ouput subframe zero selected
							(0<<pFrmIntEn)|\		; frame interrupts enabled
							(0<<pSndInEn)|\			; sound input disabled
							(1<<pSndOutEn)|\		; sound output disabled
							(0<<pSndRate)|\			; 24KHz sampling rate selected
							(0<<pComRate)			; communications CODEC, we just don't care



; === singerCtl register ===
pOutputPort	equ			0					; set digital output port
pOutputPort1	equ			0				; set digital output port, lsb
pOutputPort2	equ			1				; set digital output port
pOutputPort3	equ			2				; set digital output port
pOutputPort4	equ			3				; set digital output port, msb

pRightAtten		equ			4				; right ouput attenutaion
pRightAtten1	equ			4				; right ouput attenutaion, lsb
pRightAtten2	equ			5				; right ouput attenutaion
pRightAtten3	equ			6				; right ouput attenutaion
pRightAtten4	equ			7				; right ouput attenutaion, msb

pLeftAtten		equ			8				; Left ouput attenutaion
pLeftAtten1		equ			8				; Left ouput attenutaion, lsb
pLeftAtten2		equ			9				; Left ouput attenutaion
pLeftAtten3		equ			10				; Left ouput attenutaion
pLeftAtten4		equ			11				; Left ouput attenutaion, msb

pRightGain		equ			12				; right input gain
pRightGain1		equ			12				; right input gain, lsb
pRightGain2		equ			13				; right input gain
pRightGain3		equ			14				; right input gain
pRightGain4		equ			15				; right input gain, msb

pLeftGain		equ			16				; left input gain
pLeftGain1		equ			16				; left input gain, lsb
pLeftGain2		equ			17				; left input gain
pLeftGain3		equ			18				; left input gain
pLeftGain4		equ			19				; left input gain, msb

pRightInMux		equ			20				; right input mux
pLeftInMux		equ			21				; left input mux
pMute			equ			22				; mute bit
pExpCtl			equ			23				; expand bit for control
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused

singerCtlInit	equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
							(0<<pRightAtten)|\		; right output attenuation set to zero
							(0<<pLeftAtten)|\		; left output attenuation set to zero
							(%0101<<pRightGain)|\	; right input gain set to middle
							(%0101<<pLeftGain)|\	; left input gain set to middle
							(0<<pRightInMux)|\		; input muxes irrelevant
							(0<<pLeftInMux)|\		;
							(1<<pMute)|\			; mute ON
							(0<<pExpCtl)			; no expand

unMute			equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
							(0<<pRightAtten)|\		; right output attenuation set to zero
							(0<<pLeftAtten)|\		; left output attenuation set to zero
							(%0101<<pRightGain)|\	; right input gain set to middle
							(%0101<<pLeftGain)|\	; left input gain set to middle
							(0<<pRightInMux)|\		; input muxes irrelevant
							(0<<pLeftInMux)|\		;
							(0<<pMute)|\			; mute OFF
							(0<<pExpCtl)			; no expand



; === singerStat register ===
pInputPort1		equ			0				; set digital Input port, lsb
pInputPort2		equ			1				; set digital Input port
pInputPort3		equ			2				; set digital Input port
pInputPort4		equ			3				; set digital Input port, msb
;				equ			4				; unused
;				equ			5				; unused
;				equ			6				; unused
;				equ			7				; unused
;				equ			8				; unused
;				equ			9				; unused
;				equ			10				; unused
;				equ			11				; unused
pRevNum1		equ			12				; revision number, lsb
pRevNum2		equ			13				; revision number
pRevNum3		equ			14				; revision number
pRevNum4		equ			15				; revision number, msb
pSingerStatus1	equ			16				; status bits, lsb
pSingerStatus2	equ			17				; status bits
pSingerStatus3	equ			18				; status bits
pSingerStatus4	equ			19				; status bits, msb
pOFRight		equ			20				; right channel overflow
pOFLeft			equ			21				; left channel overflow
pValidData		equ			22				; valid sound data
pExpStat		equ			23				; expand bit for status
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused


; === sound phase register ===
pPreScaleLSB	equ			0				; pre-scaler lsbit
pReScaleMSB		equ			5				; pre-Scaler msbit
pOffsetLSB		equ			6				; sample offset lsbit
pOffsetMSB		equ			17				; sample offset msbit
;				equ			18				; unused
;				equ			19				; unused
;				equ			20				; unused
;				equ			21				; unused
;				equ			22				; unused
;				equ			23				; unused
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused

phaseOffsetMsk	equ			$003FFFC0		;										<SM4> rb, end

;---------------------------------------------------
; PSC DSP Register Bit Definitions						<SM10> ejb
;---------------------------------------------------

; === dspOverrun register ===
pdspReset		equ			0				; when set places the dsp in reset state
pdspResetEn		equ			1				; when cleared disables the dspReset bit
pdspFrameOvr	equ			2				; when set indicates cat2 frame overrun on the dsp
;				equ			3				; unused
;				equ			4				; unused
;				equ			5				; unused
;				equ			6				; unused
pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a "1"

;---------------------------------------------------
; ???
;---------------------------------------------------

;seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay

;---------------------------------------------------
; Hardware configuration bits.
;---------------------------------------------------

hwCbSCSI  		EQU 		15        				; SCSI port present
hwCbClock 		EQU 		14        				; New clock chip present
hwCbExPRAM		EQU 		13        				; Extra Parameter Ram valid.
hwCbFPU   		EQU 		12        				; FPU chip present.
hwCbMMU   		EQU 		11        				; Some kind of MMU present (see MMUType for what kind).
hwCbADB   		EQU 		10        				; Apple Desktop Bus present.
hwCbAUX			EQU			9						; Running A/UX					<2.8>
hwCbPwrMgr		EQU			8						; Power Manager present			<2.8>
hwCmSCSI  		EQU 		(1 << hwCbSCSI)
hwCmClock 		EQU 		(1 << hwCbClock)
hwCmExPRAM		EQU 		(1 << hwCbExPRAM)
hwCmFPU   		EQU 		(1 << hwCbFPU)
hwCmMMU   		EQU 		(1 << hwCbMMU)
hwCmADB   		EQU 		(1 << hwCbADB)
hwCmAUX			EQU			(1 << hwCbAUX)
hwCmPwrMgr		EQU			(1 << hwCbPwrMgr)


;---------------------------------------------------
; HcMac Clock Change Addresses
;---------------------------------------------------

Clock16M  		EQU 		$FE0000   				; Go to sixteen megahertz clock throughput
Clock1M   		EQU 		$FE0002   				; Go to one megahertz clock throughput (adds 64 wait states)


;---------------------------------------------------
; SCC Clock Rates, Baud Rate Constants
;---------------------------------------------------

nuMacClock		EQU 		36864
nuMacConst		EQU 		115200

macClock  		EQU 		36707 					; in Hz * 100
macConst  		EQU 		114709    				; in Hz/32

hcMacClock		EQU 		36720 					; SCC clock rates
hcMacConst		EQU 		114750


;---------------------------------------------------
; Deep Shit Rectangle info
;---------------------------------------------------

dsRectTL  		EQU 		(64<<16)+32       		; top left = 64,32
dsRectBR  		EQU 		(190<<16)+480     		; bottom right = 190,480
dsRectHei 		EQU 		(DSrectBR**$FFFF0000)-(DSrectTL**$FFFF0000)>>16
dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)


;---------------------------------------------------
; System Error Equates
;---------------------------------------------------

;seVars			EQU 		seRegs        			; start of system error data space (wrap city)
;seVSize   		EQU 		128       				; # of bytes in space
;seD0  			EQU 		seVars        			; loc of saved reg D0
;seA0  			EQU 		seD0+32       			; loc of saved reg A0
;seA7  			EQU 		seA0+28       			; loc of saved reg A7
;sePC  			EQU 		seA7+4        			; loc of saved PC
;seSR  			EQU 		sePC+4        			; loc of saved SR
;seAccess  		EQU 		seSR+2        			; PC address during bus/address error
;seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
;se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
;seLastVar 		EQU 		se000BE+8     			; last var in System Error data space


;---------------------------------------------------
; ROM based debugger nub
;---------------------------------------------------

;rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
;rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
;rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
;rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
;rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
;rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
;rdEnd 			EQU 		rdResult+16       		; end of vars


;---------------------------------------------------
; Microbug
;---------------------------------------------------

; NOTE: Keep mbDotAddr immediately before mBlocAddr

mbBufSize 		EQU 		34
;mbBuffer  		EQU 		seLastVar     			; buffer for input
;mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
;mbDotAddr 		EQU 		mbSign+2      			; saved address
;mBlocAddr 		EQU 		mbDotAddr+4       		; saved location


;---------------------------------------------------
; Alternate ROM vectors
;---------------------------------------------------

DiagROM   		EQU 		$F80000   				; Alternate ROM - initial vector
DiagROM1  		EQU 		$F80080   				; Alternate ROM - memory sizing vector
DiagROM2  		EQU 		$F80088   				; Alternate ROM - init I/O vector


;---------------------------------------------------
; Timing constants
;---------------------------------------------------

VIAClockHz		EQU			783360					; VIA clock rate is 783360 Hz.		<2.8>
nTicks			EQU 		VIAClockHz/1000   		; VIA timer ticks per msec
oneSecTicks   	EQU 		60    					; ticks, of course
				IF &TYPE('__SysEqu__') = 'UNDEFINED' THEN
TimeSCSIDB		EQU			$0B24					; DBRAs & SCSI access per millisecond <1.9>
				ENDIF

ramChk			EQU 		1024      				; Amount of memory tested for stack.



;__________________________________________________________________________________________
;
;
; ROM Header RECORD Definition
;
;
;__________________________________________________________________________________________

ROMHeader		RECORD		0,INCREMENT				; offsets to fields in base of ROM
ResetSP				DS.L		1					; $0000 SP to be loaded at reset time
CheckSum			EQU			ResetSP				; $0000 hiram stuffs checksum here
ResetPC				DS.L		1					; $0004 PC to be loaded at reset time
MachineNumber		DS.B		1					; $0008 Machine Number
ROMVersion			DS.B		1					; $0009 ROM Version Number
ReStart				DS.W		2					; $000A JMP to StartBoot routine
BadDisk				DS.W		2					; $000E JMP to eject disk, and ReBoot routine
ROMRelease			DS.W		1					; $0012 ROM Release in HEX, eg. $10B5 is 1.0ß5
PatchFlags			DS.B		1					; $0014 ROM overpatch basis					<H14>
					DS.B		1					; $0015 unused								<H14>
ForeighOSTbl		DS.L		1					; $0016 offset to foreign OS vector table
RomRsrc				DS.L		1					; $001A HiRam stuffs offset to ROM rsrc header here
Eject				DS.W		2					; $001E JMP to DoEject routine
DispTableOff		DS.L		1					; $0022 offset to the compressed dispatch table
Critical			DS.W		2					; $0026 JMP to Critical error handler
ResetEntry			DS.W		2					; $002A JMP to Reset Entry Point routine.
RomLoc				DS.B		1					; $002E (Bit 0: In Ram, Bit 1: In Emulator)
					DS.B		1					; $002F unused
CheckSum0			DS.L		1					; $0030 checksum 0
CheckSum1			DS.L		1					; $0034 checksum 1
CheckSum2			DS.L		1					; $0038 checksum 2
CheckSum3			DS.L		1					; $003C checksum 3
RomSize				DS.L		1					; $0040 HiRam stuffs size of ROM in bytes here
				ENDR


;---------------------------------------------------
; Romulator ROM location bits and TestFor Macro
;---------------------------------------------------

locValid1		EQU			7						; this must be 1
locValid2		EQU			6						; this must be 0
inEmulatorBit	EQU			1						; running in emulator
inRamBit		EQU			0						; running in ram



				If	onMac then
;=======================================;
;  Macintosh Plus Hardware Information	;
;=======================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock
machine   		EQU 		0
rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
vSound			EQU 		$7    					; sound volume bits (0..2)
vSndPg2   		EQU 		3 						; select sound page 2 if 0
vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
vHeadSel  		EQU 		5 						; head select line for Sony
vPage2			EQU 		6 						; select video page 2 if 0
vSCCWrReq 		EQU 		7 						; SCC write/request line

vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
							(1<<vSndPg2)|\			; sound page 2 select is an output
							(1<<vOverlay)|\			; overlay bit is an output
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; video page 2 select is an output
							(0<<vSCCWrReq)			; SCC write/request line is an input

vAInit 			EQU 		(1)|\					; sound volume level initially 1
							(1<<vSndPg2)|\			; main sound buffer selected
							(0<<vOverlay)|\			; overlay is turned off
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; main screen buffer selected
							(0<<vSCCWrReq)			; SCC write/request line is an input


; === VIA1 BUFFER B ===
vRTCData  		EQU 		0 						; real time clock data
vRTCClk   		EQU 		1 						; real time clock clock pulses
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vSW   			EQU 		3 						; mouse switch (0 when down)
vX2   			EQU 		4 						; mouse X level
vY2   			EQU 		5 						; mouse Y level
vH4   			EQU 		6 						; horizontal sync
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)

vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
							(1<<vRTCClk)|\			; real time clock clock is an output
							(1<<vRTCEnb)|\			; clock enable is an output
							(0<<vSW)|\				; mouse switch is an input
							(0<<vX2)|\				; mouse X level is an input
							(0<<vY2)|\				; mouse Y level is an input
							(0<<vH4)|\				; horizontal sync is an input
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
							(1<<vRTCClk)|\			; real time clock clock is high
							(1<<vRTCEnb)|\			; clock initially disabled
							(0<<vSW)|\				; mouse switch is an input
							(0<<vX2)|\				; mouse X level is an input
							(0<<vY2)|\				; mouse Y level is an input
							(0<<vH4)|\				; horizontal sync is an input
							(1<<vSndEnb)			; sound is disabled

vBufM			EQU 		vBufB  					; mouse state is buffer B


; === Hardware Base Addresses ===

PhaseRead 		EQU 		$F00000   				; Phase read address

VBase 			EQU 		$EFE1FE   				; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B
AVBufM			EQU 		VBase+vBufM  			; VIA buffer with mouse button bit

SCCRBase  		EQU 		$9FFFF8   				; SCC base read address
SCCWBase  		EQU 		$BFFFF9   				; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

SCSIRd			EQU 		$580000   				; base addr SCSI interface - READ
SCSIWr			EQU 		$580001   				; base addr SCSI interface - WRITE
wrOffs			EQU 		SCSIWr-SCSIRd			; write addrs are +1 to the read base

SoundLow  		EQU 		$3FFD00   				; sound buffer start address
snd2MemTop		EQU 		$300  					; SoundLow to Memtop

PWMBuffer 		EQU 		$3FFD01   				; PWM bytes are low bytes
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop

; === Video Parameters ===

ScreenLow 		EQU 		$3FA700   				; top of screen screen address
scrn2MemTop   	EQU 		$5900 					; ScreenBase to Memtop

; === Hardware Base Addresses ===

romBSize  		EQU 		$20000    				; 128K bytes in ROM $0075
ROMStart  		EQU 		$400000   				; starting address of ROM code

DBase 			EQU 		$DFE1FF   				; disk address base

; === System Software Information ===
bufWorldSize  	EQU 		scrn2MemTop   			; total size of the BufPtr world

oneSecConst   	EQU 		2 						; gets converted to $20000 for onesec constant
numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0C00 					; start of toolbox trap table
numTbTrap 		EQU 		512   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1400 					; Mac Plus starting point
defSysHeap		EQU 		$B700 					; Default size of the system heap
nDfltStackSize	EQU 		$2000 					; Default stack size

oneSec			EQU 		95528 					; looptimes						*** patch only ***
halfSec   		EQU 		onesec/2				;								*** patch only ***
stlDelay  		EQU 		$30   					; default bus settle delay		*** patch only ***
ROMDoEject		EQU 		$40001E   				; jump to DoEject utility		*** patch only ***
dACKRd			EQU 		$200  					; offset of psuedo-DMA - READ	*** patch only ***

seRegs      EQU     $3FFC80           ; Sys Error Regs w/o Overlay

  				ELSEIF  	onMacPP THEN
;=======================================;
;	Macintosh SE Hardware Information	;
;=======================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmADB
machine   		EQU 		2
rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
vSound			EQU 		$7    					; sound volume bits (0..2)
vSync 			EQU 		3 						; Synchronous modem
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
vHeadSel  		EQU 		5 						; head select line for Sony
vPage2			EQU 		6 						; select video page 2 if 0
vSCCWrReq 		EQU 		7 						; SCC write/request line

vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
							(1<<vSync)|\			; Synchronous modem is an output
							(1<<vDriveSel)|\		; int drive select is an output
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; video page 2 select is an output
							(0<<vSCCWrReq)			; SCC write/request line is an input

vAInit 			EQU 		(1)|\					; sound volume level initially 1
							(1<<vSync)|\			; Synchronous modem disabled (active low)
							(0<<vDriveSel)|\		; upper floppy drive selected
							(1<<vHeadSel)|\			; head select line is an output
							(1<<vPage2)|\			; main screen buffer selected
							(0<<vSCCWrReq)			; SCC write/request line is an input



; === VIA1 BUFFER B ===
vRTCData  		EQU 		0 						; real time clock data
vRTCClk   		EQU 		1 						; real time clock clock pulses
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vSCSIMask 		EQU 		6 						; SCSI IRQ mask
vH4   			EQU 		vSCSIMask				; SCSI IRQ mask (was horiz. sync)
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)

vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
							(1<<vRTCClk)|\			; real time clock clock is an output
							(1<<vRTCEnb)|\			; clock enable is an output
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is an output
							(1<<vFDesk2)|\			; FDB state bit 1 is an output
							(1<<vSCSIMask)|\		; SCSI IRQ mask is an output
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
							(1<<vRTCClk)|\			; real time clock clock is high
							(1<<vRTCEnb)|\			; clock initially disabled
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
							(1<<vSCSIMask)|\		; SCSI IRQ mask is initially masked
							(1<<vSndEnb)			; sound is disabled


; === Hardware Base Addresses ===

VBase 			EQU 		$EFE1FE   				; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B

SCCRBase  		EQU 		$9FFFF8   				; SCC base read address
SCCWBase  		EQU 		$BFFFF9   				; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

SCSIRd			EQU 		$5FF000   				; base addr SCSI interface - READ
SCSIWr			EQU 		$5FF001   				; base addr SCSI interface - WRITE
MacSCSIBase   	EQU 		$5FF000   				; base addr SCSI READ interface
MacSCSIDMA		EQU 		$5FF200   				; base addr SCSI DMA
MacSCSIHsk		EQU 		$5FF200   				; base addr SCSI handshake
wrOffs			EQU 		SCSIWr-SCSIRd			; write addrs are +1 to the read base

SoundLow  		EQU 		$3FFD00   				; sound buffer start address
snd2MemTop		EQU 		$300  					; SoundLow to Memtop

PWMBuffer 		EQU 		$3FFD01   				; PWM bytes are low bytes
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop

; === Video Parameters ===

ScreenLow 		EQU 		$3FA700   				; top of screen screen address
scrn2MemTop   	EQU 		$5900 					; ScreenBase to Memtop

; === Hardware Base Addresses ===

romBSize  		EQU 		$40000    				; 256K bytes in present ROM
ROMStart  		EQU 		$400000   				; starting address of ROM code

DBase 			EQU 		$DFE1FE   				; disk address base

; === System Software Information ===
bufWorldSize  	EQU 		scrn2MemTop   			; total size of the BufPtr world

oneSecConst   	EQU 		2 						; gets converted to $20000 for onesec constant
numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table

numTbTrap 		EQU 		512   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1600 					; Aladdin starting point

defSysHeap		EQU 		$18000    				; Default size of the system heap
nDfltStackSize	EQU 		$2000 					; Default stack size

seRegs      EQU     $3FFC80           ; Sys Error Regs w/o Overlay

  				ELSEIF  	onHcMac THEN
;===========================================;
;	Macintosh Portable Hardware Information	;
;===========================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmADB++hwCbPwrMgr				; <2.8>
machine   		EQU 		3
rom85Bits 		EQU 		$7F   					; New ROMs, No Power Off.


; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100


; === VIA1 BUFFER A ===
													; 68000 <-> PowerMgr data bus
vAIn  			EQU 		$00   					; VBufA output bits (all inputs)
vAOut 			EQU 		$FF   					; VBufA output bits (all outputs)
vAInit			EQU 		$00   					; VBufA initial values


; === VIA1 BUFFER B ===
vPMreq			EQU 		0 						; Power manager handshake request
vPMack			EQU 		1 						; Power manager handshake acknowledge
vTestJ			EQU 		2 						; Test jumper
vSync 			EQU 		3 						; Synchronous modem
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
vHeadSel  		EQU 		5 						; head select line for Sony
vStereo   		EQU 		6 						; Stereo sound enable
vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)	(output)

vBOut 			EQU 		(1<<vPMreq)|\			; Power mgr handshake request is an output
							(0<<vPMack)|\			; Power mgr handshake acknowledge is an input
							(0<<vTestJ)|\			; Test jumper is an input
							(1<<vSync)|\			; Synchronous modem is an output
							(1<<vDriveSel)|\		; int drive select is an output
							(1<<vHeadSel)|\			; head select line is an output
							(0<<vStereo)|\			; Stereo sound detect is an input
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vPMreq)|\			; Power mgr handshake not requesting
							(1<<vPMack)|\			; Power mgr handshake acknowledge is an input
							(1<<vTestJ)|\			; Test jumper is an input
							(1<<vSync)|\			; Synchronous modem disabled (active low)
							(1<<vDriveSel)|\		; lower floppy drive selected
							(0<<vHeadSel)|\			; head select line is an output
							(1<<vStereo)|\			; Stereo sound detect is an input
							(1<<vSndEnb)			; sound is disabled

vBufD 			EQU 		vBufB 					; disk head select is buffer B


; === Hardware Base Addresses ===

VBase 			EQU 		$F70000   				; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B

SCCRBase  		EQU 		$FD0000   				; SCC base read address
SCCWBase  		EQU 		$FD8000   				; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

SCSIRd			EQU 		$F90000   				; base address of SCSI interface - READ
SCSIWr			EQU 		$F90001   				; base address of SCSI interface - WRITE
MacSCSIBase   	EQU 		$F90000   				; base address of SCSI READ interface
MacSCSIDMA		EQU 		$F90200   				; base address of SCSI DMA
MacSCSIHsk		EQU 		$F90200   				; base address of SCSI handshake
wrOffs			EQU 		SCSIWr-SCSIRd			; write addrs are +1 to the read base

SndBase   		EQU 		$FB0000   				; sound chip's base address

MapperBase		EQU 		$FC0000   				; Mapper RAM base address

RAMconfigBase 	EQU 		$FE0200   				; Internal/external RAM control register
RAMconfigInit	EQU			$0006					; Init test register						<v2.6>

; === Video Parameters ===

ScreenLow 		EQU 		$FA8000   				; top of screen screen address
hcVideoSize   	EQU 		$8000 					; 32k of video memory
HcVideoStart  	EQU 		ScreenLow
HcVideoEnd		EQU 		HcVideoStart+hcVideoSize
NTSCMaxX		EQU			512						; NTSC output is narrow
NTSCOffset		EQU			8						;  and centered
LCDmode			EQU			0						; Normal built in screen
Mac2mode		EQU			1						; Custom screen for Mac2
NTSCmode		EQU			2						; NTSC output for Topanga

; === Hardware Base Addresses ===

romBSize  		EQU 		$40000    				; 256K bytes in present ROM
ROMStart  		EQU 		$900000   				; starting address of ROM code

DBase 			EQU 		$F6E1FF   				; disk address base

AccessBase		EQU 		$FC0200   				; SLIM card DTACK counter load address (what a mouthful)
SLIMinserted	EQU			3						; SLIMs inserted bit 						<v2.6>

; === System Software Information ===
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world

oneSecConst   	EQU 		2 						; gets converted to $20000 for onesec constant
numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table
numTbTrap 		EQU 		1024   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1E00 					; Portable starting point	<1.2>
DefSysHeap		EQU 		$18000    				; Default size of the system heap
NDfltStackSize	EQU 		$2000 					; Default stack size

seRegs      EQU     $0C30           ; offset to Sys Error Regs w/o Overlay

  				ELSEIF  	onMac16 THEN
;===================================================;
;	Universal 16 bit Macintosh Hardware Information	;
;===================================================;


; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
sccIntMask		EQU 		$0200 					; SCC interrupt Level		<1.5>
sccEnblMask   	EQU 		$F9FF 					; mask to enable SCC interrupts
viaIntMask		EQU 		$0100 					; mask for VIA (and VBL) interrupts
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
vSound			EQU 		$7    					; sound volume bits (0..2)
vSndPg2   		EQU 		3 						; select sound page 2 if 0
vSync 			EQU 		3 						; Synchronous modem
vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
vHeadSel  		EQU 		5 						; head select line for Sony
vPage2			EQU 		6 						; select video page 2 if 0
vSCCWrReq 		EQU 		7 						; SCC write/request line

; === VIA1 BUFFER B ===
vRTCData  		EQU 		0 						; real time clock data
vRTCClk   		EQU 		1 						; real time clock clock pulses
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vSW   			EQU 		3 						; mouse switch (0 when down)
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vX2   			EQU 		4 						; mouse X level
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vY2   			EQU 		5 						; mouse Y level
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vH4   			EQU 		6 						; horizontal sync
vSCSIMask 		EQU 		6 						; SCSI IRQ mask
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)

vPMreq			EQU 		0 						; Power manager handshake request
vPMack			EQU 		1 						; Power manager handshake acknowledge
vTestJ			EQU 		2 						; Test jumper
vSync 			EQU 		3 						; Synchronous modem
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)
vHeadSel  		EQU 		5 						; head select line for Sony
vStereo   		EQU 		6 						; Stereo sound enable
vSCCWrReq 		EQU 		7 						; SCC write/request line		(input)

; === VIA1 BUFFER A/B ===
vSync 			EQU 		3 						; Synchronous modem						<3.1>
vDriveSel 		EQU 		4 						; int drive select (lower drive when 1)	<3.1>
vHeadSel  		EQU 		5 						; head select line for Sony				<3.1>
vSCCWrReq 		EQU 		7 						; SCC write/request line				<3.1>

; === Hardware Base Addresses ===

wrOffs			EQU 		1						; write addrs are +1 to the read base

; === System Software Information ===

numOsTrap 		EQU 		256   					; number of os traps
ToolTable 		EQU 		$0E00 					; start of toolbox trap table
numTbTrap 		EQU 		1024   					; number of toolbox traps
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
HeapStart 		EQU 		$1E00 					; Laguna starting point	<1.2>
DefSysHeap		EQU 		$18000    				; Default size of the system heap
NDfltStackSize	EQU 		$2000 					; Default stack size

seRegs      EQU     $0C30           ; offset to Sys Error Regs w/o Overlay

  				ELSEIF  	onMac32 THEN
;===================================================;
;	Universal 32 bit Macintosh Hardware Information	;
;===================================================;

machine   		EQU 		6						; for patch file $067C					<3.5>

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700					; programmer switch only
pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
sccIntMask		EQU 		$0400					; SCC interrupt level
sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
viaIntMask		EQU 		$0100					; VIA1 interrupt level
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
vTestJ			EQU 		0 						; Burn In Test jumper		(input)
vCpuId0			EQU			1						; CPU Identification bit 0	(input)
vCpuId1			EQU			2						; CPU Identification bit 1	(input)
vSync 			EQU 		3 						; Synchronous modem
vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
vCpuId2			EQU			4						; CPU Identification bit 2
vHeadSel  		EQU 		5 						; head select line for Sony
vRev8Bd   		EQU 		6 						; =0 for rev 8 board
vCpuId3			EQU			6						; CPU Identification bit 3
vSCCWrReq 		EQU 		7 						; SCC write/request line

; === VIA1 BUFFER B ===
vRTCData  		EQU 		0 						; real time clock data
v0reserved		EQU			0						; reserved bit in Erickson				<6>
vRTCClk   		EQU 		1 						; real time clock clock pulses
v1reserved		EQU			1						; reserved bit in Erickson				<6>
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
v2reserved		EQU			2						; reserved bit in Erickson				<6>
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
xcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
viafullbit		EQU			4						; Egret via full bit					<6>
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
syssesbit		EQU			5						; Egret system session bit				<6>
vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
v6reserved		EQU			6						; reserved bit in Erickson				<6>
vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
v7reserved		EQU			7						; reserved bit in Erickson				<6>
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)


; === Hardware Base Addresses ===

WrOffs			EQU			0						; SCSI write addrs are same as read base

MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
MskVIA1			EQU			1						; VIA 1 is level 1
MskADB			EQU			1						; ADB is level 1
Msk60Hz			EQU			1						; 60 Hz is level 1
MskSCSI			EQU			2						; SCSI is level 2
MskSound		EQU			2						; sound is level 2						<4.5>
MskSlots		EQU			2						; slots are level 2 interrupts
MskRTC			EQU			3						; RTC is level 3
MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
MskPwrOff		EQU			6						; Poweroff button is level 6
MskNMI			EQU			7						; NMI switch is level 7

; === System Software Information ===
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay


  				ELSEIF  	onHafMac THEN
;===================================;
;	Mac IIci Hardware Information	;
;===================================;

machine   		EQU 		6

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700 					; programmer switch only
pwrOffEnbl		EQU 		$2500 					; mask to allow poweroff interrupts
sccIntMask		EQU 		$0400 					; SCC interrupt level
sccEnblMask   	EQU 		$FBFF 					; mask to enable SCC interrupts
via2IntMask   	EQU 		$0200 					; VIA2 interrupt level		<v1.4><1.9>
slotIntMask   	EQU 		via2IntMask   			; slot's interrupt level	<v1.4><1.9>
viaIntMask		EQU 		$0100 					; VIA1 interrupt level
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
vTestJ			EQU 		0 						; Burn In Test jumper		(input)
vCpuId0			EQU			1						; CPU Identification bit 0	(input)
vCpuId1			EQU			2						; CPU Identification bit 1	(input)
vSync 			EQU 		3 						; Synchronous modem
vCpuId2			EQU			4						; CPU Identification bit 2
vHeadSel  		EQU 		5 						; head select line for Sony
vCpuId3			EQU			6						; CPU Identification bit 3
vSCCWrReq 		EQU 		7 						; SCC write/request line

vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
							(1<<vSync)|\			; Synchronous modem is an output
							(0<<vCpuId2)|\			; CPU Identification bit 2 is an input
							(1<<vHeadSel)|\			; head select line is an output
							(0<<vCpuId3)|\			; CPU Identification bit 3 is an input
							(0<<vSCCWrReq)			; SCC write/request line is an input

vAInit 			EQU 		(1)|\					; sound volume level initially 1
							(0<<vSync)|\			; Synchronous modem disabled (active high)
							(0<<vCpuId2)|\			; CPU Identification bit 2 is an input
							(1<<vHeadSel)|\			; head select line is an output
							(0<<vCpuId3)|\			; CPU Identification bit 3 is an input
							(0<<vSCCWrReq)			; SCC write/request line is an input

vBufD 			EQU 		vBufA 					; disk head select is buffer A


; === VIA1 BUFFER B ===
vRTCData  		EQU 		0 						; real time clock data
vRTCClk   		EQU 		1 						; real time clock clock pulses
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)

vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
							(1<<vRTCClk)|\			; real time clock clock is an output
							(1<<vRTCEnb)|\			; clock enable is an output
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is an output
							(1<<vFDesk2)|\			; FDB state bit 1 is an output
							(1<<vPGCEnb)|\			; PGC enable is an output
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
							(1<<vRTCClk)|\			; real time clock clock is high
							(1<<vRTCEnb)|\			; clock initially disabled
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
							(1<<vPGCEnb)|\			; Parity Checking is initially disabled
							(1<<vSndEnb)			; sound is disabled


; === RBV BUFFER B ===
RvBInit			EQU			(1<<RvCDis)|\			; cache disabled	<3.3>
							(1<<RvBusLk)|\			; Bus unlocked
							(1<<RvPowerOff)|\		; Power on
							(1<<RvCFlush)|\			; don't flush cache
							(0<<RvTM1A)|\			; NuBus timeout bits are inputs
							(0<<RvTM0A)|\			; NuBus timeout bits are inputs
							(0<<RvSndExt)|\			; sound/speaker mode is an input
							(1<<RvPGCTest)			; generate correct parity


; === Hardware Base Addresses ===

VBase 			EQU 		$50F00000   			; VIA base address
AVBufA			EQU 		VBase+vBufA 			; VIA buffer A
AVBufB			EQU 		VBase+vBufB  			; VIA buffer B

SCCRBase  		EQU 		$50F04000   			; SCC base read address
SCCWBase  		EQU 		$50F04000   			; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase		; general offset for write from read

NewSCSIBase   	EQU 		$50F10000 				; rev8 base addr SCSI interface
NewSCSIDMA		EQU 		$50F12000 				; rev8 base addr SCSI DMA (corrected)
NewSCSIHsk		EQU 		$50F06000 				; rev8 base addr SCSI handshake
MacSCSIBase   	EQU 		$50F10000 				; base addr SCSI interface
MacSCSIDMA		EQU 		$50F12000 				; base addr SCSI DMA
MacSCSIHsk		EQU 		$50F06000 				; base addr SCSI handshake
wrOffs			EQU 		0 						; write addrs are same as read base

SndBase			EQU 		$50F14000 				; sound chip's base address

; === Video Parameters ===

RBVBase			EQU			$50F26000				; RBV base address				<v1.4><1.4>
vDACBase		EQU			$50F24000				; base of clut

; === System Software Information ===
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay

  				ELSEIF  	onNuMac THEN
;=======================================================;
;	Macintosh II, IIx, IIcx, SE30 Hardware Information	;
;=======================================================;

hwCfgBits 		EQU 		hwCmSCSI++hwCmClock++hwCmFPU++hwCmMMU++hwCmADB
machine   		EQU 		1
rom85Bits 		EQU 		$3F   					; New ROMs, Power Off ability.

; === Interrupt Masks ===
hiIntMask 		EQU 		$0700 					; programmer switch only
pwrOffEnbl		EQU 		$2500 					; mask to allow poweroff interrupts
sccIntMask		EQU 		$0400 					; SCC interrupt level
sccEnblMask   	EQU 		$FBFF 					; mask to enable SCC interrupts
via2IntMask   	EQU 		$0200 					; VIA2 interrupt level		<v1.4><1.9>
slotIntMask   	EQU 		via2IntMask   			; slot's interrupt level	<v1.4><1.9>
viaIntMask		EQU 		$0100 					; VIA1 interrupt level
loIntMask 		EQU 		$0100

; === VIA1 BUFFER A ===
vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
vSync 			EQU 		3 						; Synchronous modem
vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
vHeadSel  		EQU 		5 						; head select line for Sony
vRev8Bd   		EQU 		6 						; =0 for rev 8 board
vSCCWrReq 		EQU 		7 						; SCC write/request line

vAOut 			EQU 		(vSound)|\				; sound volume bits are outputs
							(1<<vSync)|\			; Synchronous modem is an output
							(1<<vOverlay)|\			; overlay bit is an output
							(1<<vHeadSel)|\			; head select line is an output
							(0<<vRev8Bd)|\			; board ID is an input
							(0<<vSCCWrReq)			; SCC write/request line is an input

vAInit 			EQU 		(1)|\					; sound volume level initially 1
							(0<<vSync)|\			; Synchronous modem disabled (active high)
							(0<<vOverlay)|\			; overlay is turned off
							(0<<vHeadSel)|\			; head select line is an output
							(0<<vRev8Bd)|\			; board ID is an input
							(0<<vSCCWrReq)			; SCC write/request line is an input

vBufD 			EQU 		vBufA 					; disk head select is buffer A


; === VIA1 BUFFER B ===
vRTCData  		EQU 		0 						; real time clock data
vRTCClk   		EQU 		1 						; real time clock clock pulses
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
;				EQU			6						; unused
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)

vBOut 			EQU 		(1<<vRTCData)|\			; real time clock data initially an output
							(1<<vRTCClk)|\			; real time clock clock is an output
							(1<<vRTCEnb)|\			; clock enable is an output
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is an output
							(1<<vFDesk2)|\			; FDB state bit 1 is an output
							(1<<vSndEnb)			; sound enable is an output

vBInit 			EQU 		(1<<vRTCData)|\			; real time clock data is one
							(1<<vRTCClk)|\			; real time clock clock is high
							(1<<vRTCEnb)|\			; clock initially disabled
							(0<<vFDBInt)|\			; Front Desk bus interrupt is an input
							(1<<vFDesk1)|\			; FDB state bit 0 is initially state 3
							(1<<vFDesk2)|\			; FDB state bit 1 is initially state 3
							(0<<vSndEnb)			; sound is enabled


; === VIA2 BUFFER A ===
v2AOut			EQU 		(0<<v2IRQ1)|\     		; slot 1 interrupt is an input
  				(0<<v2IRQ2)|\ 						; slot 2 interrupt is an input
  				(0<<v2IRQ3)|\ 						; slot 3 interrupt is an input
  				(0<<v2IRQ4)|\ 						; slot 4 interrupt is an input
  				(0<<v2IRQ5)|\ 						; slot 5 interrupt is an input
  				(0<<v2IRQ6)|\ 						; slot 6 interrupt is an input
  				(1<<v2RAM0)|\ 						; ram size bit 0 is an output
  				(1<<v2RAM1)   						; ram size bit 1 is an output

v2AInit			EQU			(0<<v2IRQ1)|\			; slot 1 interrupt is an input
							(0<<v2IRQ2)|\			; slot 2 interrupt is an input
							(0<<v2IRQ3)|\			; slot 3 interrupt is an input
							(0<<v2IRQ4)|\			; slot 4 interrupt is an input
							(0<<v2IRQ5)|\			; slot 5 interrupt is an input
							(0<<v2IRQ6)|\			; slot 6 interrupt is an input
							(0<<v2RAM0)|\			; or ram size bit 0 with 0
							(0<<v2RAM1)				; or ram size bit 1 with 0


; === VIA2 BUFFER B ===
v2BOut			EQU			(0<<v2CDis)|\			; cache disabled	<3.3>
  				(0<<v2BusLk)|\						; Bus unlocked
  				(0<<v2PowerOff)|\ 					; Power on
  				(0<<vFC3)|\   						; don't flush cache
  				(0<<v2TM1A)|\ 						; NuBus timeout bits are inputs
  				(0<<v2TM0A)|\ 						; NuBus timeout bits are inputs
  				(0<<v2SndExt)|\   					; sound/speaker mode is an input
  				(1<<v2VBL)							; 60Hz pseudo VBL output

v2BInit			EQU			(1<<v2CDis)|\			; cache disabled (input when not in use)	<3.3>
							(0<<v2BusLk)|\			; Bus unlocked	(input when not in use)
							(1<<v2PowerOff)|\		; Power on	(input when not in use)
							(0<<vFC3)|\				; don't flush cache	(input when not in use)
							(0<<v2TM1A)|\			; NuBus timeout bits are inputs
							(0<<v2TM0A)|\			; NuBus timeout bits are inputs
							(0<<v2SndExt)|\			; sound/speaker mode is an input
							(0<<v2VBL)				; 60Hz pseudo VBL output


; === Hardware Base Addresses ===

VBase 			EQU 		$50F00000     			; VIA base address
AVBufA			EQU 		VBase+vBufA       		; VIA buffer A
AVBufB			EQU 		VBase+vBufB       		; VIA buffer B

VBase2			EQU 		$50F02000 				; VIA2 base address				<v1.4>

SCCRBase  		EQU 		$50F04000     			; SCC base read address
SCCWBase  		EQU 		$50F04000     			; SCC base write address
sccWrite  		EQU 		SCCWBase-SCCRBase     	; general offset for write from read

NewSCSIBase   	EQU 		$50F10000     			; rev8 base addr SCSI interface
NewSCSIDMA		EQU 		$50F12000     			; rev8 base addr SCSI DMA (corrected)
NewSCSIHsk		EQU 		$50F06000     			; rev8 base addr SCSI handshake
MacSCSIBase   	EQU 		$50F10000     			; base addr SCSI interface
MacSCSIDMA		EQU 		$50F12000     			; base addr SCSI DMA
MacSCSIHsk		EQU 		$50F06000     			; base addr SCSI handshake
wrOffs			EQU 		0 						; write addrs are same as read base

SndBase   		EQU 		$50F14000     			; sound chip's base address

; === System Software Information ===
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
bufWorldSize  	EQU 		snd2MemTop    			; total size of the BufPtr world
seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay


  				ENDIF

HardwarePrivate EQU 		1

  				ENDIF								; __INCLUDINGHARDWAREPRIVATEEQU__

; Everything below is empty calories to keep this file compiling
;__________________________________________________________________________________________
;
; Welcome to the New Hardware Equates File.  By following some simple procedures this file
; can keep its youthful appearance for years to come.  This file is a recombination of
; HardwareEqu.a and HardwarePrivateEqu.a.  Everyone should be using this file only.  Please
; change any of your files that use either of the hardware equate files to use only this one.
; HardwareEqu.a will be left as an historical artifact for future generations.
;
; To help you navigate through this file use the "Mark" menu item, and please help to keep
; it current.  When you add a new section, add a handy mark to find it again.  Equates are
; grouped in a semi-logical way in the follwing order:
;
;		Chip Offsets - Register offsets for the 'standard' Mac peripheral chips.
;		Chip Offsets 2 - Register offsets for the 'non-standard' Mac peripheral chips.
;		VIA1 - Register offsets and pin descriptions.
;		VIA2 - Register offsets and pin descriptions.
;		RBV - Register offsets and pin descriptions.
;		VISA - Register offsets and pin descriptions.
;		Memory Controllers - Register definitions and miscellaneous equates.
;		Interrupts - Auto vector names and mask definitions.
;		Miscellaneous - The "Smorgasboard" of equates.
;		Old 16 Bit Equates - Machine dependent equates for Mac, MacPP, HcMac, and Mac16.
;
;
;__________________________________________________________________________________________





;__________________________________________________________________________________________
;
;
; Chip Offsets - Register offsets for "standard" Mac chips.  This includes the following:
;				 IWM, SWIM, SCC, SCSI (with and without DMA), ASC.
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
; IWM Offsets
;---------------------------------------------------

	IF &TYPE('ph0L') = 'UNDEFINED' THEN ; generated for fun
ph0L  			EQU 		0 						; disk address offsets from base
	ENDIF ; generated for fun
	IF &TYPE('ph0H') = 'UNDEFINED' THEN ; generated for fun
ph0H  			EQU 		$200
	ENDIF ; generated for fun
	IF &TYPE('ph1L') = 'UNDEFINED' THEN ; generated for fun
ph1L  			EQU 		$400
	ENDIF ; generated for fun
	IF &TYPE('ph1H') = 'UNDEFINED' THEN ; generated for fun
ph1H  			EQU 		$600
	ENDIF ; generated for fun
	IF &TYPE('ph2L') = 'UNDEFINED' THEN ; generated for fun
ph2L  			EQU 		$800
	ENDIF ; generated for fun
	IF &TYPE('ph2H') = 'UNDEFINED' THEN ; generated for fun
ph2H  			EQU 		$A00
	ENDIF ; generated for fun
	IF &TYPE('ph3L') = 'UNDEFINED' THEN ; generated for fun
ph3L  			EQU 		$C00
	ENDIF ; generated for fun
	IF &TYPE('ph3H') = 'UNDEFINED' THEN ; generated for fun
ph3H  			EQU 		$E00
	ENDIF ; generated for fun
	IF &TYPE('mtrOff') = 'UNDEFINED' THEN ; generated for fun
mtrOff			EQU 		$1000
	ENDIF ; generated for fun
	IF &TYPE('mtrOn') = 'UNDEFINED' THEN ; generated for fun
mtrOn 			EQU 		$1200
	ENDIF ; generated for fun
	IF &TYPE('intDrive') = 'UNDEFINED' THEN ; generated for fun
intDrive  		EQU 		$1400 					; enable internal drive address
	ENDIF ; generated for fun
	IF &TYPE('extDrive') = 'UNDEFINED' THEN ; generated for fun
extDrive  		EQU 		$1600 					; enable external drive address
	ENDIF ; generated for fun
	IF &TYPE('q6L') = 'UNDEFINED' THEN ; generated for fun
q6L   			EQU 		$1800
	ENDIF ; generated for fun
	IF &TYPE('q6H') = 'UNDEFINED' THEN ; generated for fun
q6H   			EQU 		$1A00
	ENDIF ; generated for fun
	IF &TYPE('q7L') = 'UNDEFINED' THEN ; generated for fun
q7L   			EQU 		$1C00
	ENDIF ; generated for fun
	IF &TYPE('q7H') = 'UNDEFINED' THEN ; generated for fun
q7H   			EQU 		$1E00
	ENDIF ; generated for fun

	IF &TYPE('IWMInitMode') = 'UNDEFINED' THEN ; generated for fun
IWMInitMode		equ			$17						; initial IWM mode setting				<3.5>
	ENDIF ; generated for fun

;---------------------------------------------------
;  SWIM offsets
;---------------------------------------------------

	IF &TYPE('wData') = 'UNDEFINED' THEN ; generated for fun
wData 			EQU 		$0000 					;Write a data byte
	ENDIF ; generated for fun
	IF &TYPE('wMark') = 'UNDEFINED' THEN ; generated for fun
wMark 			EQU 		$0200 					;Write a mark byte
	ENDIF ; generated for fun
	IF &TYPE('wCRC') = 'UNDEFINED' THEN ; generated for fun
wCRC  			EQU 		$0400 					;Write a 2-byte CRC (1 access does both)
	ENDIF ; generated for fun
	IF &TYPE('wIWMConfig') = 'UNDEFINED' THEN ; generated for fun
wIWMConfig		EQU 		wCRC  					;Set IWM configuration
	ENDIF ; generated for fun
	IF &TYPE('wParams') = 'UNDEFINED' THEN ; generated for fun
wParams   		EQU 		$0600 					;Set the 16 parameter registers
	ENDIF ; generated for fun
	IF &TYPE('wPhase') = 'UNDEFINED' THEN ; generated for fun
wPhase			EQU 		$0800 					;Set phase lines states and directions
	ENDIF ; generated for fun
	IF &TYPE('wSetup') = 'UNDEFINED' THEN ; generated for fun
wSetup			EQU 		$0A00 					;Set the current configuration
	ENDIF ; generated for fun
	IF &TYPE('wZeroes') = 'UNDEFINED' THEN ; generated for fun
wZeroes   		EQU 		$0C00 					;Mode reg: 1's clr bits, 0's=don't care
	ENDIF ; generated for fun
	IF &TYPE('wOnes') = 'UNDEFINED' THEN ; generated for fun
wOnes 			EQU 		$0E00 					;Mode reg: 1's set bits, 0's=don't care
	ENDIF ; generated for fun
	IF &TYPE('rData') = 'UNDEFINED' THEN ; generated for fun
rData 			EQU 		$1000 					;Read a data byte
	ENDIF ; generated for fun
	IF &TYPE('rCorrection') = 'UNDEFINED' THEN ; generated for fun
rCorrection   	EQU 		rData 					;Read the correction factor
	ENDIF ; generated for fun
	IF &TYPE('rMark') = 'UNDEFINED' THEN ; generated for fun
rMark 			EQU 		$1200 					;Read a mark byte
	ENDIF ; generated for fun
	IF &TYPE('rError') = 'UNDEFINED' THEN ; generated for fun
rError			EQU 		$1400 					;Error register
	ENDIF ; generated for fun
	IF &TYPE('rParams') = 'UNDEFINED' THEN ; generated for fun
rParams   		EQU 		$1600 					;Parameters (16 bytes deep at this addr)
	ENDIF ; generated for fun
	IF &TYPE('rPhase') = 'UNDEFINED' THEN ; generated for fun
rPhase			EQU 		$1800 					;Phase lines states and directions
	ENDIF ; generated for fun
	IF &TYPE('rSetup') = 'UNDEFINED' THEN ; generated for fun
rSetup			EQU 		$1A00 					;Read the current configuration
	ENDIF ; generated for fun
	IF &TYPE('rStatus') = 'UNDEFINED' THEN ; generated for fun
rStatus   		EQU 		$1C00 					;Status (returns current mode reg value)
	ENDIF ; generated for fun
	IF &TYPE('rHandshake') = 'UNDEFINED' THEN ; generated for fun
rHandshake		EQU 		$1E00 					;Handshake register
	ENDIF ; generated for fun


;---------------------------------------------------
; 8530 SCC Offsets
;---------------------------------------------------

	IF &TYPE('aData') = 'UNDEFINED' THEN ; generated for fun
aData 			EQU 		6 						; offset for A channel data
	ENDIF ; generated for fun
	IF &TYPE('aCtl') = 'UNDEFINED' THEN ; generated for fun
aCtl  			EQU 		2 						; offset for A channel control
	ENDIF ; generated for fun
	IF &TYPE('bData') = 'UNDEFINED' THEN ; generated for fun
bData 			EQU 		4 						; offset for B channel data
	ENDIF ; generated for fun
	IF &TYPE('bCtl') = 'UNDEFINED' THEN ; generated for fun
bCtl  			EQU 		0 						; offset for B channel control
	ENDIF ; generated for fun
	IF &TYPE('sccData') = 'UNDEFINED' THEN ; generated for fun
sccData   		EQU 		4 						; general offset for data from control
	ENDIF ; generated for fun
	IF &TYPE('rxBF') = 'UNDEFINED' THEN ; generated for fun
rxBF  			EQU 		0 						; SCC receive buffer full
	ENDIF ; generated for fun
	IF &TYPE('txBE') = 'UNDEFINED' THEN ; generated for fun
txBE  			EQU 		2 						; SCC transmit buffer empty
	ENDIF ; generated for fun
	IF &TYPE('RxCA') = 'UNDEFINED' THEN ; generated for fun
RxCA			EQU			0						; Receive Character Available
	ENDIF ; generated for fun


;---------------------------------------------------
; 53C80 SCSI Register Defs, Offsets
;---------------------------------------------------

	IF &TYPE('sCDR') = 'UNDEFINED' THEN ; generated for fun
sCDR  			EQU 		$00   					; Current SCSI Read Data
	ENDIF ; generated for fun
	IF &TYPE('sODR') = 'UNDEFINED' THEN ; generated for fun
sODR  			EQU 		$00   					; Output data register
	ENDIF ; generated for fun
	IF &TYPE('sICR') = 'UNDEFINED' THEN ; generated for fun
sICR  			EQU 		$10   					; Initiator Command Register - READ/WRITE
	ENDIF ; generated for fun
	IF &TYPE('iRST') = 'UNDEFINED' THEN ; generated for fun
iRST  			EQU 		$80   					; *RST asserted
	ENDIF ; generated for fun
	IF &TYPE('iAIP') = 'UNDEFINED' THEN ; generated for fun
iAIP  			EQU 		$40   					; arbitration in progress (read)
	ENDIF ; generated for fun
	IF &TYPE('bAIP') = 'UNDEFINED' THEN ; generated for fun
bAIP  			EQU 		6 						; bit test for arbitration in progress
	ENDIF ; generated for fun
	IF &TYPE('aTMD') = 'UNDEFINED' THEN ; generated for fun
aTMD  			EQU 		$40   					; assert Test Mode (write)
	ENDIF ; generated for fun
	IF &TYPE('iLA') = 'UNDEFINED' THEN ; generated for fun
iLA   			EQU 		$20   					; Lost arbitration (read)
	ENDIF ; generated for fun
	IF &TYPE('bLA') = 'UNDEFINED' THEN ; generated for fun
bLA   			EQU 		5 						; bit test for Lost Arbitration
	ENDIF ; generated for fun
	IF &TYPE('aDIFF') = 'UNDEFINED' THEN ; generated for fun
aDIFF 			EQU 		$20   					; assert Differential enable (write)
	ENDIF ; generated for fun
	IF &TYPE('iACK') = 'UNDEFINED' THEN ; generated for fun
iACK  			EQU 		$10   					; *ACK is asserted
	ENDIF ; generated for fun
	IF &TYPE('iBSY') = 'UNDEFINED' THEN ; generated for fun
iBSY  			EQU 		$08   					; *BSY is asserted
	ENDIF ; generated for fun
	IF &TYPE('iSEL') = 'UNDEFINED' THEN ; generated for fun
iSEL  			EQU 		$04   					; *SEL is asserted
	ENDIF ; generated for fun
	IF &TYPE('iATN') = 'UNDEFINED' THEN ; generated for fun
iATN  			EQU 		$02   					; *ATN is asserted
	ENDIF ; generated for fun
	IF &TYPE('iDB') = 'UNDEFINED' THEN ; generated for fun
iDB   			EQU 		$01   					; Data bus is asserted
	ENDIF ; generated for fun
	IF &TYPE('sMR') = 'UNDEFINED' THEN ; generated for fun
sMR   			EQU 		$20   					; Mode Register - READ/WRITE
	ENDIF ; generated for fun
	IF &TYPE('iBDMA') = 'UNDEFINED' THEN ; generated for fun
iBDMA 			EQU 		$80   					; Block Mode DMA
	ENDIF ; generated for fun
	IF &TYPE('iTGT') = 'UNDEFINED' THEN ; generated for fun
iTGT  			EQU 		$40   					; Target Mode
	ENDIF ; generated for fun
	IF &TYPE('iPTY') = 'UNDEFINED' THEN ; generated for fun
iPTY  			EQU 		$20   					; Enable Parity Checking
	ENDIF ; generated for fun
	IF &TYPE('iIPTY') = 'UNDEFINED' THEN ; generated for fun
iIPTY 			EQU 		$10   					; Enable Parity interrupt
	ENDIF ; generated for fun
	IF &TYPE('iIEOP') = 'UNDEFINED' THEN ; generated for fun
iIEOP 			EQU 		$08   					; Enable EOP interrupt
	ENDIF ; generated for fun
	IF &TYPE('iMBSY') = 'UNDEFINED' THEN ; generated for fun
iMBSY 			EQU 		$04   					; Monitor BSY
	ENDIF ; generated for fun
	IF &TYPE('iDMA') = 'UNDEFINED' THEN ; generated for fun
iDMA  			EQU 		$02   					; DMA Mode
	ENDIF ; generated for fun
	IF &TYPE('iARB') = 'UNDEFINED' THEN ; generated for fun
iARB  			EQU 		$01   					; Arbitration
	ENDIF ; generated for fun
	IF &TYPE('sTCR') = 'UNDEFINED' THEN ; generated for fun
sTCR  			EQU 		$30   					; Target Command Register - READ/WRITE
	ENDIF ; generated for fun
	IF &TYPE('iREQ') = 'UNDEFINED' THEN ; generated for fun
iREQ  			EQU 		$08   					; Assert *REQ
	ENDIF ; generated for fun
	IF &TYPE('iMSG') = 'UNDEFINED' THEN ; generated for fun
iMSG  			EQU 		$04   					; Assert *MSG
	ENDIF ; generated for fun
	IF &TYPE('iCD') = 'UNDEFINED' THEN ; generated for fun
iCD   			EQU 		$02   					; Assert C/*D
	ENDIF ; generated for fun
	IF &TYPE('iIO') = 'UNDEFINED' THEN ; generated for fun
iIO   			EQU 		$01   					; Assert I/*O
	ENDIF ; generated for fun
	IF &TYPE('sCSR') = 'UNDEFINED' THEN ; generated for fun
sCSR  			EQU 		$40   					; Current SCSI Bus Status (READ)
	ENDIF ; generated for fun
	IF &TYPE('aRST') = 'UNDEFINED' THEN ; generated for fun
aRST  			EQU 		$80   					; *RST
	ENDIF ; generated for fun
	IF &TYPE('aBSY') = 'UNDEFINED' THEN ; generated for fun
aBSY  			EQU 		$40   					; *BSY
	ENDIF ; generated for fun
	IF &TYPE('bBSY') = 'UNDEFINED' THEN ; generated for fun
bBSY  			EQU 		6 						; bit test for *BSY
	ENDIF ; generated for fun
	IF &TYPE('aREQ') = 'UNDEFINED' THEN ; generated for fun
aREQ  			EQU 		$20   					; *REQ
	ENDIF ; generated for fun
	IF &TYPE('bREQ') = 'UNDEFINED' THEN ; generated for fun
bREQ  			EQU 		5 						; bit test for *REQ
	ENDIF ; generated for fun
	IF &TYPE('aMSG') = 'UNDEFINED' THEN ; generated for fun
aMSG  			EQU 		$10   					; *MSG
	ENDIF ; generated for fun
	IF &TYPE('bMSG') = 'UNDEFINED' THEN ; generated for fun
bMSG  			EQU 		4 						; bit test for *MSG
	ENDIF ; generated for fun
	IF &TYPE('aCD') = 'UNDEFINED' THEN ; generated for fun
aCD   			EQU 		$08   					; C/*D
	ENDIF ; generated for fun
	IF &TYPE('bCD') = 'UNDEFINED' THEN ; generated for fun
bCD   			EQU 		3 						; bit test for C/*D
	ENDIF ; generated for fun
	IF &TYPE('aIO') = 'UNDEFINED' THEN ; generated for fun
aIO   			EQU 		$04   					; I/*O
	ENDIF ; generated for fun
	IF &TYPE('bIO') = 'UNDEFINED' THEN ; generated for fun
bIO   			EQU 		2 						; bit test for I/*O
	ENDIF ; generated for fun
	IF &TYPE('aSEL') = 'UNDEFINED' THEN ; generated for fun
aSEL  			EQU 		$02   					; *SEL
	ENDIF ; generated for fun
	IF &TYPE('bSEL') = 'UNDEFINED' THEN ; generated for fun
bSEL  			EQU 		1 						; bit test for *SEL
	ENDIF ; generated for fun
	IF &TYPE('aDBP') = 'UNDEFINED' THEN ; generated for fun
aDBP  			EQU 		$01   					; *DBP
	ENDIF ; generated for fun
	IF &TYPE('sSER') = 'UNDEFINED' THEN ; generated for fun
sSER  			EQU 		$40   					; Select Enable Register (WRITE)
	ENDIF ; generated for fun
	IF &TYPE('sBSR') = 'UNDEFINED' THEN ; generated for fun
sBSR  			EQU 		$50   					; Bus & Status Register (READ)
	ENDIF ; generated for fun
	IF &TYPE('iEDMA') = 'UNDEFINED' THEN ; generated for fun
iEDMA 			EQU 		$80   					; End of DMA
	ENDIF ; generated for fun
	IF &TYPE('bEDMA') = 'UNDEFINED' THEN ; generated for fun
bEDMA 			EQU 		7 						; bit test for end of DMA
	ENDIF ; generated for fun
	IF &TYPE('iDMAR') = 'UNDEFINED' THEN ; generated for fun
iDMAR 			EQU 		$40   					; DMA Request
	ENDIF ; generated for fun
	IF &TYPE('bDMAR') = 'UNDEFINED' THEN ; generated for fun
bDMAR 			EQU 		6 						; bit test for DMA Req
	ENDIF ; generated for fun
	IF &TYPE('iPERR') = 'UNDEFINED' THEN ; generated for fun
iPERR 			EQU 		$20   					; Parity Error
	ENDIF ; generated for fun
	IF &TYPE('iIREQ') = 'UNDEFINED' THEN ; generated for fun
iIREQ 			EQU 		$10   					; Interrupt Request
	ENDIF ; generated for fun
	IF &TYPE('bIREQ') = 'UNDEFINED' THEN ; generated for fun
bIREQ 			EQU 		4 						; bit test for interrupt
	ENDIF ; generated for fun
	IF &TYPE('iPM') = 'UNDEFINED' THEN ; generated for fun
iPM   			EQU 		$08   					; Phase Match
	ENDIF ; generated for fun
	IF &TYPE('bPM') = 'UNDEFINED' THEN ; generated for fun
bPM   			EQU 		3 						; bit test for Phase Match
	ENDIF ; generated for fun
	IF &TYPE('iBERR') = 'UNDEFINED' THEN ; generated for fun
iBERR 			EQU 		$04   					; Bus Error
	ENDIF ; generated for fun
	IF &TYPE('ATN') = 'UNDEFINED' THEN ; generated for fun
ATN   			EQU 		$02   					; *ATN
	ENDIF ; generated for fun
	IF &TYPE('ACK') = 'UNDEFINED' THEN ; generated for fun
ACK   			EQU 		$01   					; *ACK
	ENDIF ; generated for fun
	IF &TYPE('bACK') = 'UNDEFINED' THEN ; generated for fun
bACK  			EQU 		0 						; bit test for ACK
	ENDIF ; generated for fun
	IF &TYPE('sDMAtx') = 'UNDEFINED' THEN ; generated for fun
sDMAtx			EQU 		$50   					; DMA Transmit Start (WRITE)
	ENDIF ; generated for fun
	IF &TYPE('sIDR') = 'UNDEFINED' THEN ; generated for fun
sIDR  			EQU 		$60   					; Data input register (READ)
	ENDIF ; generated for fun
	IF &TYPE('sTDMArx') = 'UNDEFINED' THEN ; generated for fun
sTDMArx   		EQU 		$60   					; Start Target DMA receive (WRITE)
	ENDIF ; generated for fun
	IF &TYPE('sRESET') = 'UNDEFINED' THEN ; generated for fun
sRESET			EQU 		$70   					; Reset Parity/Interrupt (READ)
	ENDIF ; generated for fun
	IF &TYPE('sIDMArx') = 'UNDEFINED' THEN ; generated for fun
sIDMArx   		EQU 		$70   					; Start Initiator DMA receive (WRITE)
	ENDIF ; generated for fun


;---------------------------------------------------
;  SCSI DMA chip register offsets
;---------------------------------------------------

;  Note that the 53C80 registers are provided on the SCSI DMA chip.  The registers
;  described here are in addition to the 53C80 registers.

	IF &TYPE('sDCTRL') = 'UNDEFINED' THEN ; generated for fun
sDCTRL			EQU			$80
	ENDIF ; generated for fun
	IF &TYPE('bDMAEN') = 'UNDEFINED' THEN ; generated for fun
bDMAEN			EQU			0						; bit to enable SCSI DMA
	ENDIF ; generated for fun
	IF &TYPE('iDMAEN') = 'UNDEFINED' THEN ; generated for fun
iDMAEN			EQU			$0001					; mask to enable SCSI DMA
	ENDIF ; generated for fun
	IF &TYPE('bINTREN') = 'UNDEFINED' THEN ; generated for fun
bINTREN			EQU			1						; bit to enable SCSI DMA interrupts
	ENDIF ; generated for fun
	IF &TYPE('iINTREN') = 'UNDEFINED' THEN ; generated for fun
iINTREN			EQU			$0002					; mask to enable SCSI DMA interrupts
	ENDIF ; generated for fun
	IF &TYPE('bTIMEEN') = 'UNDEFINED' THEN ; generated for fun
bTIMEEN			EQU			2						; bit to enable watchdog timer intr's
	ENDIF ; generated for fun
	IF &TYPE('iTIMEEN') = 'UNDEFINED' THEN ; generated for fun
iTIMEEN			EQU			$0004					; mask to enable watchdog timer intr's
	ENDIF ; generated for fun
	IF &TYPE('bHSKEN') = 'UNDEFINED' THEN ; generated for fun
bHSKEN			EQU			3						; bit to enable hardware-handshaking (write)
	ENDIF ; generated for fun
	IF &TYPE('iHSKEN') = 'UNDEFINED' THEN ; generated for fun
iHSKEN			EQU			$0008					; mask to enable hardware-handshaking (write)
	ENDIF ; generated for fun
	IF &TYPE('bRESET') = 'UNDEFINED' THEN ; generated for fun
bRESET			EQU			4						; bit to reset SCSI DMA chip (write)
	ENDIF ; generated for fun
	IF &TYPE('iRESET') = 'UNDEFINED' THEN ; generated for fun
iRESET			EQU			$0010					; mask to reset SCSI DMA chip (write)
	ENDIF ; generated for fun
	IF &TYPE('bFIFO') = 'UNDEFINED' THEN ; generated for fun
bFIFO			EQU			4						; bit indicating bytes left in FIFO (read)
	ENDIF ; generated for fun
	IF &TYPE('iFIFO') = 'UNDEFINED' THEN ; generated for fun
iFIFO			EQU			$0010					; mask indicating bytes left in FIFO (read)
	ENDIF ; generated for fun
	IF &TYPE('bTEST') = 'UNDEFINED' THEN ; generated for fun
bTEST			EQU			5						; bit to enable SCSI Test Mode (write)
	ENDIF ; generated for fun
	IF &TYPE('iTEST') = 'UNDEFINED' THEN ; generated for fun
iTEST			EQU			$0020					; mask to enable SCSI Test Mode (write)
	ENDIF ; generated for fun
	IF &TYPE('bSCSIP') = 'UNDEFINED' THEN ; generated for fun
bSCSIP			EQU			6						; bit indicating SCSI intr pending (read)
	ENDIF ; generated for fun
	IF &TYPE('iSCSIP') = 'UNDEFINED' THEN ; generated for fun
iSCSIP			EQU			$0040					; mask indicating SCSI intr pending (read)
	ENDIF ; generated for fun
	IF &TYPE('bTIMEP') = 'UNDEFINED' THEN ; generated for fun
bTIMEP			EQU			7						; bit indicating timer intr pending (read)
	ENDIF ; generated for fun
	IF &TYPE('iTIMEP') = 'UNDEFINED' THEN ; generated for fun
iTIMEP			EQU			$0080					; mask indicating timer intr pending (read)
	ENDIF ; generated for fun
	IF &TYPE('bDMABERR') = 'UNDEFINED' THEN ; generated for fun
bDMABERR		EQU			8						; bit indicating DMA bus error (read)
	ENDIF ; generated for fun
	IF &TYPE('iDMABERR') = 'UNDEFINED' THEN ; generated for fun
iDMABERR		EQU			$0100					; mask indicating DMA bus error (read)
	ENDIF ; generated for fun
	IF &TYPE('iARBID') = 'UNDEFINED' THEN ; generated for fun
iARBID			EQU			$0E00					; mask to get target ID for arbitration
	ENDIF ; generated for fun
	IF &TYPE('bARBIDEN') = 'UNDEFINED' THEN ; generated for fun
bARBIDEN		EQU			12						; bit to enable hardware arbitration
	ENDIF ; generated for fun
	IF &TYPE('iARBIDEN') = 'UNDEFINED' THEN ; generated for fun
iARBIDEN		EQU			$1000					; mask to enable hardware arbitration
	ENDIF ; generated for fun
	IF &TYPE('bWONARB') = 'UNDEFINED' THEN ; generated for fun
bWONARB			EQU			13						; bit indicating successful arbitration
	ENDIF ; generated for fun
	IF &TYPE('iWONARB') = 'UNDEFINED' THEN ; generated for fun
iWONARB			EQU			$2000					; mask indicating successful arbitration
	ENDIF ; generated for fun
	IF &TYPE('iINFIFO') = 'UNDEFINED' THEN ; generated for fun
iINFIFO			EQU			$C000					; mask to get bytes left in FIFO (read)
	ENDIF ; generated for fun

	IF &TYPE('sDCNT') = 'UNDEFINED' THEN ; generated for fun
sDCNT			EQU			$C0
	ENDIF ; generated for fun

	IF &TYPE('sDADDR') = 'UNDEFINED' THEN ; generated for fun
sDADDR			EQU			$100
	ENDIF ; generated for fun

	IF &TYPE('sDTIME') = 'UNDEFINED' THEN ; generated for fun
sDTIME			EQU			$140
	ENDIF ; generated for fun

	IF &TYPE('sTEST') = 'UNDEFINED' THEN ; generated for fun
sTEST			equ			$180
	ENDIF ; generated for fun

;__________________________________________________________________________________________
;
;
; Chip Offsets - Register offsets for "non standard" Mac chips.  This includes the following:
;				 OSS and IOP.
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
;  OSS (Operating System Support) Chip Address & Offsets
;---------------------------------------------------

	IF &TYPE('OSSMskFirst') = 'UNDEFINED' THEN ; generated for fun
OSSMskFirst		equ			$000					;offset to first interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSlot9') = 'UNDEFINED' THEN ; generated for fun
OSSMskSlot9		equ			OSSMskFirst				;offset to slot 9 interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSlotA') = 'UNDEFINED' THEN ; generated for fun
OSSMskSlotA		equ			$001					;offset to slot A interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSlotB') = 'UNDEFINED' THEN ; generated for fun
OSSMskSlotB		equ			$002					;offset to slot B interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSlotC') = 'UNDEFINED' THEN ; generated for fun
OSSMskSlotC		equ			$003					;offset to slot C interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSlotD') = 'UNDEFINED' THEN ; generated for fun
OSSMskSlotD		equ			$004					;offset to slot D interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSlotE') = 'UNDEFINED' THEN ; generated for fun
OSSMskSlotE		equ			$005					;offset to slot E interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskPSwm') = 'UNDEFINED' THEN ; generated for fun
OSSMskPSwm		equ			$006					;offset to SWIM PIC interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskPScc') = 'UNDEFINED' THEN ; generated for fun
OSSMskPScc		equ			$007					;offset to SCC PIC interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskSnd') = 'UNDEFINED' THEN ; generated for fun
OSSMskSnd		equ			$008					;offset to Sound interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskScsi') = 'UNDEFINED' THEN ; generated for fun
OSSMskScsi		equ			$009					;offset to SCSI interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMsk60Hz') = 'UNDEFINED' THEN ; generated for fun
OSSMsk60Hz		equ			$00A					;offset to 60 Hz interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskVia1') = 'UNDEFINED' THEN ; generated for fun
OSSMskVia1		equ			$00B					;offset to VIA1 interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskRTC') = 'UNDEFINED' THEN ; generated for fun
OSSMskRTC		equ			$00C					;offset to RTC interrupt mask register
	ENDIF ; generated for fun
	IF &TYPE('OSSMskADB') = 'UNDEFINED' THEN ; generated for fun
OSSMskADB		equ			$00D					;offset to ADB interrupt mask register (not used)		<5.1>
	ENDIF ; generated for fun
	IF &TYPE('OSSMskRPU') = 'UNDEFINED' THEN ; generated for fun
OSSMskRPU		equ			$00E					;offset to RPU interrupt mask register					<4.8>
	ENDIF ; generated for fun
	IF &TYPE('OSSMskLast') = 'UNDEFINED' THEN ; generated for fun
OSSMskLast		equ			OSSMskRPU				;offset to last interrupt mask register
	ENDIF ; generated for fun

	IF &TYPE('rpuReset') = 'UNDEFINED' THEN ; generated for fun
rpuReset		EQU			$010					; RPU write offset to reset serial ptr					<4.9>
	ENDIF ; generated for fun

	IF &TYPE('OSSIntStat') = 'UNDEFINED' THEN ; generated for fun
OSSIntStat		equ			$202					;offset to interrupt status register. Bits are:			<3.7>
	ENDIF ; generated for fun
													;  15:  interrupt 15 (spare) pending
													;  14:  interrupt 14 (RPU) pending						<4.8>
													;  13:  interrupt 13 (spare) pending					<5.1>
													;  12:  interrupt 12 (RTC) pending
													;  11:  interrupt 11 (VIA1) pending
													;  10:  interrupt 10 (60 Hz) pending
													;   9:  interrupt 9 (SCSI) pending
													;   8:  interrupt 8 (sound) pending
													;   7:  interrupt 7 (SCC PIC) pending
													;   6:  interrupt 6 (SWIM PIC) pending
													;   5:  interrupt 5 (slot E) pending
													;   4:  interrupt 4 (slot D) pending
													;   3:  interrupt 3 (slot C) pending
													;   2:  interrupt 2 (slot B) pending
													;   1:  interrupt 1 (slot A) pending
													;   0:  interrupt 0 (slot 9) pending

;••••• NOTE: In the new OSS, the interrupt status register is a long word starting at $200.			<3.7>
;•••••		 Since only the low-order word is currently used, making a single change here			<3.7>
;•••••		 has less impact on the ROM sources.  When we permanently switch over to the			<3.7>
;•••••		 new OSS hardware, then it may make sense to fix this equate and change all its			<3.7>
;•••••		 uses from MOVE.Ws to MOVE.Ls.															<3.7>

	IF &TYPE('OSSRomCntl') = 'UNDEFINED' THEN ; generated for fun
OSSRomCntl		equ			$204					;offset to ROM control register.  Bits are:
	ENDIF ; generated for fun
													;  <to be specified - see Steve Ray's spec>				<2.0>

	IF &TYPE('OSSPwrOff') = 'UNDEFINED' THEN ; generated for fun
OSSPwrOff		equ			OSSRomCntl				;power off is now a bit in the ROM control register		<5.1>
	ENDIF ; generated for fun
	IF &TYPE('OSSPwrOffBit') = 'UNDEFINED' THEN ; generated for fun
OSSPwrOffBit	equ			7						;    7:  write a 1 here to power off the machine		<2.1><3.7>
	ENDIF ; generated for fun

	IF &TYPE('OSSCntrCntl') = 'UNDEFINED' THEN ; generated for fun
OSSCntrCntl		equ			$205					;offset to counter control register.  Bits are
	ENDIF ; generated for fun
													;  7-2:  unused
													;    1:  test control.  A 1 causes each 4 bit
													;        counter segment to count in parallel
													;    0:  counter hold.  A 1 holds current value
													;        so all 64 bits can be read.  Hold doesn't
													;        affect counting, though!

	IF &TYPE('OSSInpStat') = 'UNDEFINED' THEN ; generated for fun
OSSInpStat		equ			$206					;offset to input status register.  Bits are
	ENDIF ; generated for fun
													;  7-2:  not used, read as zero
													;    1:  SCC write request. Not used if PIC present
													;    0:  mini-phono device plugged in flag.  A 1
													;        means a device IS plugged in.

	IF &TYPE('OSS60HzAck') = 'UNDEFINED' THEN ; generated for fun
OSS60HzAck		equ			$207					;offset to 'Clear 60 Hz interrupt flag' register.  Both	<3.7>
	ENDIF ; generated for fun
													; writes and reads clear it, so might as well write it.

	IF &TYPE('OSSCounter') = 'UNDEFINED' THEN ; generated for fun
OSSCounter		equ			$208					;offset to 64 bit counter register.  Low order 8
	ENDIF ; generated for fun
													;.bits are always read as zero (maybe not in future...)

;  Bit numbers in OSS interrupt status register

	IF &TYPE('OSSIntIOPSWIM') = 'UNDEFINED' THEN ; generated for fun
OSSIntIOPSWIM	equ			6						;bit # of SWIM IOP in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntIOPSCC') = 'UNDEFINED' THEN ; generated for fun
OSSIntIOPSCC	equ			7						;bit # of SCC IOP in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntSound') = 'UNDEFINED' THEN ; generated for fun
OSSIntSound		equ			8						;bit # of ASC in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntSCSI') = 'UNDEFINED' THEN ; generated for fun
OSSIntSCSI		equ			9						;bit # of SCSI in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntVBL60Hz') = 'UNDEFINED' THEN ; generated for fun
OSSIntVBL60Hz	equ			10						;bit # of 60Hz VBL in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntVia1') = 'UNDEFINED' THEN ; generated for fun
OSSIntVia1		equ			11						;bit # of VIA 1 in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntRTC') = 'UNDEFINED' THEN ; generated for fun
OSSIntRTC		equ			12						;bit # of RTC in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntADB') = 'UNDEFINED' THEN ; generated for fun
OSSIntADB		equ			13						;bit # of ADB in interrupt status register
	ENDIF ; generated for fun
	IF &TYPE('OSSIntRPU') = 'UNDEFINED' THEN ; generated for fun
OSSIntRPU		equ			14						;bit # of RPU in interrupt status register		<4.8>
	ENDIF ; generated for fun
	IF &TYPE('OSSIntLast') = 'UNDEFINED' THEN ; generated for fun
OSSIntLast		equ			14						;bit # of last interrupt source
	ENDIF ; generated for fun

	IF &TYPE('OSSRomInit') = 'UNDEFINED' THEN ; generated for fun
OSSRomInit		EQU			$D						; initial value for ROM control register<3.5>
	ENDIF ; generated for fun


;---------------------------------------------------
;  IOP (Input Output Processor) Chip Offsets and bit definitions
;---------------------------------------------------

	IF &TYPE('iopRamAddrH') = 'UNDEFINED' THEN ; generated for fun
iopRamAddrH		equ			$0000-$20				; high byte of shared RAM address register
	ENDIF ; generated for fun
	IF &TYPE('iopRamAddrL') = 'UNDEFINED' THEN ; generated for fun
iopRamAddrL		equ			$0002-$20				; low byte of shared RAM address register
	ENDIF ; generated for fun
	IF &TYPE('iopRamAddr') = 'UNDEFINED' THEN ; generated for fun
iopRamAddr		equ			iopRamAddrL-1			; WORD access to shared RAM address register
	ENDIF ; generated for fun

	IF &TYPE('iopRamData') = 'UNDEFINED' THEN ; generated for fun
iopRamData		equ			$0008-$20				; shared RAM data register (byte, word, or long)
	ENDIF ; generated for fun
	IF &TYPE('iopStatCtl') = 'UNDEFINED' THEN ; generated for fun
iopStatCtl		equ			$0004-$20				; IOP Status and Control register
	ENDIF ; generated for fun

;	bit numbers within the iopStatCtl register
	IF &TYPE('iopInBypassMode') = 'UNDEFINED' THEN ; generated for fun
iopInBypassMode	equ			0						; IOP is in BYPASS mode
	ENDIF ; generated for fun
	IF &TYPE('iopIncEnable') = 'UNDEFINED' THEN ; generated for fun
iopIncEnable	equ			1						; enable addr pointer increment
	ENDIF ; generated for fun
	IF &TYPE('iopRun') = 'UNDEFINED' THEN ; generated for fun
iopRun			equ			2						; 0 -> reset IOP, 1 -> run IOP
	ENDIF ; generated for fun
	IF &TYPE('iopGenInterrupt') = 'UNDEFINED' THEN ; generated for fun
iopGenInterrupt	equ			3						; interrupt the IOP
	ENDIF ; generated for fun
	IF &TYPE('iopInt0Active') = 'UNDEFINED' THEN ; generated for fun
iopInt0Active	equ			4						; interrupt 0 active
	ENDIF ; generated for fun
	IF &TYPE('iopInt1Active') = 'UNDEFINED' THEN ; generated for fun
iopInt1Active	equ			5						; interrupt 1 active
	ENDIF ; generated for fun
	IF &TYPE('iopBypassIntReq') = 'UNDEFINED' THEN ; generated for fun
iopBypassIntReq	equ			6						; peripheral chip interrupt request in bypass mode
	ENDIF ; generated for fun
	IF &TYPE('iopSCCWrReq') = 'UNDEFINED' THEN ; generated for fun
iopSCCWrReq		equ			7						; 0 -> SCC REQ active, 1 -> inactive
	ENDIF ; generated for fun

;	commands bytes to write to the iopStatCtl register
	IF &TYPE('setIopIncEnable') = 'UNDEFINED' THEN ; generated for fun
setIopIncEnable	equ			(1<<iopIncEnable)|\		; set increment enable
							(1<<iopRun)				; leave iop running
	ENDIF ; generated for fun

	IF &TYPE('clrIopIncEnable') = 'UNDEFINED' THEN ; generated for fun
clrIopIncEnable	equ			(0<<iopIncEnable)|\		; reset increment enable
							(1<<iopRun)				; leave iop running
	ENDIF ; generated for fun

	IF &TYPE('clrIopInt0') = 'UNDEFINED' THEN ; generated for fun
clrIopInt0		equ			(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled
	ENDIF ; generated for fun

	IF &TYPE('clrIopInt1') = 'UNDEFINED' THEN ; generated for fun
clrIopInt1		equ			(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled
	ENDIF ; generated for fun

	IF &TYPE('setIopGenInt') = 'UNDEFINED' THEN ; generated for fun
setIopGenInt	equ			(1<<iopGenInterrupt)|\	; interrupt the IOP
							(1<<iopRun)|\			; leave iop running
							(1<<iopIncEnable)		; leave increment enabled
	ENDIF ; generated for fun

	IF &TYPE('resetIopRun') = 'UNDEFINED' THEN ; generated for fun
resetIopRun		equ			(0<<iopRun)|\			; stop iop from running
							(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopIncEnable)		; set increment enable
	ENDIF ; generated for fun

	IF &TYPE('setIopRun') = 'UNDEFINED' THEN ; generated for fun
setIopRun		equ			(1<<iopRun)|\			; start iop running
							(1<<iopInt0Active)|\	; clear interrupt 0 active
							(1<<iopInt1Active)|\	; clear interrupt 1 active
							(1<<iopIncEnable)		; set increment enable
	ENDIF ; generated for fun



;__________________________________________________________________________________________
;
;
; VIA1 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
; are grouped together.  New definitions for VIA1 pins are added such that the grouping is
; maintained.
;
;
;__________________________________________________________________________________________

;---------------------------------------------------
; 6522 VIA1 (and VIA2) register offsets
;---------------------------------------------------

	IF &TYPE('vBufB') = 'UNDEFINED' THEN ; generated for fun
vBufB 			EQU 		0 						; BUFFER B
	ENDIF ; generated for fun
	IF &TYPE('vBufAH') = 'UNDEFINED' THEN ; generated for fun
vBufAH			EQU 		$200  					; buffer a (with handshake) [ Dont use! ]
	ENDIF ; generated for fun
	IF &TYPE('vDIRB') = 'UNDEFINED' THEN ; generated for fun
vDIRB 			EQU 		$400  					; DIRECTION B
	ENDIF ; generated for fun
	IF &TYPE('vDIRA') = 'UNDEFINED' THEN ; generated for fun
vDIRA 			EQU 		$600  					; DIRECTION A
	ENDIF ; generated for fun
	IF &TYPE('vT1C') = 'UNDEFINED' THEN ; generated for fun
vT1C  			EQU 		$800  					; TIMER 1 COUNTER (L.O.)
	ENDIF ; generated for fun
	IF &TYPE('vT1CH') = 'UNDEFINED' THEN ; generated for fun
vT1CH 			EQU 		$A00  					; timer 1 counter (high order)
	ENDIF ; generated for fun
	IF &TYPE('vT1L') = 'UNDEFINED' THEN ; generated for fun
vT1L  			EQU 		$C00  					; TIMER 1 LATCH (L.O.)
	ENDIF ; generated for fun
	IF &TYPE('vT1LH') = 'UNDEFINED' THEN ; generated for fun
vT1LH 			EQU 		$E00  					; timer 1 latch (high order)
	ENDIF ; generated for fun
	IF &TYPE('vT2C') = 'UNDEFINED' THEN ; generated for fun
vT2C  			EQU 		$1000 					; TIMER 2 LATCH (L.O.)
	ENDIF ; generated for fun
	IF &TYPE('vT2CH') = 'UNDEFINED' THEN ; generated for fun
vT2CH 			EQU 		$1200 					; timer 2 counter (high order)
	ENDIF ; generated for fun
	IF &TYPE('vSR') = 'UNDEFINED' THEN ; generated for fun
vSR   			EQU 		$1400 					; SHIFT REGISTER
	ENDIF ; generated for fun
	IF &TYPE('vACR') = 'UNDEFINED' THEN ; generated for fun
vACR  			EQU 		$1600 					; AUX. CONTROL REG.
	ENDIF ; generated for fun
	IF &TYPE('vPCR') = 'UNDEFINED' THEN ; generated for fun
vPCR  			EQU 		$1800 					; PERIPH. CONTROL REG.
	ENDIF ; generated for fun
	IF &TYPE('vIFR') = 'UNDEFINED' THEN ; generated for fun
vIFR  			EQU 		$1A00 					; INT. FLAG REG.
	ENDIF ; generated for fun
	IF &TYPE('vIER') = 'UNDEFINED' THEN ; generated for fun
vIER  			EQU 		$1C00 					; INT. ENABLE REG.
	ENDIF ; generated for fun
	IF &TYPE('vBufA') = 'UNDEFINED' THEN ; generated for fun
vBufA 			EQU 		$1E00 					; BUFFER A
	ENDIF ; generated for fun
	IF &TYPE('vBufD') = 'UNDEFINED' THEN ; generated for fun
vBufD 			EQU 		vBufA 					; disk head select is buffer A			<3.5>
	ENDIF ; generated for fun

;---------------------------------------------------
; VIA IFR/IER bits
;---------------------------------------------------

	IF &TYPE('ifCA2') = 'UNDEFINED' THEN ; generated for fun
ifCA2 			EQU 		0 						; CA2 interrupt
	ENDIF ; generated for fun
	IF &TYPE('ifCA1') = 'UNDEFINED' THEN ; generated for fun
ifCA1 			EQU 		1 						; CA1 interrupt
	ENDIF ; generated for fun
	IF &TYPE('ifSR') = 'UNDEFINED' THEN ; generated for fun
ifSR  			EQU 		2 						; SR shift register done
	ENDIF ; generated for fun
	IF &TYPE('ifCB2') = 'UNDEFINED' THEN ; generated for fun
ifCB2 			EQU 		3 						; CB2 interrupt
	ENDIF ; generated for fun
	IF &TYPE('ifCB1') = 'UNDEFINED' THEN ; generated for fun
ifCB1 			EQU 		4 						; CB1 interrupt
	ENDIF ; generated for fun
	IF &TYPE('ifT2') = 'UNDEFINED' THEN ; generated for fun
ifT2  			EQU 		5 						; T2 timer2 interrupt
	ENDIF ; generated for fun
	IF &TYPE('ifT1') = 'UNDEFINED' THEN ; generated for fun
ifT1  			EQU 		6 						; T1 timer1 interrupt
	ENDIF ; generated for fun
	IF &TYPE('ifIRQ') = 'UNDEFINED' THEN ; generated for fun
ifIRQ 			EQU 		7 						; any interrupt
	ENDIF ; generated for fun


;---------------------------------------------------
; VIA1 Port A definitions
;---------------------------------------------------

	IF &TYPE('vSound') = 'UNDEFINED' THEN ; generated for fun
vSound			EQU 		$7    					; sound volume bits (0..2)	(output)
	ENDIF ; generated for fun

	IF &TYPE('vTestJ') = 'UNDEFINED' THEN ; generated for fun
vTestJ			EQU 		0 						; Burn In Test jumper		(input)
	ENDIF ; generated for fun

	IF &TYPE('vCpuId0') = 'UNDEFINED' THEN ; generated for fun
vCpuId0			EQU			1						; CPU Identification bit 0	(input)
	ENDIF ; generated for fun
	IF &TYPE('vCpuId1') = 'UNDEFINED' THEN ; generated for fun
vCpuId1			EQU			2						; CPU Identification bit 1	(input)
	ENDIF ; generated for fun
	IF &TYPE('vSync') = 'UNDEFINED' THEN ; generated for fun
vSync 			EQU 		3 						; Synchronous modem
	ENDIF ; generated for fun
	IF &TYPE('vOverlay') = 'UNDEFINED' THEN ; generated for fun
vOverlay  		EQU 		4 						; overlay bit (overlay when 1)
	ENDIF ; generated for fun
	IF &TYPE('vCpuId2') = 'UNDEFINED' THEN ; generated for fun
vCpuId2			EQU			4						; CPU Identification bit 2
	ENDIF ; generated for fun
	IF &TYPE('vReqAEnable') = 'UNDEFINED' THEN ; generated for fun
vReqAEnable		EQU			4						; enable ReqA into vSCCWrReq (PSC only)		<LW2>
	ENDIF ; generated for fun
	IF &TYPE('vHeadSel') = 'UNDEFINED' THEN ; generated for fun
vHeadSel  		EQU 		5 						; head select line for Sony
	ENDIF ; generated for fun
	IF &TYPE('vCpuId3') = 'UNDEFINED' THEN ; generated for fun
vCpuId3			EQU			6						; CPU Identification bit 3
	ENDIF ; generated for fun
	IF &TYPE('vRev8Bd') = 'UNDEFINED' THEN ; generated for fun
vRev8Bd   		EQU 		6 						; =0 for rev 8 board>
	ENDIF ; generated for fun
	IF &TYPE('vReqBEnable') = 'UNDEFINED' THEN ; generated for fun
vReqBEnable		EQU			6						; enable ReqB into vSCCWrReq (PSC only)		<LW2>
	ENDIF ; generated for fun
	IF &TYPE('vSCCWrReq') = 'UNDEFINED' THEN ; generated for fun
vSCCWrReq 		EQU 		7 						; SCC write/request line
	ENDIF ; generated for fun

;---------------------------------------------------
; VIA1 Port B definitions
;---------------------------------------------------

	IF &TYPE('vEclipseLED') = 'UNDEFINED' THEN ; generated for fun
vEclipseLED		EQU			0						; flashable Eclipse LED (how quaint!)		<23>
	ENDIF ; generated for fun
	IF &TYPE('vRTCData') = 'UNDEFINED' THEN ; generated for fun
vRTCData  		EQU 		0 						; real time clock data
	ENDIF ; generated for fun
	IF &TYPE('vRMP0') = 'UNDEFINED' THEN ; generated for fun
vRMP0			EQU			0						; Reserved for RMP (PSC only)
	ENDIF ; generated for fun
	IF &TYPE('vRTCClk') = 'UNDEFINED' THEN ; generated for fun
vRTCClk   		EQU 		1 						; real time clock clock pulses
	ENDIF ; generated for fun
	IF &TYPE('vRMP1') = 'UNDEFINED' THEN ; generated for fun
vRMP1			EQU			1						; Reserved for RMP (PSC only)
	ENDIF ; generated for fun
	IF &TYPE('vRTCEnb') = 'UNDEFINED' THEN ; generated for fun
vRTCEnb   		EQU 		2 						; clock enable (0 for enable)
	ENDIF ; generated for fun
	IF &TYPE('vRMP2') = 'UNDEFINED' THEN ; generated for fun
vRMP2			EQU			2						; Reserved for RMP (PSC only)
	ENDIF ; generated for fun
	IF &TYPE('vFDBInt') = 'UNDEFINED' THEN ; generated for fun
vFDBInt   		EQU 		3 						; Front Desk bus interrupt
	ENDIF ; generated for fun
	IF &TYPE('vXcvrsesbit') = 'UNDEFINED' THEN ; generated for fun
vXcvrsesbit		EQU			3						; Egret transceiver session bit			<6>
	ENDIF ; generated for fun
	IF &TYPE('vSDMCable') = 'UNDEFINED' THEN ; generated for fun
vSDMCable		EQU			3						; SCSI DiskMode cable sense for Dartanian	<H15>
	ENDIF ; generated for fun
	IF &TYPE('vCudaTREQ') = 'UNDEFINED' THEN ; generated for fun
vCudaTREQ		EQU			3						; Cuda transaction request input		<P2><SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('vSDMDiskID') = 'UNDEFINED' THEN ; generated for fun
vSDMDiskID		EQU			4						; DiskMode HD ID (bits 4-6) for Dartanian	<H15>
	ENDIF ; generated for fun
	IF &TYPE('vFDesk1') = 'UNDEFINED' THEN ; generated for fun
vFDesk1   		EQU 		4 						; Front Desk bus state bit 0
	ENDIF ; generated for fun
	IF &TYPE('vViafullbit') = 'UNDEFINED' THEN ; generated for fun
vViafullbit		EQU			4						; Egret via full bit					<6>
	ENDIF ; generated for fun
	IF &TYPE('vCudaBYTEACK') = 'UNDEFINED' THEN ; generated for fun
vCudaBYTEACK	EQU			4						; Cuda byte acknowledge output			<P2><SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('vFDesk2') = 'UNDEFINED' THEN ; generated for fun
vFDesk2   		EQU 		5 						; Front Desk bus state bit 1
	ENDIF ; generated for fun
	IF &TYPE('vSyssesbit') = 'UNDEFINED' THEN ; generated for fun
vSyssesbit		EQU			5						; Egret system session bit				<6><SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('vCudaTIP') = 'UNDEFINED' THEN ; generated for fun
vCudaTIP		EQU			5						; Cuda interface transaction in progress output <P2>
	ENDIF ; generated for fun
	IF &TYPE('vAUXIntEnb') = 'UNDEFINED' THEN ; generated for fun
vAUXIntEnb 		EQU 		6 						; switch to A/UX interrupt scheme (output)	<23>
	ENDIF ; generated for fun
	IF &TYPE('vPGCEnb') = 'UNDEFINED' THEN ; generated for fun
vPGCEnb			EQU			6						; Parity Generator/Checker enable (0 for enable)
	ENDIF ; generated for fun
	IF &TYPE('vJMPDude6') = 'UNDEFINED' THEN ; generated for fun
vJMPDude6		EQU			6						; Reserved for JMP (PSC only)
	ENDIF ; generated for fun
	IF &TYPE('vPGCErr') = 'UNDEFINED' THEN ; generated for fun
vPGCErr			EQU			7						; Parity Generator/Checker error	(input)
	ENDIF ; generated for fun
	IF &TYPE('vSndEnb') = 'UNDEFINED' THEN ; generated for fun
vSndEnb   		EQU 		7 						; /sound enable (reset when 1)		(output)
	ENDIF ; generated for fun
	IF &TYPE('vSWInt') = 'UNDEFINED' THEN ; generated for fun
vSWInt	  		EQU 		7 						; cause a software interrupt	(output)	<23>
	ENDIF ; generated for fun
	IF &TYPE('vJMPDude7') = 'UNDEFINED' THEN ; generated for fun
vJMPDude7		EQU			7						; Reserved for JMP (PSC only)
	ENDIF ; generated for fun



;__________________________________________________________________________________________
;
;
; VIA2 or Equivalent Pin Definitions and Register Offsets - Multiple names for the same pin
; are grouped together.  New definitions for VIA2 pins are added such that the grouping is
; maintained.
;
;
;__________________________________________________________________________________________

;---------------------------------------------------
; VIA2 Port A definitions
;---------------------------------------------------

	IF &TYPE('v2IRQ1') = 'UNDEFINED' THEN ; generated for fun
v2IRQ1			EQU 		0 						; slot 1 interrupt
	ENDIF ; generated for fun
	IF &TYPE('v2EnetIRQ') = 'UNDEFINED' THEN ; generated for fun
v2EnetIRQ		EQU			0						; on-board ethernet								<8><23>
	ENDIF ; generated for fun
	IF &TYPE('v2IRQ2') = 'UNDEFINED' THEN ; generated for fun
v2IRQ2			EQU 		1 						; slot 2 interrupt
	ENDIF ; generated for fun
	IF &TYPE('v2IRQ3') = 'UNDEFINED' THEN ; generated for fun
v2IRQ3			EQU 		2 						; slot 3 interrupt
	ENDIF ; generated for fun
	IF &TYPE('v2IRQ4') = 'UNDEFINED' THEN ; generated for fun
v2IRQ4			EQU 		3 						; slot 4 interrupt
	ENDIF ; generated for fun
	IF &TYPE('v2IRQ5') = 'UNDEFINED' THEN ; generated for fun
v2IRQ5			EQU 		4 						; slot 5 interrupt
	ENDIF ; generated for fun
	IF &TYPE('v2IRQ6') = 'UNDEFINED' THEN ; generated for fun
v2IRQ6			EQU 		5 						; slot 6 interrupt
	ENDIF ; generated for fun
	IF &TYPE('v2RAM0') = 'UNDEFINED' THEN ; generated for fun
v2RAM0			EQU 		6 						; RAM size bit 0
	ENDIF ; generated for fun
	IF &TYPE('v2LCDIRQ') = 'UNDEFINED' THEN ; generated for fun
v2LCDIRQ		EQU			6						; on-board LCD video
	ENDIF ; generated for fun
	IF &TYPE('v2VideoIRQ') = 'UNDEFINED' THEN ; generated for fun
v2VideoIRQ		EQU			6						; on-board video								<8><23>
	ENDIF ; generated for fun
	IF &TYPE('v2RAM1') = 'UNDEFINED' THEN ; generated for fun
v2RAM1			EQU 		7 						; RAM size bit 1
	ENDIF ; generated for fun
	IF &TYPE('v2CardIn') = 'UNDEFINED' THEN ; generated for fun
v2CardIn		EQU			7						; on-board video
	ENDIF ; generated for fun
	IF &TYPE('v2SyncOnGreen') = 'UNDEFINED' THEN ; generated for fun
v2SyncOnGreen	EQU			7						; for enabling/disabling Sync-on-Green (DAFB)	<T20>
	ENDIF ; generated for fun

;---------------------------------------------------
; VIA2 Port B definitions
;---------------------------------------------------

	IF &TYPE('v2ConfigLE') = 'UNDEFINED' THEN ; generated for fun
v2ConfigLE		EQU			0						; DFAC config latch enable						<T8>
	ENDIF ; generated for fun
	IF &TYPE('v2CDis') = 'UNDEFINED' THEN ; generated for fun
v2CDis			EQU 		0 						; cache disable (when 1)	<3.3>
	ENDIF ; generated for fun
	IF &TYPE('v2Keyswitch') = 'UNDEFINED' THEN ; generated for fun
v2Keyswitch		EQU			0						; 900/950 ONLY - keyswitch shadow bit (1=SECURE)<T14><T17><SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('v2BusLk') = 'UNDEFINED' THEN ; generated for fun
v2BusLk   		EQU 		1 						; Bus lockout
	ENDIF ; generated for fun
	IF &TYPE('v2PMack') = 'UNDEFINED' THEN ; generated for fun
v2PMack			EQU 		1 						; Power manager handshake acknowledge
	ENDIF ; generated for fun
	IF &TYPE('v2PowerOff') = 'UNDEFINED' THEN ; generated for fun
v2PowerOff		EQU 		2 						; soft power off signal (when 0)
	ENDIF ; generated for fun
													; (also 900/950 keyswitch OFF bit)				<T17><SM4> rb
	IF &TYPE('v2PMreq') = 'UNDEFINED' THEN ; generated for fun
v2PMreq			EQU 		2 						; Power manager handshake request
	ENDIF ; generated for fun
	IF &TYPE('v2ConfigData') = 'UNDEFINED' THEN ; generated for fun
v2ConfigData 	EQU 		3 						; DFAC config data								<T8>
	ENDIF ; generated for fun
	IF &TYPE('v2FC3') = 'UNDEFINED' THEN ; generated for fun
v2FC3  			EQU 		3 						; PMMU FC3 indicator
	ENDIF ; generated for fun
	IF &TYPE('vFC3') = 'UNDEFINED' THEN ; generated for fun
vFC3  			EQU 		3 						; PMMU FC3 indicator
	ENDIF ; generated for fun
	IF &TYPE('v2SndInSel0') = 'UNDEFINED' THEN ; generated for fun
v2SndInSel0		EQU			3						; Eclipse only - sound input select bit 0		<t19><H17>
	ENDIF ; generated for fun
	IF &TYPE('v2ConfigClk') = 'UNDEFINED' THEN ; generated for fun
v2ConfigClk		EQU 		4 						; DFAC config clock								<T8>
	ENDIF ; generated for fun
	IF &TYPE('v2TM1A') = 'UNDEFINED' THEN ; generated for fun
v2TM1A			EQU 		4 						; bit for NUBus
	ENDIF ; generated for fun
	IF &TYPE('v2TM0A') = 'UNDEFINED' THEN ; generated for fun
v2TM0A			EQU 		5 						; and another
	ENDIF ; generated for fun
	IF &TYPE('v2Speed') = 'UNDEFINED' THEN ; generated for fun
v2Speed			EQU 		5 						; 25/33 Mhz 68040 input (0=25MHz, 1=33 MHz)
	ENDIF ; generated for fun
	IF &TYPE('v2MicCtl') = 'UNDEFINED' THEN ; generated for fun
v2MicCtl		EQU			5						; microphone control on Wombats					<H17><SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('v2HMMU') = 'UNDEFINED' THEN ; generated for fun
v2HMMU			EQU			5 						; HMMU 24/32									<15> HJR
	ENDIF ; generated for fun
	IF &TYPE('v2CDis2') = 'UNDEFINED' THEN ; generated for fun
v2CDis2			EQU			6						; On Tim the CDIS is on pb6						<15> HJR
	ENDIF ; generated for fun
	IF &TYPE('v2SndExt') = 'UNDEFINED' THEN ; generated for fun
v2SndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio
	ENDIF ; generated for fun
	IF &TYPE('v2SndInSel1') = 'UNDEFINED' THEN ; generated for fun
v2SndInSel1		EQU			6						; Q900/950 only - sound input select bit 1		<t19><SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('v2VBL') = 'UNDEFINED' THEN ; generated for fun
v2VBL 			EQU 		7 						; pseudo VBL signal
	ENDIF ; generated for fun
	IF &TYPE('v2ModemRST') = 'UNDEFINED' THEN ; generated for fun
v2ModemRST		EQU			7						; Modem.Reset									<15> HJR
	ENDIF ; generated for fun



													; temporary Cyclone equates <SM4> rb, start, <SM5> rb


; <SM7> rb, • TEMP EQUATES

	IF &TYPE('CycloneEVT1Reg') = 'UNDEFINED' THEN ; generated for fun
CycloneEVT1Reg	EQU			$A55A2800				; id which identifies an EVT1 cyclone in CPURegID <SM9> rb
	ENDIF ; generated for fun
	IF &TYPE('PSCVIA2SIntEVT1') = 'UNDEFINED' THEN ; generated for fun
PSCVIA2SIntEVT1	EQU			$000					; Slot interrupt reg. offset					<SM9> rb
	ENDIF ; generated for fun
	IF &TYPE('PSCVIA2IFREVT1') = 'UNDEFINED' THEN ; generated for fun
PSCVIA2IFREVT1	EQU			$004					; VIA2 interrupt flag reg. offset				<SM9> rb
	ENDIF ; generated for fun
	IF &TYPE('PSCVIA2IEREVT1') = 'UNDEFINED' THEN ; generated for fun
PSCVIA2IEREVT1	EQU			$008					; VIA2 interrupt enable reg. offset				<SM9> rb
	ENDIF ; generated for fun

	IF &TYPE('PSCVIA2SInt') = 'UNDEFINED' THEN ; generated for fun
PSCVIA2SInt		EQU			$1E00					; Slot interrupt reg. offset					<SM7> rb
	ENDIF ; generated for fun
	IF &TYPE('PSCVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
PSCVIA2IFR		EQU			$1A00					; VIA2 interrupt flag reg. offset				<SM7> rb
	ENDIF ; generated for fun
	IF &TYPE('PSCVIA2IER') = 'UNDEFINED' THEN ; generated for fun
PSCVIA2IER		EQU			$1C00					; VIA2 interrupt enable reg. offset				<SM7> rb
	ENDIF ; generated for fun


; PSC VIA2 Slot Interrupt Register equates
	IF &TYPE('PSCSlotC') = 'UNDEFINED' THEN ; generated for fun
PSCSlotC		EQU			3						; slot C int.
	ENDIF ; generated for fun
	IF &TYPE('PSCSlotD') = 'UNDEFINED' THEN ; generated for fun
PSCSlotD		EQU			4						; slot D int.
	ENDIF ; generated for fun
	IF &TYPE('PSCSlotE') = 'UNDEFINED' THEN ; generated for fun
PSCSlotE		EQU			5						; slot E int.
	ENDIF ; generated for fun
	IF &TYPE('PSCOVBVBL') = 'UNDEFINED' THEN ; generated for fun
PSCOVBVBL		EQU			6						; on-board video vbl int.
	ENDIF ; generated for fun

; PSC VIA2 Interrupt Flag and Interrupt Enable Registers equates
	IF &TYPE('PSCSCSI0') = 'UNDEFINED' THEN ; generated for fun
PSCSCSI0		EQU			0						; SCSI int., same as bit 3
	ENDIF ; generated for fun
	IF &TYPE('PSCSlot') = 'UNDEFINED' THEN ; generated for fun
PSCSlot			EQU			1						; any slot int.
	ENDIF ; generated for fun
	IF &TYPE('PSCMUNI') = 'UNDEFINED' THEN ; generated for fun
PSCMUNI			EQU			2						; MUNI int.
	ENDIF ; generated for fun
	IF &TYPE('PSCSCSI3') = 'UNDEFINED' THEN ; generated for fun
PSCSCSI3		EQU			3						; SCSI int.
	ENDIF ; generated for fun
	IF &TYPE('PSCFDC') = 'UNDEFINED' THEN ; generated for fun
PSCFDC			EQU			5						; floppy int.
	ENDIF ; generated for fun
	IF &TYPE('PSCSNDFRM') = 'UNDEFINED' THEN ; generated for fun
PSCSNDFRM		EQU			6						; sound frame int.
	ENDIF ; generated for fun
	IF &TYPE('PSCANY') = 'UNDEFINED' THEN ; generated for fun
PSCANY			EQU			7						; any of the above
	ENDIF ; generated for fun

													; <SM4> rb, end, <SM5> rb


;----------
;RBV (Ram Based Video) register definitions
;----------

	IF &TYPE('RvDataB') = 'UNDEFINED' THEN ; generated for fun
RvDataB			EQU			$000					; VIA2 data reg. B equivalent	<v1.4><2.5>
	ENDIF ; generated for fun
	IF &TYPE('RvExp') = 'UNDEFINED' THEN ; generated for fun
RvExp			EQU			$001					; RBV Expansion Register		<3>
	ENDIF ; generated for fun
	IF &TYPE('RvSInt') = 'UNDEFINED' THEN ; generated for fun
RvSInt			EQU			$002					; Slot interrupts reg.			<v1.4><2.5>
	ENDIF ; generated for fun
	IF &TYPE('RvIFR') = 'UNDEFINED' THEN ; generated for fun
RvIFR			EQU			$003					; interrupt flag reg.			<v1.4><2.5>
	ENDIF ; generated for fun
	IF &TYPE('RvMonP') = 'UNDEFINED' THEN ; generated for fun
RvMonP			EQU			$010					; monitor parameters reg.		<v1.4><2.5>
	ENDIF ; generated for fun
	IF &TYPE('RvChpT') = 'UNDEFINED' THEN ; generated for fun
RvChpT			EQU			$011					; chip test reg.				<v1.4><2.5>
	ENDIF ; generated for fun
	IF &TYPE('RvSEnb') = 'UNDEFINED' THEN ; generated for fun
RvSEnb			EQU			$012					; Slot interrupt enable reg.	<v1.4><2.5>
	ENDIF ; generated for fun
	IF &TYPE('RvIER') = 'UNDEFINED' THEN ; generated for fun
RvIER			EQU			$013					; interrupt flag enable reg.	<v1.4><2.5>
	ENDIF ; generated for fun

;----------
;Common Via 2 and RBV (Ram Based Video) register offsets
;----------


	IF &TYPE('Rv2DataB') = 'UNDEFINED' THEN ; generated for fun
Rv2DataB		EQU			vBufB++RvDataB			; RBV/VIA2 data reg. B equivalent	<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2Exp') = 'UNDEFINED' THEN ; generated for fun
Rv2Exp			EQU			RvExp					; RBV Expansion Register			<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2SInt') = 'UNDEFINED' THEN ; generated for fun
Rv2SInt			EQU			RvSInt					; Slot interrupts reg.				<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2IFR') = 'UNDEFINED' THEN ; generated for fun
Rv2IFR			EQU			vIFR++RvIFR				; RBV/VIA2 interrupt flag reg.		<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2MonP') = 'UNDEFINED' THEN ; generated for fun
Rv2MonP			EQU			RvMonP					; monitor parameters reg.			<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2ChpT') = 'UNDEFINED' THEN ; generated for fun
Rv2ChpT			EQU			RvChpT					; chip test reg.					<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2SEnb') = 'UNDEFINED' THEN ; generated for fun
Rv2SEnb			EQU			RvSEnb					; Slot interrupt enable reg.		<H8>
	ENDIF ; generated for fun
	IF &TYPE('Rv2IER') = 'UNDEFINED' THEN ; generated for fun
Rv2IER			EQU			vIER++RvIER				; iRBV/VIA2 interrupt enable reg.	<H8>
	ENDIF ; generated for fun


;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====									<v1.4>
	IF &TYPE('RvCDis') = 'UNDEFINED' THEN ; generated for fun
RvCDis			EQU 		0 						; cache disable (when 1)					<v1.4><3.3>
	ENDIF ; generated for fun
	IF &TYPE('RvBusLk') = 'UNDEFINED' THEN ; generated for fun
RvBusLk   		EQU 		1 						; Bus lockout								<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvPowerOff') = 'UNDEFINED' THEN ; generated for fun
RvPowerOff		EQU 		2 						; soft power off signal (when 0)			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvCFlush') = 'UNDEFINED' THEN ; generated for fun
RvCFlush		EQU 		3 						; Flush external cache (when 0)				<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvTM1A') = 'UNDEFINED' THEN ; generated for fun
RvTM1A			EQU 		4 						; bit for NUBus								<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvTM0A') = 'UNDEFINED' THEN ; generated for fun
RvTM0A			EQU 		5 						; and another								<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSndExt') = 'UNDEFINED' THEN ; generated for fun
RvSndExt  		EQU 		6 						; 1 = internal speaker, 0 = ext. audio		<v1.4>
	ENDIF ; generated for fun
													; jack in use								<v1.4>
	IF &TYPE('RvPGCTest') = 'UNDEFINED' THEN ; generated for fun
RvPGCTest		EQU			7						; 1 = generate good parity, 0 = generate errors
	ENDIF ; generated for fun

;  ======  Future Expansion   Address: $50026001	 =====										<v1.4>

;  ======  Slot Interrupts   Address: $50026002	 =====											<v1.4>
	IF &TYPE('RvIRQ1') = 'UNDEFINED' THEN ; generated for fun
RvIRQ1			EQU 		0 						; slot 1 interrupt							<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ2') = 'UNDEFINED' THEN ; generated for fun
RvIRQ2			EQU 		1 						; slot 2 interrupt							<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ3') = 'UNDEFINED' THEN ; generated for fun
RvIRQ3			EQU 		2 						; slot 3 interrupt							<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ4') = 'UNDEFINED' THEN ; generated for fun
RvIRQ4			EQU 		3 						; slot 4 interrupt							<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ5') = 'UNDEFINED' THEN ; generated for fun
RvIRQ5			EQU 		4 						; slot 5 interrupt							<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ6') = 'UNDEFINED' THEN ; generated for fun
RvIRQ6			EQU 		5 						; slot 6 interrupt							<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ0') = 'UNDEFINED' THEN ; generated for fun
RvIRQ0			EQU 		6 						; slot 0 interrupt or internal video 		<v1.4>
	ENDIF ; generated for fun
													; blanking interrupt						<v1.4>
;RvResr			EQU 		7 						; reserved 									<v1.4>

;  ======  Interrupt Flags   Address: $50026003	 =====											<v1.4>
	IF &TYPE('RvSCSIDRQ') = 'UNDEFINED' THEN ; generated for fun
RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvAnySlot') = 'UNDEFINED' THEN ; generated for fun
RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvExpIRQ') = 'UNDEFINED' THEN ; generated for fun
RvExpIRQ		EQU			2						; 1 = expansion int. (reserved)				<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSCSIRQ') = 'UNDEFINED' THEN ; generated for fun
RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSndIRQ') = 'UNDEFINED' THEN ; generated for fun
RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup				<v1.4>
	ENDIF ; generated for fun
;RvResr			EQU 		5 						; reserved 									<v1.4>
;RvResr			EQU 		6 						; reserved									<v1.4>
;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt			<v1.4>
													; on WRITE, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;  ======  Monitor Parameters   Address: $50026010	 =====										<v1.4>
	IF &TYPE('RvColor1') = 'UNDEFINED' THEN ; generated for fun
RvColor1		EQU			0						; (lsb) R/W 000 = 1bit, 001 = 2 bit			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvColor2') = 'UNDEFINED' THEN ; generated for fun
RvColor2		EQU			1						; 		R/W 010 = 4bit, 011 = 8 bit			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvColor3') = 'UNDEFINED' THEN ; generated for fun
RvColor3		EQU			2						; (msb) Read 1xx = Reserved					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvMonID1') = 'UNDEFINED' THEN ; generated for fun
RvMonID1		EQU			3						; READ 000,011,100=reserved; x01=15" monitor<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvMonID2') = 'UNDEFINED' THEN ; generated for fun
RvMonID2		EQU			4						; 010=Mod'IIGSmonitor;110=MacII monitors	<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvMonID3') = 'UNDEFINED' THEN ; generated for fun
RvMonID3		EQU 		5 						; 111= 9" build in monitor					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvVIDOff') = 'UNDEFINED' THEN ; generated for fun
RvVIDOff		EQU 		6 						; 1 = Video off								<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvVID3St') = 'UNDEFINED' THEN ; generated for fun
RvVID3St		EQU			7						; 1 = all video outputs tri-stated			<v1.4>
	ENDIF ; generated for fun

;  ======  Chip Test   Address: $50026011	 =====												<v1.4>
	IF &TYPE('RvC60') = 'UNDEFINED' THEN ; generated for fun
RvC60			EQU			0						; 1 = C60 clock run 128 x normal			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSpd1') = 'UNDEFINED' THEN ; generated for fun
RvSpd1			EQU			1						; (lsb) 00 = normal, 01=medium				<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSpd2') = 'UNDEFINED' THEN ; generated for fun
RvSpd2			EQU			2						; (msb) 10 = fast, 11 = very fast			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvHndShk3') = 'UNDEFINED' THEN ; generated for fun
RvHndShk3		EQU			3						; 1=VID.REQ & VID.RES tri-stated			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIOClk3') = 'UNDEFINED' THEN ; generated for fun
RvIOClk3		EQU			4						; 1=C16M, C8M, C3.7M tri-stated				<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvC30M') = 'UNDEFINED' THEN ; generated for fun
RvC30M			EQU 		5 						; 1=30.24 mHz clock for all monitors		<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSDTClk') = 'UNDEFINED' THEN ; generated for fun
RvSDTClk		EQU 		6 						; 1 = Dot clock halted						<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvTstRes') = 'UNDEFINED' THEN ; generated for fun
RvTstRes		EQU			7						; 1 = reset video counters					<v1.4>
	ENDIF ; generated for fun

;  ======  Slot Interrupts Enable   Address: $50026012	 =====									<v1.4>
	IF &TYPE('RvIRQ1En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ1En		EQU 		0 						; slot 1 interrupt enabled					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ2En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ2En		EQU 		1 						; slot 2 interrupt enabled					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ3En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ3En		EQU 		2 						; slot 3 interrupt enabled					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ4En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ4En		EQU 		3 						; slot 4 interrupt enabled					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ5En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ5En		EQU 		4 						; slot 5 interrupt enabled					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ6En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ6En		EQU 		5 						; slot 6 interrupt enabled					<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvIRQ0En') = 'UNDEFINED' THEN ; generated for fun
RvIRQ0En		EQU 		6 						; slot 0 interrupt or internal video enabled<v1.4>
	ENDIF ; generated for fun
;RvSetClr		EQU			7						; on READs, always reads 0					<v1.4>
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;  ======  Interrupt Flags Enable   Address: $50026013	 =====
	IF &TYPE('RvSCSIDRQEn') = 'UNDEFINED' THEN ; generated for fun
RvSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvAnySlotEn') = 'UNDEFINED' THEN ; generated for fun
RvAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled		<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvExpIRQEn') = 'UNDEFINED' THEN ; generated for fun
RvExpIRQEn		EQU			2						; 1 = expansion int. (reserved) enabled		<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSCSIRQEn') = 'UNDEFINED' THEN ; generated for fun
RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled			<v1.4>
	ENDIF ; generated for fun
	IF &TYPE('RvSndIRQEn') = 'UNDEFINED' THEN ; generated for fun
RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled	<v1.4>
	ENDIF ; generated for fun
;RvResr			EQU 		5 						; reserved 									<v1.4>
;RvResr			EQU 		6 						; reserved									<v1.4>
;RvSetClr		EQU			7						; on READs, always reads 1					<v1.4>
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's<v1.4>
													;  			0 = 1-bits in bits 0-6 write 0's<v1.4>

;----------
; VDAC register definitions
;----------

	IF &TYPE('vDACwAddReg') = 'UNDEFINED' THEN ; generated for fun
vDACwAddReg		EQU			$0000					;   offset from vDACBase for write address reg
	ENDIF ; generated for fun
	IF &TYPE('vDACrAddReg') = 'UNDEFINED' THEN ; generated for fun
vDACrAddReg		EQU			$000C					;   offset from vDACBase for read address register <v4.2>
	ENDIF ; generated for fun
	IF &TYPE('vDACwDataReg') = 'UNDEFINED' THEN ; generated for fun
vDACwDataReg	EQU			$0004					;   offset from vDACBase for write data reg
	ENDIF ; generated for fun

	IF &TYPE('vDACPixRdMask') = 'UNDEFINED' THEN ; generated for fun
vDACPixRdMask	EQU			$0008					;   offset from vDACBase for pixel mask
	ENDIF ; generated for fun


;__________________________________________________________________________________________
;
;
; VISA Pin Definitions and Register Offsets - Multiple names for the same pin are grouped
; together.  New definitions for VISA pins are added such that the grouping is maintained.
;
;
;__________________________________________________________________________________________


;----------
; VISA register definitions - generally, these equates are a precise subset
;		of the RBV equates.
;----------

; these registers are accessed off of VIA1 lomem
	IF &TYPE('VsData1A') = 'UNDEFINED' THEN ; generated for fun
VsData1A		EQU		  	$1E00					; VIA1 data reg A
	ENDIF ; generated for fun
	IF &TYPE('VsData1B') = 'UNDEFINED' THEN ; generated for fun
VsData1B		EQU			$0000					; VIA1 data reg B
	ENDIF ; generated for fun

; these registers are accessed off of VISA lomem
	IF &TYPE('VsData2B') = 'UNDEFINED' THEN ; generated for fun
VsData2B		EQU			$000					; VIA2 data reg B equivalent
	ENDIF ; generated for fun
	IF &TYPE('VsExp') = 'UNDEFINED' THEN ; generated for fun
VsExp			EQU			$001					; VISA Expansion Register
	ENDIF ; generated for fun
	IF &TYPE('VsSInt') = 'UNDEFINED' THEN ; generated for fun
VsSInt			EQU			$002					; Slot Interrupt Register
	ENDIF ; generated for fun
	IF &TYPE('VsIFR') = 'UNDEFINED' THEN ; generated for fun
VsIFR			EQU			$003					; Interrupt Flag Register
	ENDIF ; generated for fun
	IF &TYPE('VsMonP') = 'UNDEFINED' THEN ; generated for fun
VsMonP			EQU			$010					; Monitor Parameters Register
	ENDIF ; generated for fun
	IF &TYPE('VsSEnb') = 'UNDEFINED' THEN ; generated for fun
VsSEnb			EQU			$012					; Slot Interrupt Enable Register
	ENDIF ; generated for fun
	IF &TYPE('VsIER') = 'UNDEFINED' THEN ; generated for fun
VsIER			EQU			$013					; Interrupt Flag Enable Register
	ENDIF ; generated for fun

;  ======  VIA2 BufferB Equivalent   Address: $50026000	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
	IF &TYPE('VsFC3') = 'UNDEFINED' THEN ; generated for fun
VsFC3			EQU			3						; select 32-bit map.  0=24 bit, 1=32 bit
	ENDIF ; generated for fun
;*VsResr		EQU			4						; reserved
;*VsResr		EQU			5						; reserved
	IF &TYPE('VsSndExt') = 'UNDEFINED' THEN ; generated for fun
VsSndExt		EQU			6						; Always reads as 1 - play sounds in Mono
	ENDIF ; generated for fun
;*VsResr		EQU			7						; reserved

;  ======  Future Expansion   Address: $50026001	 =====
	IF &TYPE('VsA2Mode') = 'UNDEFINED' THEN ; generated for fun
VsA2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
	ENDIF ; generated for fun
	IF &TYPE('VsVResEn') = 'UNDEFINED' THEN ; generated for fun
VsVResEn		EQU			1						; 1=enable vertical counter reset for video genlock
	ENDIF ; generated for fun
	IF &TYPE('VsFlWrEn') = 'UNDEFINED' THEN ; generated for fun
VsFlWrEn	 	EQU			2						; 1=enable writes to flash EEPROM
	ENDIF ; generated for fun
	IF &TYPE('Vs1BV') = 'UNDEFINED' THEN ; generated for fun
Vs1BV			EQU			3						; 1=low base for 1-bit mode, 0=high base
	ENDIF ; generated for fun
	IF &TYPE('VsPg2') = 'UNDEFINED' THEN ; generated for fun
VsPg2			EQU			4						; 1=main video page, 0=sec video page
	ENDIF ; generated for fun
;*VsResr		EQU			5						; reserved
	IF &TYPE('VsSiz0') = 'UNDEFINED' THEN ; generated for fun
VsSiz0			EQU			6						; RAM size control bit 00=1MB, 01=1.5MB
	ENDIF ; generated for fun
	IF &TYPE('VsSiz1') = 'UNDEFINED' THEN ; generated for fun
VsSiz1			EQU			7						; 	10=3MB,11=9MB
	ENDIF ; generated for fun

;  ======  Slot Interrupts   Address: $50026002	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
;*VsResr		EQU			3						; reserved
;*VsResr		EQU			4						; reserved
	IF &TYPE('VsSIRQ') = 'UNDEFINED' THEN ; generated for fun
VsSIRQ			EQU			5						; expansion slot interrupt
	ENDIF ; generated for fun
	IF &TYPE('VsVBLInt') = 'UNDEFINED' THEN ; generated for fun
VsVBLInt		EQU			6						; slot zero (built-in) VBL interrupt
	ENDIF ; generated for fun
;*VsResr		EQU			7						; reserved


;  ======  Interrupt Flags   Address: $50026003	 =====
	IF &TYPE('VsSCSIDRQ') = 'UNDEFINED' THEN ; generated for fun
VsSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrup
	ENDIF ; generated for fun
	IF &TYPE('VsAnySlot') = 'UNDEFINED' THEN ; generated for fun
VsAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
	ENDIF ; generated for fun
;*VsResr		EQU			2						; reserved
	IF &TYPE('VsSCSIRQ') = 'UNDEFINED' THEN ; generated for fun
VsSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
	ENDIF ; generated for fun
	IF &TYPE('VsSndIRQ') = 'UNDEFINED' THEN ; generated for fun
VsSndIRQ		EQU			4						; 1 = Apple Sound Chip interrupt
	ENDIF ; generated for fun
;RvResr			EQU 		5 						; reserved
;RvResr			EQU 		6 						; reserved
	IF &TYPE('RvSetClr') = 'UNDEFINED' THEN ; generated for fun
RvSetClr		EQU			7						; on READ, 1 = any enabled interrupt
	ENDIF ; generated for fun
													; on WRITE, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Monitor Parameters   Address: $50026010	 =====
;*VsResr		EQU			0						; (lsb)
	IF &TYPE('VsColor') = 'UNDEFINED' THEN ; generated for fun
VsColor			EQU			1						; (compat w/RBV) R/W 000 = 1bit, R/W 010 = 4bit
	ENDIF ; generated for fun
;*VsResr		EQU			2						; (msb)
	IF &TYPE('VsMonConn') = 'UNDEFINED' THEN ; generated for fun
VsMonConn		EQU			3						; (lsb)1=no monitor connected
	ENDIF ; generated for fun
;*VsResr		EQU			4						; (compat w/RBV)
	IF &TYPE('VsMonSel') = 'UNDEFINED' THEN ; generated for fun
VsMonSel		EQU 		5 						; (msb) Monitor select 1=Jersey, 0=Rubik
	ENDIF ; generated for fun
;*VsResr		EQU 		6 						; reserved
;*VsResr		EQU			7						; reserved


;  ======  Slot Interrupts Enable   Address: $50026012	 =====
;*VsResr		EQU			0						; reserved
;*VsResr		EQU			1						; reserved
;*VsResr		EQU			2						; reserved
;*VsResr		EQU			3						; reserved
;*VsResr		EQU			4						; reserved
	IF &TYPE('VsExtIRQEn') = 'UNDEFINED' THEN ; generated for fun
VsExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
	ENDIF ; generated for fun
	IF &TYPE('VsIntIRQEn') = 'UNDEFINED' THEN ; generated for fun
VsIntIRQEn		EQU 		6 						; internal video interrupt enabled
	ENDIF ; generated for fun
	IF &TYPE('VsSetClr') = 'UNDEFINED' THEN ; generated for fun
VsSetClr		EQU			7						; on READs, always reads 0
	ENDIF ; generated for fun
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Interrupt Flags Enable   Address: $50026013	 =====
	IF &TYPE('VsSCSIDRQEn') = 'UNDEFINED' THEN ; generated for fun
VsSCSIDRQEn		EQU			0						; 1 = SCSI DRQ interrupt enabled
	ENDIF ; generated for fun
	IF &TYPE('VsAnySlotEn') = 'UNDEFINED' THEN ; generated for fun
VsAnySlotEn		EQU			1						; 1 = any slot(0-6).IRQ int. enabled
	ENDIF ; generated for fun
;*VsResr		EQU			2						; reserved
	IF &TYPE('VsSCSIRQEn') = 'UNDEFINED' THEN ; generated for fun
VsSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
	ENDIF ; generated for fun
	IF &TYPE('VsSndIRQEn') = 'UNDEFINED' THEN ; generated for fun
VsSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
	ENDIF ; generated for fun
;VsResr			EQU 		5 						; reserved
;VsResr			EQU 		6 						; reserved
;RvSetClr		EQU			7						; on READs, always reads 1
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's


;----------
; V8 register definitions - generally compatible with the VISA equates above, but a few equates
;	have changed names.
;----------

; these registers are accessed off of the V8 lomem
	IF &TYPE('V8Exp') = 'UNDEFINED' THEN ; generated for fun
V8Exp			EQU			$001					; V8 Expansion Register
	ENDIF ; generated for fun
	IF &TYPE('V8SInt') = 'UNDEFINED' THEN ; generated for fun
V8SInt			EQU			$002					; V8 Slot Interrupt Register
	ENDIF ; generated for fun
	IF &TYPE('V8MonP') = 'UNDEFINED' THEN ; generated for fun
V8MonP			EQU			$010					; Monitor Parameters Register
	ENDIF ; generated for fun
	IF &TYPE('V8SEnb') = 'UNDEFINED' THEN ; generated for fun
V8SEnb			EQU			$012					; Slot Interrupt Enable Register
	ENDIF ; generated for fun

;  ======  Future Expansion   Address: $50F26001	 =====
	IF &TYPE('V8A2Mode') = 'UNDEFINED' THEN ; generated for fun
V8A2Mode		EQU			0						; 0=512*384 mode, 1=560*384 mode
	ENDIF ; generated for fun
	IF &TYPE('V8512Row') = 'UNDEFINED' THEN ; generated for fun
V8512Row		EQU			1						; 1=V8 rowbytes is 256, 0=rowbytes is 512
	ENDIF ; generated for fun
	IF &TYPE('V8vRAMIn') = 'UNDEFINED' THEN ; generated for fun
V8vRAMIn	 	EQU			2						; 1=refresh video from vRAM, 0=refresh from dRAM
	ENDIF ; generated for fun
;*V8Resr		EQU			3						; no 1BV on V8
;*V8Resr		EQU			4						; no VP2 on V8
	IF &TYPE('V8Siz0') = 'UNDEFINED' THEN ; generated for fun
V8Siz0			EQU			5						; RAM size control bit 0
	ENDIF ; generated for fun
	IF &TYPE('V8Siz1') = 'UNDEFINED' THEN ; generated for fun
V8Siz1			EQU			6						; RAM size control bit 1
	ENDIF ; generated for fun
	IF &TYPE('V8Siz2') = 'UNDEFINED' THEN ; generated for fun
V8Siz2			EQU			7						; RAM size control bit 2
	ENDIF ; generated for fun

;  ======  Monitor Parameters   Address: $50F26010	 =====
	IF &TYPE('V8Col0') = 'UNDEFINED' THEN ; generated for fun
V8Col0			EQU			0						; Video depth control bit 0
	ENDIF ; generated for fun
	IF &TYPE('V8Col1') = 'UNDEFINED' THEN ; generated for fun
V8Col1			EQU			1						; Video depth control bit 1
	ENDIF ; generated for fun
	IF &TYPE('V8Col2') = 'UNDEFINED' THEN ; generated for fun
V8Col2			EQU			2						; Video depth control bit 2
	ENDIF ; generated for fun
	IF &TYPE('V8MonID1') = 'UNDEFINED' THEN ; generated for fun
V8MonID1		EQU			3						; Monitor sense ID bit 1
	ENDIF ; generated for fun
	IF &TYPE('V8MonID2') = 'UNDEFINED' THEN ; generated for fun
V8MonID2		EQU			4						; Monitor sense ID bit 2
	ENDIF ; generated for fun
	IF &TYPE('V8MonID3') = 'UNDEFINED' THEN ; generated for fun
V8MonID3		EQU			5						; Monitor sense ID bit 3
	ENDIF ; generated for fun
;*VsResr		EQU 		6 						; reserved
;*VsResr		EQU			7						; reserved

;  ======  Slot Interrupts Enable   Address: $50F26012	 =====
;*V8Resr		EQU			0						; reserved
;*V8Resr		EQU			1						; reserved
;*V8Resr		EQU			2						; reserved
;*V8Resr		EQU			3						; reserved
;*V8Resr		EQU			4						; reserved
	IF &TYPE('V8ExtIRQEn') = 'UNDEFINED' THEN ; generated for fun
V8ExtIRQEn		EQU 		5 						; expansion slot interrupt enabled
	ENDIF ; generated for fun
	IF &TYPE('V8IntIRQEn') = 'UNDEFINED' THEN ; generated for fun
V8IntIRQEn		EQU 		6 						; internal video interrupt enabled
	ENDIF ; generated for fun
;*V8Resr		EQU			7						; reserved


;----------
; Elsie VDAC register definitions
;----------

; VISA/Bt450 registers

	IF &TYPE('VsDACwAddReg') = 'UNDEFINED' THEN ; generated for fun
VsDACwAddReg	EQU			$0000					;   offset from vDACBase for write address reg
	ENDIF ; generated for fun
	IF &TYPE('VsDACwDataReg') = 'UNDEFINED' THEN ; generated for fun
VsDACwDataReg	EQU			$0001					;   offset from vDACBase for write data reg
	ENDIF ; generated for fun

; V8/Ariel registers

	IF &TYPE('V8DACrAddReg') = 'UNDEFINED' THEN ; generated for fun
V8DACrAddReg	EQU			$0000					; offset for read address reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACwAddReg') = 'UNDEFINED' THEN ; generated for fun
V8DACwAddReg	EQU			$0000					; offset for write address reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACrDataReg') = 'UNDEFINED' THEN ; generated for fun
V8DACrDataReg	EQU			$0001					; offset for read data reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACwDataReg') = 'UNDEFINED' THEN ; generated for fun
V8DACwDataReg	EQU			$0001					; offset for write data reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACrCntlReg') = 'UNDEFINED' THEN ; generated for fun
V8DACrCntlReg	EQU			$0002					; offset for read control reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACwCntlReg') = 'UNDEFINED' THEN ; generated for fun
V8DACwCntlReg	EQU			$0002					; offset for write control reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACrKeyReg') = 'UNDEFINED' THEN ; generated for fun
V8DACrKeyReg	EQU			$0003					; offset for read key color reg
	ENDIF ; generated for fun
	IF &TYPE('V8DACwKeyReg') = 'UNDEFINED' THEN ; generated for fun
V8DACwKeyReg	EQU			$0003					; offset for write key color reg
	ENDIF ; generated for fun

	IF &TYPE('V8vRAMBase') = 'UNDEFINED' THEN ; generated for fun
V8vRAMBase		EQU			$50F40000				; base address of V8 VRAM, if present
	ENDIF ; generated for fun

; End of VISA changes								<4> <cv>


;----------
; DAFB register definitions (offsets from DAFBBase in ProductInfo) ($F980 0000)
;----------

	IF &TYPE('DAFB_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
DAFB_BaseOffset		EQU			$0				; DAFB offset from DAFBBase
	ENDIF ; generated for fun
	IF &TYPE('DAFB_ParmSize') = 'UNDEFINED' THEN ; generated for fun
DAFB_ParmSize		EQU			$5				; size of DAFB programmed subset
	ENDIF ; generated for fun
	IF &TYPE('DAFB_NumRegs') = 'UNDEFINED' THEN ; generated for fun
DAFB_NumRegs		Equ			(16-4)			; Number of DAFB registers (Color Regs are really vRAM).
	ENDIF ; generated for fun

	IF &TYPE('DAFB_VidBaseHi') = 'UNDEFINED' THEN ; generated for fun
DAFB_VidBaseHi		EQU			$0				; DAFB video base address, bits 20:9
	ENDIF ; generated for fun
	IF &TYPE('DAFB_VidBaseLo') = 'UNDEFINED' THEN ; generated for fun
DAFB_VidBaseLo		EQU			$4				; DAFB video base address, bits 8:5 (4:0 always zero)
	ENDIF ; generated for fun
	IF &TYPE('DAFB_RowWords') = 'UNDEFINED' THEN ; generated for fun
DAFB_RowWords		EQU			$8				; DAFB rowlongs size
	ENDIF ; generated for fun
	IF &TYPE('DAFB_ClkCfg') = 'UNDEFINED' THEN ; generated for fun
DAFB_ClkCfg			EQU			$C				; DAFB clock configuration
	ENDIF ; generated for fun
	IF &TYPE('DAFB_Config') = 'UNDEFINED' THEN ; generated for fun
DAFB_Config			EQU			$10				; DAFB general configuration
	ENDIF ; generated for fun
	IF &TYPE('DAFB_BlkWrtEn') = 'UNDEFINED' THEN ; generated for fun
DAFB_BlkWrtEn		EQU			$14				; DAFB block write enable
	ENDIF ; generated for fun
	IF &TYPE('DAFB_PgMdEn') = 'UNDEFINED' THEN ; generated for fun
DAFB_PgMdEn			EQU			$18				; DAFB page mode enable
	ENDIF ; generated for fun
	IF &TYPE('DAFB_Sense') = 'UNDEFINED' THEN ; generated for fun
DAFB_Sense			EQU			$1C				; DAFB sense line
	ENDIF ; generated for fun
	IF &TYPE('DAFB_Reset') = 'UNDEFINED' THEN ; generated for fun
DAFB_Reset			EQU			$20				; DAFB reset control
	ENDIF ; generated for fun
	IF &TYPE('DAFB_SCSIch0') = 'UNDEFINED' THEN ; generated for fun
DAFB_SCSIch0		EQU			$24				; Turbo SCSI channel 0 control (not used)
	ENDIF ; generated for fun
	IF &TYPE('DAFB_SCSIch1') = 'UNDEFINED' THEN ; generated for fun
DAFB_SCSIch1		EQU			$28				; Turbo SCSI channel 1 control (not used)
	ENDIF ; generated for fun
	IF &TYPE('DAFB_Test') = 'UNDEFINED' THEN ; generated for fun
DAFB_Test			EQU			$2C				; DAFB test control
	ENDIF ; generated for fun

	IF &TYPE('DAFB_CRB0') = 'UNDEFINED' THEN ; generated for fun
DAFB_CRB0			EQU			$30				; vRAM Color Register, bank 0
	ENDIF ; generated for fun
	IF &TYPE('DAFB_CRB1') = 'UNDEFINED' THEN ; generated for fun
DAFB_CRB1			EQU			$34				; vRAM Color Register, bank 1
	ENDIF ; generated for fun
	IF &TYPE('DAFB_CRB2') = 'UNDEFINED' THEN ; generated for fun
DAFB_CRB2			EQU			$38				; vRAM Color Register, bank 2
	ENDIF ; generated for fun
	IF &TYPE('DAFB_CRB3') = 'UNDEFINED' THEN ; generated for fun
DAFB_CRB3			EQU			$3C				; vRAM Color Register, bank 3
	ENDIF ; generated for fun

;----------
; Swatch (in DAFB) register definitions (offsets from DAFBBase in ProductInfo)
;----------

	IF &TYPE('Swatch_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
Swatch_BaseOffset	EQU			$100			; Swatch offset from DAFBBase
	ENDIF ; generated for fun
	IF &TYPE('Swatch_BaseOffset1') = 'UNDEFINED' THEN ; generated for fun
Swatch_BaseOffset1	EQU			$124			; parameter offset
	ENDIF ; generated for fun
	IF &TYPE('Swatch_ParmSize1') = 'UNDEFINED' THEN ; generated for fun
Swatch_ParmSize1	EQU			$12				; size of Swatch parameter list
	ENDIF ; generated for fun
	IF &TYPE('Swatch_NumRegs') = 'UNDEFINED' THEN ; generated for fun
Swatch_NumRegs		Equ			30				; Number of Swatch registers.
	ENDIF ; generated for fun

	IF &TYPE('Swatch_Mode') = 'UNDEFINED' THEN ; generated for fun
Swatch_Mode			EQU			$100			; Swatch general control
	ENDIF ; generated for fun
	IF &TYPE('Swatch_IntMsk') = 'UNDEFINED' THEN ; generated for fun
Swatch_IntMsk		EQU			$104			; Swatch interrupt control
	ENDIF ; generated for fun
	IF &TYPE('Swatch_IntStat') = 'UNDEFINED' THEN ; generated for fun
Swatch_IntStat		EQU			$108			; Swatch interrupt status
	ENDIF ; generated for fun
	IF &TYPE('Swatch_ClrCrsrInt') = 'UNDEFINED' THEN ; generated for fun
Swatch_ClrCrsrInt	EQU			$10C			; Swatch clear cursor interrupt (not used in this form)
	ENDIF ; generated for fun
	IF &TYPE('Swatch_ClrAnimInt') = 'UNDEFINED' THEN ; generated for fun
Swatch_ClrAnimInt	EQU			$110			; Swatch clear animation interrupt (not used in this form)
	ENDIF ; generated for fun
	IF &TYPE('Swatch_ClrVBLInt') = 'UNDEFINED' THEN ; generated for fun
Swatch_ClrVBLInt	EQU			$114			; Swatch clear VBL interrupt (not used in this form)
	ENDIF ; generated for fun
	IF &TYPE('Swatch_CrsrLine') = 'UNDEFINED' THEN ; generated for fun
Swatch_CrsrLine		EQU			$118			; Swatch cursor interrupt trigger line
	ENDIF ; generated for fun
	IF &TYPE('Swatch_AnimLine') = 'UNDEFINED' THEN ; generated for fun
Swatch_AnimLine		EQU			$11C			; Swatch animation interrupt trigger line
	ENDIF ; generated for fun
	IF &TYPE('Swatch_Test') = 'UNDEFINED' THEN ; generated for fun
Swatch_Test			EQU			$120			; Swatch counter test
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HSyncRegs') = 'UNDEFINED' THEN ; generated for fun
Swatch_HSyncRegs	EQU			$124			; Swatch horizontal sync registers (set as a group)
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HSerr') = 'UNDEFINED' THEN ; generated for fun
Swatch_HSerr		Equ			$124			;   HSerr
	ENDIF ; generated for fun
	IF &TYPE('Swatch_Hlfln') = 'UNDEFINED' THEN ; generated for fun
Swatch_Hlfln		Equ			$128			;   Hlfln
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HEq') = 'UNDEFINED' THEN ; generated for fun
Swatch_HEq			Equ			$12C			;   HEq
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HSP') = 'UNDEFINED' THEN ; generated for fun
Swatch_HSP			Equ			$130			;   HSP
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HBWay') = 'UNDEFINED' THEN ; generated for fun
Swatch_HBWay		Equ			$134			;   HBWay
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HBrst') = 'UNDEFINED' THEN ; generated for fun
Swatch_HBrst		Equ			$138			;   HBrst
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HBP') = 'UNDEFINED' THEN ; generated for fun
Swatch_HBP			Equ			$13C			;   HBP
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HAL') = 'UNDEFINED' THEN ; generated for fun
Swatch_HAL			Equ			$140			;   HAL
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HFP') = 'UNDEFINED' THEN ; generated for fun
Swatch_HFP			Equ			$144			;   HFP
	ENDIF ; generated for fun
	IF &TYPE('Swatch_HPix') = 'UNDEFINED' THEN ; generated for fun
Swatch_HPix			Equ			$148			;   HPix
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VSyncRegs') = 'UNDEFINED' THEN ; generated for fun
Swatch_VSyncRegs	EQU			$14C			; Swatch vertical sync registers (set as a group)
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VHLine') = 'UNDEFINED' THEN ; generated for fun
Swatch_VHLine		Equ			$14C			;	VHLine
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VSync') = 'UNDEFINED' THEN ; generated for fun
Swatch_VSync		Equ			$150			;	VSync
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VBPEq') = 'UNDEFINED' THEN ; generated for fun
Swatch_VBPEq		Equ			$154			;	VBPEq
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VBP') = 'UNDEFINED' THEN ; generated for fun
Swatch_VBP			Equ			$158			;	VBP
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VAL') = 'UNDEFINED' THEN ; generated for fun
Swatch_VAL			Equ			$15C			;	VAL
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VFP') = 'UNDEFINED' THEN ; generated for fun
Swatch_VFP			Equ			$160			;	VFP
	ENDIF ; generated for fun
	IF &TYPE('Swatch_VFPEq') = 'UNDEFINED' THEN ; generated for fun
Swatch_VFPEq		Equ			$164			;	VFPEq
	ENDIF ; generated for fun
	IF &TYPE('Swatch_TimeAdj') = 'UNDEFINED' THEN ; generated for fun
Swatch_TimeAdj		EQU			$168			; Swatch miscellaneous timing adjust
	ENDIF ; generated for fun
	IF &TYPE('Swatch_ActLine') = 'UNDEFINED' THEN ; generated for fun
Swatch_ActLine		EQU			$16C			; Swatch active video line (read-only)
	ENDIF ; generated for fun

;----------
; ACDC register definitions (offsets from DAFBBase in ProductInfo, also in vDACBase)
;----------

	IF &TYPE('ACDC_AddrReg') = 'UNDEFINED' THEN ; generated for fun
ACDC_AddrReg		EQU			$200			; set position in ACDC internal RAM
	ENDIF ; generated for fun
	IF &TYPE('ACDC_DataReg') = 'UNDEFINED' THEN ; generated for fun
ACDC_DataReg		EQU			$210			; read/write data in ACDC internal RAM
	ENDIF ; generated for fun
	IF &TYPE('ACDC_ConfigReg') = 'UNDEFINED' THEN ; generated for fun
ACDC_ConfigReg		EQU			$220			; ACDC offset from DAFBBase
	ENDIF ; generated for fun
	IF &TYPE('ACDC_ParmSize') = 'UNDEFINED' THEN ; generated for fun
ACDC_ParmSize		EQU			$1				; size of ACDC parameter list
	ENDIF ; generated for fun


;----------
; National Clock Chip register definitions (offsets from DAFBBase in ProductInfo)
;----------

	IF &TYPE('Clk_BaseOffset') = 'UNDEFINED' THEN ; generated for fun
Clk_BaseOffset		EQU			$300			; National offset from DAFBBase
	ENDIF ; generated for fun
	IF &TYPE('Clk_ParmSize') = 'UNDEFINED' THEN ; generated for fun
Clk_ParmSize		EQU			$10 			; size of National parameter list
	ENDIF ; generated for fun
	IF &TYPE('Clk_ParmSize1') = 'UNDEFINED' THEN ; generated for fun
Clk_ParmSize1		Equ			$0A				; (Once programmed, the last six bytes are always the same.)
	ENDIF ; generated for fun

;----------
; Misc. DAFB Parms
;----------
	IF &TYPE('Misc_ParmSize') = 'UNDEFINED' THEN ; generated for fun
Misc_ParmSize		Equ			$4				; Just for consistency with other DAFB parms.
	ENDIF ; generated for fun


;----------
; GSC register definitions (offsets from VDACAddr in ProductInfo) ($50F2 0000)					<H5> jmp
;----------
	IF &TYPE('GSCDeviceID') = 'UNDEFINED' THEN ; generated for fun
GSCDeviceID			Equ		$00						; Device revision register; read only.
	ENDIF ; generated for fun
	IF &TYPE('GSCPanelID') = 'UNDEFINED' THEN ; generated for fun
GSCPanelID			Equ		$01						; “Senseline” read/write register.
	ENDIF ; generated for fun
	IF &TYPE('GSCPanelControl') = 'UNDEFINED' THEN ; generated for fun
GSCPanelControl		Equ		$02						; Switches r/w sense of PanelID reg.
	ENDIF ; generated for fun
	IF &TYPE('GSCPanelSetup') = 'UNDEFINED' THEN ; generated for fun
GSCPanelSetup		Equ		$03						; Panel intialization register.
	ENDIF ; generated for fun
	IF &TYPE('GSCGrayScale') = 'UNDEFINED' THEN ; generated for fun
GSCGrayScale		Equ		$04						; The depth-switching register.
	ENDIF ; generated for fun
	IF &TYPE('GSCPolyAdj') = 'UNDEFINED' THEN ; generated for fun
GSCPolyAdj			Equ		$05						; Allows for grayscale adjustment.
	ENDIF ; generated for fun
	IF &TYPE('GSCPanelAdj') = 'UNDEFINED' THEN ; generated for fun
GSCPanelAdj			Equ		$06						; Allows for panel adjustment.
	ENDIF ; generated for fun
	IF &TYPE('GSCACDClk') = 'UNDEFINED' THEN ; generated for fun
GSCACDClk			Equ		$07						; Who knows?
	ENDIF ; generated for fun
	IF &TYPE('GSCRefreshRate') = 'UNDEFINED' THEN ; generated for fun
GSCRefreshRate		Equ		$08						; Refresh cycles per scanline.
	ENDIF ; generated for fun
	IF &TYPE('GSCBlankShade') = 'UNDEFINED' THEN ; generated for fun
GSCBlankShade		Equ		$09						; Shade of gray for depth switches.
	ENDIF ; generated for fun
	IF &TYPE('GSCPanelSkew') = 'UNDEFINED' THEN ; generated for fun
GSCPanelSkew		Equ		$0A						; Who knows?
	ENDIF ; generated for fun

	IF &TYPE('GSCDiag0') = 'UNDEFINED' THEN ; generated for fun
GSCDiag0			Equ		$1D						; Undocumented “diagnostic” registers.
	ENDIF ; generated for fun
	IF &TYPE('GSCDiag1') = 'UNDEFINED' THEN ; generated for fun
GSCDiag1			Equ		$1E
	ENDIF ; generated for fun
	IF &TYPE('GSCDiag2') = 'UNDEFINED' THEN ; generated for fun
GSCDiag2			Equ		$1F
	ENDIF ; generated for fun


;----------
; Sonora register definitions (offsets from SonoraAddr in ProductInfo) ($50F0 0000)				<H4><H6>
;----------

	IF &TYPE('SonoraVIA2Base') = 'UNDEFINED' THEN ; generated for fun
SonoraVIA2Base	Equ			$26000					; Base address of VIA2
	ENDIF ; generated for fun

	IF &TYPE('SonoraVIA2Data') = 'UNDEFINED' THEN ; generated for fun
SonoraVIA2Data	Equ			$00						; VIA2 Data Register
	ENDIF ; generated for fun
	IF &TYPE('SonoraRAMSize') = 'UNDEFINED' THEN ; generated for fun
SonoraRAMSize	EQU			$01						; DRAM config
	ENDIF ; generated for fun
	IF &TYPE('SonoraSlotIFR') = 'UNDEFINED' THEN ; generated for fun
SonoraSlotIFR	Equ			$02						; Slot Interrupt Flags Register
	ENDIF ; generated for fun
	IF &TYPE('SonoraVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
SonoraVIA2IFR	Equ			$03						; VIA2 Interrupt Flags Register
	ENDIF ; generated for fun
	IF &TYPE('SonoraVRAMSize') = 'UNDEFINED' THEN ; generated for fun
SonoraVRAMSize	Equ			$04						; VRAM config
	ENDIF ; generated for fun
	IF &TYPE('SonoraSpeedReg') = 'UNDEFINED' THEN ; generated for fun
SonoraSpeedReg	Equ			$05						; System CPU Speed (waitstate) Register
	ENDIF ; generated for fun
	IF &TYPE('SonoraSlotIER') = 'UNDEFINED' THEN ; generated for fun
SonoraSlotIER	Equ			$12						; Slot Interrupt Enable Register
	ENDIF ; generated for fun
	IF &TYPE('SonoraVIA2IER') = 'UNDEFINED' THEN ; generated for fun
SonoraVIA2IER	Equ			$13						; Interrupt Flag Register
	ENDIF ; generated for fun
	IF &TYPE('SonoraVdCtlBase') = 'UNDEFINED' THEN ; generated for fun
SonoraVdCtlBase	Equ			$28000					; Base address of video control registers
	ENDIF ; generated for fun

	IF &TYPE('SonoraVdModeReg') = 'UNDEFINED' THEN ; generated for fun
SonoraVdModeReg	Equ			$00						; Monitor code and video blanking register
	ENDIF ; generated for fun
	IF &TYPE('SonoraVdColrReg') = 'UNDEFINED' THEN ; generated for fun
SonoraVdColrReg Equ			$01						; Framebuffer pixel depth control register
	ENDIF ; generated for fun
	IF &TYPE('SonoraVdSenseRg') = 'UNDEFINED' THEN ; generated for fun
SonoraVdSenseRg	Equ			$02						; Senseline register
	ENDIF ; generated for fun

; Bits for Misc Sonora Regs
;
	IF &TYPE('SonoraSetClr') = 'UNDEFINED' THEN ; generated for fun
SonoraSetClr	Equ			7						; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
	ENDIF ; generated for fun
													;  			 0 = 1-bits in bits 0-6 write 0's

; Bits for SonoraSlotIER
;
	IF &TYPE('SonoraVBLIRQEn') = 'UNDEFINED' THEN ; generated for fun
SonoraVBLIRQEn	Equ			6						; Enable/Disable built-in video VBL
	ENDIF ; generated for fun

;----------
; Ariel register definitions (offsets from VDACAddr in ProductInfo) ($50F2 4000)				<H6>
;----------
	IF &TYPE('ArielAddrReg') = 'UNDEFINED' THEN ; generated for fun
ArielAddrReg	Equ			0						; Offset to r/w address register
	ENDIF ; generated for fun
	IF &TYPE('ArielDataReg') = 'UNDEFINED' THEN ; generated for fun
ArielDataReg	Equ			1						; Offset to r/w data register
	ENDIF ; generated for fun
	IF &TYPE('ArielConfigReg') = 'UNDEFINED' THEN ; generated for fun
ArielConfigReg	Equ			2						; Offset to r/w control register
	ENDIF ; generated for fun
	IF &TYPE('ArielKeyReg') = 'UNDEFINED' THEN ; generated for fun
ArielKeyReg		Equ			3						; Offset to r/w key color register
	ENDIF ; generated for fun


;----------
; MMC register definitions (offsets from MMCAddr in ProductInfo) ($50F3 0400)				<P2><SM4> rb, start
;----------

	IF &TYPE('MMC_DRAMspeed0') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMspeed0	EQU			$00						; DRAM timing register 0 [M0].
	ENDIF ; generated for fun
	IF &TYPE('MMC_DRAMspeed1') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMspeed1	EQU			$04						; DRAM timing register 1 [M1].
	ENDIF ; generated for fun

	IF &TYPE('MMC_CPUspeed0') = 'UNDEFINED' THEN ; generated for fun
MMC_CPUspeed0	EQU			$08						; Clock speed 0 [M2].
	ENDIF ; generated for fun
	IF &TYPE('MMC_CPUspeed1') = 'UNDEFINED' THEN ; generated for fun
MMC_CPUspeed1	EQU			$0C						; Clock speed 1 [M3].
	ENDIF ; generated for fun

	IF &TYPE('MMC_ROMspeed0') = 'UNDEFINED' THEN ; generated for fun
MMC_ROMspeed0	EQU			$10						; ROM cycle time 0 [M4].
	ENDIF ; generated for fun
	IF &TYPE('MMC_ROMspeed1') = 'UNDEFINED' THEN ; generated for fun
MMC_ROMspeed1	EQU			$14						; ROM cycle time 1 [M5].
	ENDIF ; generated for fun
	IF &TYPE('MMC_ROMspeed2') = 'UNDEFINED' THEN ; generated for fun
MMC_ROMspeed2	EQU			$18						; ROM cycle time 2 [M6].
	ENDIF ; generated for fun

	IF &TYPE('MMC_DSPspeed') = 'UNDEFINED' THEN ; generated for fun
MMC_DSPspeed	EQU			$1C						; DSP clock speed [M7].
	ENDIF ; generated for fun

	IF &TYPE('MMC_DRAMwidth0') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMwidth0	EQU			$20						; DRAM width 0 [M8].
	ENDIF ; generated for fun
	IF &TYPE('MMC_DRAMwidth1') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMwidth1	EQU			$24						; DRAM width 1 [M9].
	ENDIF ; generated for fun
	IF &TYPE('MMC_DRAMwidth2') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMwidth2	EQU			$28						; DRAM width 2 [M10].
	ENDIF ; generated for fun
	IF &TYPE('MMC_DRAMwidth3') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMwidth3	EQU			$2C						; DRAM width 3 [M11].
	ENDIF ; generated for fun

	IF &TYPE('MMC_EPROMmode') = 'UNDEFINED' THEN ; generated for fun
MMC_EPROMmode	EQU			$30						; EPROM mode [M12].
	ENDIF ; generated for fun

	IF &TYPE('MMC_DRAMrange2') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMrange2	EQU			$34						; DRAM bank range 0 [M13].
	ENDIF ; generated for fun
	IF &TYPE('MMC_DRAMrange1') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMrange1	EQU			$38						; DRAM bank range 1 [M14].
	ENDIF ; generated for fun
	IF &TYPE('MMC_DRAMrange0') = 'UNDEFINED' THEN ; generated for fun
MMC_DRAMrange0	EQU			$3C						; DRAM bank range 2 [M15].
	ENDIF ; generated for fun

	IF &TYPE('MMC_CPUID0') = 'UNDEFINED' THEN ; generated for fun
MMC_CPUID0		EQU			$40						; CPU ID 0 [M16].
	ENDIF ; generated for fun
	IF &TYPE('MMC_CPUID1') = 'UNDEFINED' THEN ; generated for fun
MMC_CPUID1		EQU			$44						; CPU ID 1 [M17].
	ENDIF ; generated for fun

	IF &TYPE('MMC_ClockSelect') = 'UNDEFINED' THEN ; generated for fun
MMC_ClockSelect	EQU			$48						; Endeavor Input Clock Select (NTSC/PAL) [M18].
	ENDIF ; generated for fun

	IF &TYPE('MMC_Bypass') = 'UNDEFINED' THEN ; generated for fun
MMC_Bypass		EQU			$4C						; RGB or Composite bypass [M19].
	ENDIF ; generated for fun

;----------
; MUNI (NuBus) register definitions																<P6>
;----------

; <SM7> rb, • TEMP for EVT1							;											<SM7> rb

	IF &TYPE('MUNIBaseEVT1') = 'UNDEFINED' THEN ; generated for fun
MUNIBaseEVT1	EQU			$50F30800				; Base address of Muni for EVT1				<SM9> rb
	ENDIF ; generated for fun


	IF &TYPE('MUNIBase') = 'UNDEFINED' THEN ; generated for fun
MUNIBase		EQU			$50F30000				; Base address of Muni.						<SM7> rb
	ENDIF ; generated for fun



	IF &TYPE('MUNI_IntCntrl') = 'UNDEFINED' THEN ; generated for fun
MUNI_IntCntrl	EQU			$00						; Interrupt control register.
	ENDIF ; generated for fun
	IF &TYPE('MUNI_IntStatus') = 'UNDEFINED' THEN ; generated for fun
MUNI_IntStatus	EQU			$04						; Interrupt status register.
	ENDIF ; generated for fun
	IF &TYPE('MUNI_Control') = 'UNDEFINED' THEN ; generated for fun
MUNI_Control	EQU			$08						; System control register.
	ENDIF ; generated for fun
	IF &TYPE('MUNI_BlkAttmpt') = 'UNDEFINED' THEN ; generated for fun
MUNI_BlkAttmpt	EQU			$0C						; Block attempt register.
	ENDIF ; generated for fun
	IF &TYPE('MUNI_Status') = 'UNDEFINED' THEN ; generated for fun
MUNI_Status		EQU			$10						; Status register.
	ENDIF ; generated for fun
	IF &TYPE('MUNI_Test') = 'UNDEFINED' THEN ; generated for fun
MUNI_Test		EQU			$14						; Test control register.
	ENDIF ; generated for fun

;----------
; Civic register definitions (offsets from CivicAddr in ProductInfo) ($50F3 6000)
;----------

	IF &TYPE('Civic_VBLInt') = 'UNDEFINED' THEN ; generated for fun
Civic_VBLInt	Equ			$000					; Read-only VBL flag register
	ENDIF ; generated for fun
	IF &TYPE('Civic_VBLEnb') = 'UNDEFINED' THEN ; generated for fun
Civic_VBLEnb	Equ			$110					; Enables VBL interrupt.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VBLClr') = 'UNDEFINED' THEN ; generated for fun
Civic_VBLClr	Equ			$120					; Clear VBL interrupt.
	ENDIF ; generated for fun

	IF &TYPE('Civic_Enable') = 'UNDEFINED' THEN ; generated for fun
Civic_Enable	Equ			$004					; Enables Civic’s timing generator (Casio).
	ENDIF ; generated for fun
	IF &TYPE('Civic_Reset') = 'UNDEFINED' THEN ; generated for fun
Civic_Reset		Equ			$10C					; Resets Casio.
	ENDIF ; generated for fun

	IF &TYPE('Civic_VDCInt') = 'UNDEFINED' THEN ; generated for fun
Civic_VDCInt	Equ			$008					; Read-only VDC flag register.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VDCClr') = 'UNDEFINED' THEN ; generated for fun
Civic_VDCClr	Equ			$00C					; Clears VDC interrupt.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VDCEnb') = 'UNDEFINED' THEN ; generated for fun
Civic_VDCEnb	Equ			$010					; Enables VDC interrupt.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VDCClk') = 'UNDEFINED' THEN ; generated for fun
Civic_VDCClk	Equ			$018					; Enables VDC clock.
	ENDIF ; generated for fun

	IF &TYPE('Civic_VidInSize') = 'UNDEFINED' THEN ; generated for fun
Civic_VidInSize	Equ			$014					; Controls video-in Rows (1024 vs. 1536 bytes).
	ENDIF ; generated for fun

	IF &TYPE('Civic_VidInDble') = 'UNDEFINED' THEN ; generated for fun
Civic_VidInDble	Equ			$208					; Controls whether Civic Doubles each Video-in Field
	ENDIF ; generated for fun

	IF &TYPE('Civic_ScanCtl') = 'UNDEFINED' THEN ; generated for fun
Civic_ScanCtl	Equ			$01C					; Controls progressive vs. interlaced scans.
	ENDIF ; generated for fun

	IF &TYPE('Civic_GSCDivide') = 'UNDEFINED' THEN ; generated for fun
Civic_GSCDivide	Equ			$020					; Controls graphics clock divide count.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VSCDivide') = 'UNDEFINED' THEN ; generated for fun
Civic_VSCDivide	Equ			$02C					; Controls video-in clock divide count.
	ENDIF ; generated for fun

	IF &TYPE('Civic_VRAMSize') = 'UNDEFINED' THEN ; generated for fun
Civic_VRAMSize	Equ			$040					; Controls VRAM sizing (1 vs. 2 Mbytes).
	ENDIF ; generated for fun

	IF &TYPE('Civic_RfrshCtl') = 'UNDEFINED' THEN ; generated for fun
Civic_RfrshCtl	Equ			$044					; Controls the refresh mode.
	ENDIF ; generated for fun

	IF &TYPE('Civic_BusSize') = 'UNDEFINED' THEN ; generated for fun
Civic_BusSize	Equ			$04C					; Controls the bus size (32 vs. 64 bits).
	ENDIF ; generated for fun

	IF &TYPE('Civic_SpeedCtl') = 'UNDEFINED' THEN ; generated for fun
Civic_SpeedCtl	Equ			$050					; Controls the timing (25 vs. 33 MHz).
	ENDIF ; generated for fun

	IF &TYPE('Civic_ConvEnb') = 'UNDEFINED' THEN ; generated for fun
Civic_ConvEnb	Equ			$054					; Enables convolution.
	ENDIF ; generated for fun

	IF &TYPE('Civic_ReadSense') = 'UNDEFINED' THEN ; generated for fun
Civic_ReadSense	Equ			$088					; Sense-line registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_SenseCtl') = 'UNDEFINED' THEN ; generated for fun
Civic_SenseCtl	Equ			$058					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_Sense0') = 'UNDEFINED' THEN ; generated for fun
Civic_Sense0	Equ			$05C					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_Sense1') = 'UNDEFINED' THEN ; generated for fun
Civic_Sense1	Equ			$060					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_Sense2') = 'UNDEFINED' THEN ; generated for fun
Civic_Sense2	Equ			$064					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_SenseTst') = 'UNDEFINED' THEN ; generated for fun
Civic_SenseTst	Equ			$068					;
	ENDIF ; generated for fun

	IF &TYPE('Civic_SyncClr') = 'UNDEFINED' THEN ; generated for fun
Civic_SyncClr	Equ			$06C					; Disables RGB (Sync) output.
	ENDIF ; generated for fun

	IF &TYPE('Civic_BaseAddr') = 'UNDEFINED' THEN ; generated for fun
Civic_BaseAddr	Equ			$0C0					; Base address of active video.
	ENDIF ; generated for fun
	IF &TYPE('Civic_RowWords') = 'UNDEFINED' THEN ; generated for fun
Civic_RowWords	Equ			$094					; Row long words of active video.
	ENDIF ; generated for fun

	IF &TYPE('Civic_AdjF1') = 'UNDEFINED' THEN ; generated for fun
Civic_AdjF1		Equ			$128					; Timing adjust registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_AdjF2') = 'UNDEFINED' THEN ; generated for fun
Civic_AdjF2		Equ			$124					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_Piped') = 'UNDEFINED' THEN ; generated for fun
Civic_Piped		Equ			$440					;
	ENDIF ; generated for fun

	IF &TYPE('Civic_HSerr') = 'UNDEFINED' THEN ; generated for fun
Civic_HSerr		Equ			$180					; Horizontal timing registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_HlfLn') = 'UNDEFINED' THEN ; generated for fun
Civic_HlfLn		Equ			$280					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HEq') = 'UNDEFINED' THEN ; generated for fun
Civic_HEq		Equ			$2C0					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HSP') = 'UNDEFINED' THEN ; generated for fun
Civic_HSP		Equ			$300					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HBWay') = 'UNDEFINED' THEN ; generated for fun
Civic_HBWay		Equ			$340					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HAL') = 'UNDEFINED' THEN ; generated for fun
Civic_HAL		Equ			$380					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HFP') = 'UNDEFINED' THEN ; generated for fun
Civic_HFP		Equ			$3C0					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HPix') = 'UNDEFINED' THEN ; generated for fun
Civic_HPix		Equ			$400					;
	ENDIF ; generated for fun

	IF &TYPE('Civic_VHLine') = 'UNDEFINED' THEN ; generated for fun
Civic_VHLine	Equ			$480					; Vertical timing registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VSync') = 'UNDEFINED' THEN ; generated for fun
Civic_VSync		Equ			$4C0					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VBPEqu') = 'UNDEFINED' THEN ; generated for fun
Civic_VBPEqu	Equ			$500					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VBP') = 'UNDEFINED' THEN ; generated for fun
Civic_VBP		Equ			$540					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VAL') = 'UNDEFINED' THEN ; generated for fun
Civic_VAL		Equ			$580					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VFP') = 'UNDEFINED' THEN ; generated for fun
Civic_VFP		Equ			$640					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VFPEqu') = 'UNDEFINED' THEN ; generated for fun
Civic_VFPEqu	Equ			$680					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_CurLine') = 'UNDEFINED' THEN ; generated for fun
Civic_CurLine	Equ			$6C0					;
	ENDIF ; generated for fun

	IF &TYPE('Civic_VInHAL') = 'UNDEFINED' THEN ; generated for fun
Civic_VInHAL	Equ			$1C0					; Video-in timing registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VInHFPD') = 'UNDEFINED' THEN ; generated for fun
Civic_VInHFPD	Equ			$200					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VInHFP') = 'UNDEFINED' THEN ; generated for fun
Civic_VInHFP	Equ			$240					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VInVAL') = 'UNDEFINED' THEN ; generated for fun
Civic_VInVAL	Equ			$5C0					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VInVFP') = 'UNDEFINED' THEN ; generated for fun
Civic_VInVFP	Equ			$600					;
	ENDIF ; generated for fun

	IF &TYPE('Civic_HLDB') = 'UNDEFINED' THEN ; generated for fun
Civic_HLDB		Equ			$114					; Horizontal test/control registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_HHLTB') = 'UNDEFINED' THEN ; generated for fun
Civic_HHLTB		Equ			$118					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_HActHi') = 'UNDEFINED' THEN ; generated for fun
Civic_HActHi	Equ			$11C
	ENDIF ; generated for fun

	IF &TYPE('Civic_VLDB') = 'UNDEFINED' THEN ; generated for fun
Civic_VLDB		Equ			$100					; VSync test/control registers.
	ENDIF ; generated for fun
	IF &TYPE('Civic_VHLTB') = 'UNDEFINED' THEN ; generated for fun
Civic_VHLTB		Equ			$104					;
	ENDIF ; generated for fun
	IF &TYPE('Civic_VActHi') = 'UNDEFINED' THEN ; generated for fun
Civic_VActHi	Equ			$108					;
	ENDIF ; generated for fun

	IF &TYPE('Civic_TestEnb') = 'UNDEFINED' THEN ; generated for fun
Civic_TestEnb	Equ			$12C					; Enables Casio test mode.
	ENDIF ; generated for fun
	IF &TYPE('Civic_CntTest') = 'UNDEFINED' THEN ; generated for fun
Civic_CntTest	Equ			$140					; Count test register.
	ENDIF ; generated for fun

;----------
; Sebastian register definitions (offsets from SebastianAddr in ProductInfo) ($50F3 0000)
;----------

	IF &TYPE('SebastAddrReg') = 'UNDEFINED' THEN ; generated for fun
SebastAddrReg	Equ			$000					; CLUT/DAC Address register.
	ENDIF ; generated for fun
	IF &TYPE('SebastDataReg') = 'UNDEFINED' THEN ; generated for fun
SebastDataReg	Equ			$010					; CLUT/DAC Data register.
	ENDIF ; generated for fun
	IF &TYPE('SebastPCBR') = 'UNDEFINED' THEN ; generated for fun
SebastPCBR		Equ			$020					; CLUT/DAC Pixel Bus Control register.
	ENDIF ; generated for fun

;----------
; Endeavor register definitions
;----------

	IF &TYPE('Endeavor') = 'UNDEFINED' THEN ; generated for fun
Endeavor		Equ			$50F2E000				; Base address of Endeavor in Cyclone.
	ENDIF ; generated for fun

	IF &TYPE('EndeavorM') = 'UNDEFINED' THEN ; generated for fun
EndeavorM		Equ			$000					; 8-bit numerator.
	ENDIF ; generated for fun
	IF &TYPE('EndeavorN') = 'UNDEFINED' THEN ; generated for fun
EndeavorN		Equ			$010					; 8-bit denominator.
	ENDIF ; generated for fun
	IF &TYPE('EndeavorClk') = 'UNDEFINED' THEN ; generated for fun
EndeavorClk		Equ			$020					; Clock select (A or B).
	ENDIF ; generated for fun

;----------
; MSC register definitions (offsets from MSCAddr in ProductInfo) ($50F2 6000)
;----------

	IF &TYPE('MSCSlotIFR') = 'UNDEFINED' THEN ; generated for fun
MSCSlotIFR		EQU			$02						; slots interrupt flags
	ENDIF ; generated for fun
	IF &TYPE('MSCVIA2IFR') = 'UNDEFINED' THEN ; generated for fun
MSCVIA2IFR		EQU			$03						; VIA 2 interrupt flags
	ENDIF ; generated for fun
	IF &TYPE('MSCConfig') = 'UNDEFINED' THEN ; generated for fun
MSCConfig		EQU			$10						; RAM, clock configuration
	ENDIF ; generated for fun
	IF &TYPE('MSCSlotIER') = 'UNDEFINED' THEN ; generated for fun
MSCSlotIER		EQU			$12						; slots interrupt enables
	ENDIF ; generated for fun
	IF &TYPE('MSCVIA2IER') = 'UNDEFINED' THEN ; generated for fun
MSCVIA2IER		EQU			$13						; VIA 2 interrupt enables
	ENDIF ; generated for fun
	IF &TYPE('MSCClkCntl') = 'UNDEFINED' THEN ; generated for fun
MSCClkCntl		EQU			$21						; peripherals clock control
	ENDIF ; generated for fun
	IF &TYPE('MSCSndCntl') = 'UNDEFINED' THEN ; generated for fun
MSCSndCntl		EQU			$22						; sound control
	ENDIF ; generated for fun
	IF &TYPE('MSCFlashWrEnb') = 'UNDEFINED' THEN ; generated for fun
MSCFlashWrEnb	EQU			$23						; flash ROM write enable
	ENDIF ; generated for fun
	IF &TYPE('MSCPowerCycle') = 'UNDEFINED' THEN ; generated for fun
MSCPowerCycle	EQU			$50FA0000-$50F26000		; CPU power off control register			<H2>
	ENDIF ; generated for fun

;  ======  VIA2 BufferB Equivalent		Address: $50F26000	 =====
	IF &TYPE('MSCExpansion') = 'UNDEFINED' THEN ; generated for fun
MSCExpansion	EQU			0						; 0 = enable on-board external cache (not currently used)
	ENDIF ; generated for fun
;v2PMack		EQU 		1 						; Power manager handshake acknowledge
;v2PMreq		EQU 		2 						; Power manager handshake request
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;reserved7		EQU			7						; reserved

;  ======  Slot Interrupt Flags			Address: $50F26002	 =====
;reserved0		EQU			0						; reserved
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;RvIRQE			EQU 		5 						; slot E interrupt
;RvIRQLCD		EQU			6						; LCD display VBL interrupt
;reserved7		EQU			7						; reserved

;  ======  VIA 2 Interrupt Flags		Address: $50F26003	 =====
;RvSCSIDRQ		EQU			0						; 1 = SCSI DRQ interrupt
;RvAnySlot		EQU			1						; 1 = any slot(0-6).IRQ int
;reserved2		EQU			2						; reserved
;RvSCSIRQ		EQU			3						; 1 = SCSI IRQ interrupt
;RvSndIRQ		EQU			4						; 1 = Apple Sound Chip interrup
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;RvSetClr		EQU			7						; on READ, 1 = any enable interrupt

;  ======  MSC Configuration			Address: $50F26010	 =====
	IF &TYPE('MSC25MHz') = 'UNDEFINED' THEN ; generated for fun
MSC25MHz		EQU			0						; 1 = 25MHz system, 0 = 33MHz system
	ENDIF ; generated for fun
	IF &TYPE('MSCEconoBit') = 'UNDEFINED' THEN ; generated for fun
MSCEconoBit		EQU			1						; 1 = econo-mode enabled (switches to 16MHz)
	ENDIF ; generated for fun
	IF &TYPE('MSCFastROM') = 'UNDEFINED' THEN ; generated for fun
MSCFastROM		EQU			2						; 1 = 100ns ROMs installed, 0 = 120ns ROMs installed
	ENDIF ; generated for fun
;reserved3		EQU			3						; reserved
	IF &TYPE('MSCBank8M') = 'UNDEFINED' THEN ; generated for fun
MSCBank8M		EQU			4						; 1 = banks 4-7 are 8MB, 0=banks 4-7 are 2MB
	ENDIF ; generated for fun
	IF &TYPE('MSCSize0') = 'UNDEFINED' THEN ; generated for fun
MSCSize0		EQU			5						; RAM size bit
	ENDIF ; generated for fun
	IF &TYPE('MSCSize1') = 'UNDEFINED' THEN ; generated for fun
MSCSize1		EQU			6						; RAM size bit
	ENDIF ; generated for fun
	IF &TYPE('MSCSize2') = 'UNDEFINED' THEN ; generated for fun
MSCSize2		EQU			7						; RAM size bit
	ENDIF ; generated for fun

;  ======  Slot Interrupt Enables		Address: $50F26012	 =====
;reserved0		EQU			0						; reserved
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;RvIRQEEn		EQU 		5 						; slot E interrupt enabled
;RvIRQLCDEn		EQU			6						; LCD display VBL interrupt enabled
;RvSetClr		EQU			7						; on READs, always reads 0

;  ======  VIA 2 Interrupt Enables		Address: $50F26013	 =====
;RvSCSIDRQEn	EQU			0						; 1 = SCSI DRQ interrupt enabled
;RvAnySlotEn	EQU			1						; 1 = any slot(0-6).IRQ int. enabled
;reserved2		EQU			2						; reserved
;RvSCSIRQEn		EQU			3						; 1 = SCSI IRQ interrupt enabled
;RvSndIRQEn		EQU			4						; 1 = Apple Sound Chip interrupt enabled
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;RvSetClr		EQU			7						; on READs, always reads 0
													; on WRITEs, 1 = 1-bits in bits 0-6 write 1's
													;  			0 = 1-bits in bits 0-6 write 0's

;  ======  Peripherals Clock Control	Address: $50F26021	 =====
	IF &TYPE('MSCIOClk') = 'UNDEFINED' THEN ; generated for fun
MSCIOClk		EQU			0						; 1=15.6672MHz I/O clock running, 0=stopped
	ENDIF ; generated for fun
	IF &TYPE('MSCSCCClk') = 'UNDEFINED' THEN ; generated for fun
MSCSCCClk		EQU			1						; 1=3.672MHz SCC clock running, 0=stopped
	ENDIF ; generated for fun
	IF &TYPE('MSCSCSIReset') = 'UNDEFINED' THEN ; generated for fun
MSCSCSIReset	EQU			2						; 1=SCSI reset not asserted, 0=reset asserted (clocks stop)
	ENDIF ; generated for fun
	IF &TYPE('MSCLCDReset') = 'UNDEFINED' THEN ; generated for fun
MSCLCDReset		EQU			3						; 1=LCD reset not asserted, 0=reset asserted (clocks stop)
	ENDIF ; generated for fun
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
;reserved6		EQU			6						; reserved
;reserved7		EQU			7						; reserved

;  ======  Sound Control				Address: $50F26022	 =====
	IF &TYPE('MSCSndPower') = 'UNDEFINED' THEN ; generated for fun
MSCSndPower		EQU			0						; 1=DFAC power on, 0=DFAC power off
	ENDIF ; generated for fun
;reserved1		EQU			1						; reserved
;reserved2		EQU			2						; reserved
;reserved3		EQU			3						; reserved
;reserved4		EQU			4						; reserved
;reserved5		EQU			5						; reserved
	IF &TYPE('MSCSndBusy') = 'UNDEFINED' THEN ; generated for fun
MSCSndBusy		EQU			6						; 1=access to FIFO since last access to this register
	ENDIF ; generated for fun
	IF &TYPE('MSCSndLatch') = 'UNDEFINED' THEN ; generated for fun
MSCSndLatch		EQU			7						; 1=DFAC is powered up and initialized
	ENDIF ; generated for fun


	IF &TYPE('MSCDefConfig') = 'UNDEFINED' THEN ; generated for fun
MSCDefConfig	EQU			(1<<MSC25MHz)|\			; 25MHz system								<H9>
							(0<<MSCEconoBit)|\		; econo-mode disabled						<H9>
							(0<<MSCFastROM)|\		; 120ns ROMs installed						<H9>
							(0<<MSCBank8M)|\		; assume 2MB each in banks 4-7				<H19>
							(%000<<MSCSize0)		; set 2MB so there's real RAM for BootBeep	<H10>
	ENDIF ; generated for fun



;__________________________________________________________________________________________
;
;
; Memory Controllers - Register Definitions and Misc Equates for Memory Controllers.  Included
; are: FMC, ORWELL, JAWS, Niagra, Ponti, djMEMC, Pratt
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
;  FMC (Fitch Memory Controller) Equates
;---------------------------------------------------

	IF &TYPE('FMCConfig') = 'UNDEFINED' THEN ; generated for fun
FMCConfig		equ			$0						; offset to configuration register.  It is a 16
	ENDIF ; generated for fun
													; bit wide register with a 1 bit wide data port
													; on d24, so do byte writes (and rotates) and
													; let dynamic bus sizing replicate it on d24-31.

	IF &TYPE('FMCLatch') = 'UNDEFINED' THEN ; generated for fun
FMCLatch		equ			$10						; offset to 'latch config data' register (latches
	ENDIF ; generated for fun
													; on a write to here)
	IF &TYPE('FMCInit') = 'UNDEFINED' THEN ; generated for fun
FMCInit			EQU			$F3EF					; config reg initial value				<4.5><4.6><4.9><1>
	ENDIF ; generated for fun
	IF &TYPE('FMCRPUInit') = 'UNDEFINED' THEN ; generated for fun
FMCRPUInit		EQU			$F3FF					; config reg initial value (parity)		<1>
	ENDIF ; generated for fun


;---------------------------------------------------
;  Orwell Memory Controller Equates	<5>
;---------------------------------------------------

;	Orwell only has one input/output data bit.  So to store or retrieve any configuration register
;	information, you must read/write a succession of long-word addresses, starting at the addresses
;	below, with the ONLY valid data bit being {reg}:0.  Valued being read must be assembled one bit
;	at a time; values being written must be loaded into the config registers 1 bit at a time.  The
;	new config. register values do not become active until a "latch" register address associated
;	with the config. register is written.
;
;	The below addresses correspond to longword addresses where bit 0 of whatever data register used to
;	read/write the location will be stored.  The Orwell configuration register is a 34-bit register,
;	with each bit written to/read by addressing the appropriate longword offset.
;
;	The configuration register can be thought of like this:
;
;		+---------------------------------------------------------------------------------------------+
;		| PAR_ODD | PAR_ENB | REFRESH | ROM_SPEED | DRAM_SPEED | CLK_SPEED | BANK_D | BANK_C | BANK_B |
;		+---------------------------------------------------------------------------------------------+
;			28        27     26     24 23       21  20       19     18      17   12  11    6  5      0
;
;																												<T6>
;		+---------------------------------------------------------------------+									<T6>
;		|    RAS    | Optional WRITE | Optional Read  | Optional Read  | Page |									<T6>
;		| Precharge |   wait state   | 2nd wait state | 1st wait state | Mode |									<T6>
;		+---------------------------------------------------------------------+									<T6>
;			 33            32                31               30          29									<T6>

;			***		Register Offsets	***

	IF &TYPE('OrCfgRegAddr') = 'UNDEFINED' THEN ; generated for fun
OrCfgRegAddr		EQU			0						; starting offset of config reg. bits
	ENDIF ; generated for fun
	IF &TYPE('OrCfgRegSize') = 'UNDEFINED' THEN ; generated for fun
OrCfgRegSize		EQU			34						; number of bits in the configuration register				<T6>
	ENDIF ; generated for fun

	IF &TYPE('OrBankFieldSize') = 'UNDEFINED' THEN ; generated for fun
OrBankFieldSize		EQU			6						; each bank config. reg. field is 6 bits wide
	ENDIF ; generated for fun
	IF &TYPE('OrBankBCfgAddr') = 'UNDEFINED' THEN ; generated for fun
OrBankBCfgAddr		EQU			OrCfgRegAddr			; starting offset of BankB(5:0)
	ENDIF ; generated for fun
	IF &TYPE('OrBankCCfgAddr') = 'UNDEFINED' THEN ; generated for fun
OrBankCCfgAddr		EQU			OrBankBCfgAddr+(4*OrBankFieldSize); starting offset of BankC(5:0)
	ENDIF ; generated for fun
	IF &TYPE('OrBankDCfgAddr') = 'UNDEFINED' THEN ; generated for fun
OrBankDCfgAddr		EQU			OrBankCCfgAddr+(4*OrBankFieldSize); starting offset of BankD(5:0)
	ENDIF ; generated for fun
	IF &TYPE('OrClkSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
OrClkSpeedAddr		EQU			OrBankDCfgAddr+(4*OrBankFieldSize); starting address of Clock_Speed
	ENDIF ; generated for fun
														; ... Clock_Speed is 1 bit (0=25MHz)
	IF &TYPE('OrDRAMSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
OrDRAMSpeedAddr		EQU			OrClkSpeedAddr+4		; starting address of DRAM Speed(1:0)
	ENDIF ; generated for fun
	IF &TYPE('OrDRAMFieldSize') = 'UNDEFINED' THEN ; generated for fun
OrDRAMFieldSize		EQU			2						; DRAM speed config reg. field is 2 bits wide
	ENDIF ; generated for fun
	IF &TYPE('OrROMSpeedAddr') = 'UNDEFINED' THEN ; generated for fun
OrROMSpeedAddr		EQU			OrDRAMSpeedAddr+(4*OrDRAMFieldSize); starting address of ROM Speed(2:0)
	ENDIF ; generated for fun
	IF &TYPE('OrROMFieldSize') = 'UNDEFINED' THEN ; generated for fun
OrROMFieldSize		EQU			3						; ROM speed config reg. field is 3 bits wide
	ENDIF ; generated for fun
	IF &TYPE('OrRefreshAddr') = 'UNDEFINED' THEN ; generated for fun
OrRefreshAddr		EQU			OrROMSpeedAddr+(4*OrROMFieldSize); starting address of Refresh Rate(2:0)
	ENDIF ; generated for fun
	IF &TYPE('OrRefreshSize') = 'UNDEFINED' THEN ; generated for fun
OrRefreshSize		EQU			3						; Refresh speed config reg. field is 3 bits wide
	ENDIF ; generated for fun
	IF &TYPE('OrParityEnbAddr') = 'UNDEFINED' THEN ; generated for fun
OrParityEnbAddr		EQU			OrRefreshAddr+(4*OrRefreshSize); starting address of parity enable/disable
	ENDIF ; generated for fun
														; ... Parity_Enable is 1 bit (0=parity OFF)
	IF &TYPE('OrParityTypAddr') = 'UNDEFINED' THEN ; generated for fun
OrParityTypAddr		EQU			OrParityEnbAddr+4		; starting address of parity type (even/odd)
	ENDIF ; generated for fun
														; ... Parity_Type is 1 bit (0=parity EVEN)
	IF &TYPE('OrPageMode') = 'UNDEFINED' THEN ; generated for fun
OrPageMode			EQU			OrParityTypAddr+4		;															<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrWaitRead1') = 'UNDEFINED' THEN ; generated for fun
OrWaitRead1			EQU			OrPageMode+4			;															<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrWaitRead2') = 'UNDEFINED' THEN ; generated for fun
OrWaitRead2			EQU			OrWaitRead1+4			;															<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrWaitWrite1') = 'UNDEFINED' THEN ; generated for fun
OrWaitWrite1		EQU			OrWaitRead2+4			;															<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrRASPrecharge') = 'UNDEFINED' THEN ; generated for fun
OrRASPrecharge		EQU			OrWaitWrite1+4			;															<T6>
	ENDIF ; generated for fun

	IF &TYPE('OrLatchOffset') = 'UNDEFINED' THEN ; generated for fun
OrLatchOffset		EQU			$A0						; offset from start of config reg. where latches live		<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrwellLatches') = 'UNDEFINED' THEN ; generated for fun
OrwellLatches		EQU			OrCfgRegAddr+OrLatchOffset; starting address of Latch Addresses						<T6>
	ENDIF ; generated for fun

	IF &TYPE('OrLoadBanks') = 'UNDEFINED' THEN ; generated for fun
OrLoadBanks			EQU			OrwellLatches			; Load Bank Config Reg. Latch address						<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrLoadSpeeds') = 'UNDEFINED' THEN ; generated for fun
OrLoadSpeeds		EQU			OrLoadBanks+4			; Load Clock, DRAM and ROM Speeds Latch address
	ENDIF ; generated for fun
	IF &TYPE('OrLoadRefresh') = 'UNDEFINED' THEN ; generated for fun
OrLoadRefresh		EQU			OrLoadSpeeds+4			; Load Refresh interval Latch address
	ENDIF ; generated for fun
	IF &TYPE('OrLoadParity') = 'UNDEFINED' THEN ; generated for fun
OrLoadParity		EQU			OrLoadRefresh+4			; Load Parity enable/disable and type Latch address
	ENDIF ; generated for fun

	IF &TYPE('OrLoadMode') = 'UNDEFINED' THEN ; generated for fun
OrLoadMode			EQU			OrLoadParity+4			; Load Page Mode On/Off address								<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrLoadWaitStates') = 'UNDEFINED' THEN ; generated for fun
OrLoadWaitStates	EQU			OrLoadMode+4			; Load Read/Write extra waitstates address					<T6>
	ENDIF ; generated for fun
	IF &TYPE('OrLoadPrecharge') = 'UNDEFINED' THEN ; generated for fun
OrLoadPrecharge		EQU			OrLoadWaitStates+4		; Load RAS precharge address								<T6>
	ENDIF ; generated for fun

	IF &TYPE('OrParityStatus') = 'UNDEFINED' THEN ; generated for fun
OrParityStatus		EQU			$100					; A0-BC = LS 8 bits, C0-DC   = LM 8 bits					<T6>
	ENDIF ; generated for fun
														; E0-FC = HM 8 bits, 100-11C = MS 8 bits
	IF &TYPE('OrParErrInByte0') = 'UNDEFINED' THEN ; generated for fun
OrParErrInByte0		EQU			$180					; =1 if parity error occurred in byte 0
	ENDIF ; generated for fun
	IF &TYPE('OrParErrInByte1') = 'UNDEFINED' THEN ; generated for fun
OrParErrInByte1		EQU			$184					; =1 if parity error occurred in byte 1
	ENDIF ; generated for fun
	IF &TYPE('OrParityError') = 'UNDEFINED' THEN ; generated for fun
OrParityError		EQU			$188					; =1 if parity error occurred (period)
	ENDIF ; generated for fun

;			***		Initializing Values at Bootup Time		***

	IF &TYPE('ORINITBankB') = 'UNDEFINED' THEN ; generated for fun
ORINITBankB			EQU			$10						; 10=Bank B at 64MB
	ENDIF ; generated for fun
	IF &TYPE('ORINITBankC') = 'UNDEFINED' THEN ; generated for fun
ORINITBankC			EQU			$20						; 20=Bank C at 128MB
	ENDIF ; generated for fun
	IF &TYPE('ORINITBankD') = 'UNDEFINED' THEN ; generated for fun
ORINITBankD			EQU			$30						; 30=Bank D at 192MB
	ENDIF ; generated for fun

	IF &TYPE('ORINITClock25') = 'UNDEFINED' THEN ; generated for fun
ORINITClock25		EQU			1						; 1=25MHz, 0=33MHz											<T12>
	ENDIF ; generated for fun
	IF &TYPE('ORINITClock33') = 'UNDEFINED' THEN ; generated for fun
ORINITClock33		EQU			0						;															<T12>
	ENDIF ; generated for fun
	IF &TYPE('ORINITDRAMSpeed') = 'UNDEFINED' THEN ; generated for fun
ORINITDRAMSpeed		EQU			1						; 0=100ns, 1=80ns, 2=60ns							<10>
	ENDIF ; generated for fun
	IF &TYPE('ORINITROMSpeed25') = 'UNDEFINED' THEN ; generated for fun
ORINITROMSpeed25	EQU			2						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
	ENDIF ; generated for fun
	IF &TYPE('ORINITROMSpeed33') = 'UNDEFINED' THEN ; generated for fun
ORINITROMSpeed33	EQU			4						; *n* = Clock_Access-3 (0 = 3 Clock_Access)					<T6><T12>
	ENDIF ; generated for fun
	IF &TYPE('ORINITREFRESH25') = 'UNDEFINED' THEN ; generated for fun
ORINITREFRESH25		EQU			2						; 0=25MHz 7.8µsec,  1=33MHz, 7.8µsec				<21>	<T12>
	ENDIF ; generated for fun
														; 2=25MHz 15.6µsec, 3=33MHz 15.6µsec				<21>	<T12>
	IF &TYPE('ORINITREFRESH33') = 'UNDEFINED' THEN ; generated for fun
ORINITREFRESH33		EQU			3						;													<21>	<T12>
	ENDIF ; generated for fun
	IF &TYPE('ORINITParity') = 'UNDEFINED' THEN ; generated for fun
ORINITParity		EQU			0						; 0=parity OFF, 1=parity ON
	ENDIF ; generated for fun
	IF &TYPE('ORINITParType') = 'UNDEFINED' THEN ; generated for fun
ORINITParType		EQU			1						; 0=even, 1=odd
	ENDIF ; generated for fun

;	Additional (programmable) wait states for reads and writes

	IF &TYPE('ORINITPageMode') = 'UNDEFINED' THEN ; generated for fun
ORINITPageMode		EQU			0						; 0=off, 1=on												<T6>
	ENDIF ; generated for fun
	IF &TYPE('ORINITWaitRd1') = 'UNDEFINED' THEN ; generated for fun
ORINITWaitRd1		EQU			0						; 0=off, 1=on (unless Rd2 = 1, in which case it is interpreted as off)<T6>
	ENDIF ; generated for fun
	IF &TYPE('ORINITWaitRd2') = 'UNDEFINED' THEN ; generated for fun
ORINITWaitRd2		EQU			0						; 0=off, 1=on (unless Rd1 = 1, in which case it is interpreted as off)<T6>
	ENDIF ; generated for fun
	IF &TYPE('ORINITWaitWr1') = 'UNDEFINED' THEN ; generated for fun
ORINITWaitWr1		EQU			0						; 0=off, 1=on												<T6>
	ENDIF ; generated for fun
	IF &TYPE('ORINITRAS25') = 'UNDEFINED' THEN ; generated for fun
ORINITRAS25			EQU			0						; 0=2 cycles, 1=3 cycles 									<T6>
	ENDIF ; generated for fun
	IF &TYPE('ORINITRAS33') = 'UNDEFINED' THEN ; generated for fun
ORINITRAS33			EQU			1						;															<T12>
	ENDIF ; generated for fun

;	These are 32-bit constants that hold all but 2 bits of the initial defaults we									  .
;	would want to jam into the Orwell configuration register.  These are arranged									  .
;	in order the register is memory-mapped to facilitate the code that sticks them									  .
;	in the register.  There are two bits that don't fit in a 32-bit constant, the									  .
;	optional -OrWaitWrite1- and the not-so-optional -OrRASPrecharge-.  Those values									  .
;	are used and initialized separately.																			  .

	IF &TYPE('ORWELL_INIT25') = 'UNDEFINED' THEN ; generated for fun
ORWELL_INIT25		EQU			\						;															<T6><T12>
								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
								(ORINITParType<<28)|\	; initial parity even/odd value
								(ORINITParity<<27)|\	; initial parity on/off value
								(ORINITREFRESH25<<24)|\	; initial refresh rate value								<T12>
								(ORINITROMSpeed25<<21)|\; initial ROM speed value									<T12>
								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
								(ORINITClock25<<18)|\	; initial clock speed value									<T12>
								(ORINITBankD<<12)|\		; initial Bank D starting address value
								(ORINITBankC<<6)|\		; initial Bank C starting address value
								(ORINITBankB)			; initial Bank B starting address value
	ENDIF ; generated for fun
	IF &TYPE('ORWELL_INIT33') = 'UNDEFINED' THEN ; generated for fun
ORWELL_INIT33		EQU			\						;															<T6><T12> thru next <T12>
								(ORINITWaitRd2<<31)|\	; initial value - are TWO read-related wait states needed? (0=no)<T6>
								(ORINITWaitRd1<<30)|\	; initial value - is  ONE read-related wait state needed? (0=no)<T6>
								(ORINITPageMode<<29)|\	; initial page mode value (OFF)								<T6>
								(ORINITParType<<28)|\	; initial parity even/odd value
								(ORINITParity<<27)|\	; initial parity on/off value
								(ORINITREFRESH33<<24)|\	; initial refresh rate value
								(ORINITROMSpeed33<<21)|\; initial ROM speed value
								(ORINITDRAMSpeed<<19)|\	; initial DRAM speed value
								(ORINITClock33<<18)|\	; initial clock speed value
								(ORINITBankD<<12)|\		; initial Bank D starting address value
								(ORINITBankC<<6)|\		; initial Bank C starting address value
								(ORINITBankB)			; initial Bank B starting address value						<T12>
	ENDIF ; generated for fun


;---------------------------------------------------
; JAWS Memory Controller Equates
;---------------------------------------------------

	IF &TYPE('JAWSRAMWaitS') = 'UNDEFINED' THEN ; generated for fun
JAWSRAMWaitS	EQU			$00000					; RAM wait state control register offset
	ENDIF ; generated for fun
	IF &TYPE('JAWSEconoMode') = 'UNDEFINED' THEN ; generated for fun
JAWSEconoMode	EQU			$04000					; Econo-Mode register offset									<21> HJR
	ENDIF ; generated for fun
	IF &TYPE('JAWSROMWaitS') = 'UNDEFINED' THEN ; generated for fun
JAWSROMWaitS	EQU			$06000					; ROM wait state control register offset
	ENDIF ; generated for fun

	IF &TYPE('JAWSMemConfigA') = 'UNDEFINED' THEN ; generated for fun
JAWSMemConfigA	EQU			$10000					; Contiguous memory (knitting) registers
	ENDIF ; generated for fun
	IF &TYPE('JAWSMemConfigB') = 'UNDEFINED' THEN ; generated for fun
JAWSMemConfigB	EQU			$12000					; Contiguous memory (knitting) registers
	ENDIF ; generated for fun
	IF &TYPE('JAWSMemConfigC') = 'UNDEFINED' THEN ; generated for fun
JAWSMemConfigC	EQU			$14000					; Contiguous memory (knitting) registers
	ENDIF ; generated for fun

	IF &TYPE('JAWSPowerCycle') = 'UNDEFINED' THEN ; generated for fun
JAWSPowerCycle	EQU			$20000					; CPU power off control register
	ENDIF ; generated for fun
	IF &TYPE('JAWSSetCPUClock') = 'UNDEFINED' THEN ; generated for fun
JAWSSetCPUClock	EQU			$22000					; Controls the CPU clock frequency
	ENDIF ; generated for fun
	IF &TYPE('JAWSPCBLevel') = 'UNDEFINED' THEN ; generated for fun
JAWSPCBLevel	EQU			$30000					; Selects between SCC and SCC/SCSI combo
	ENDIF ; generated for fun
	IF &TYPE('JAWSLockRAM') = 'UNDEFINED' THEN ; generated for fun
JAWSLockRAM		EQU			$32000					; Puts RAM in self refresh state
	ENDIF ; generated for fun
	IF &TYPE('JAWSGetCPUClock') = 'UNDEFINED' THEN ; generated for fun
JAWSGetCPUClock	EQU			$34000					; Returns the CPU clock frequency
	ENDIF ; generated for fun

;---------------------------------------------------
; Niagra Memory Controller Equates
;---------------------------------------------------

	IF &TYPE('NiagraVidCntCtr') = 'UNDEFINED' THEN ; generated for fun
NiagraVidCntCtr	EQU			$02000					; Video count options 									<21> HJR
	ENDIF ; generated for fun
	IF &TYPE('NiagraGUR') = 'UNDEFINED' THEN ; generated for fun
NiagraGUR		EQU			$16000					; General Utility Registers (ponti register access)<SM4> rb
	ENDIF ; generated for fun
	IF &TYPE('NiagraVidAcc1') = 'UNDEFINED' THEN ; generated for fun
NiagraVidAcc1	EQU			$22000					; Video Accesses thru 64
	ENDIF ; generated for fun
	IF &TYPE('NiagraVidAcc2') = 'UNDEFINED' THEN ; generated for fun
NiagraVidAcc2	EQU			$24000					; Video Accesses thru 512
	ENDIF ; generated for fun
	IF &TYPE('NiagraVidAcc3') = 'UNDEFINED' THEN ; generated for fun
NiagraVidAcc3	EQU			$26000					; Video Accesses thru 2K
	ENDIF ; generated for fun
	IF &TYPE('NiagraFlashEnbl') = 'UNDEFINED' THEN ; generated for fun
NiagraFlashEnbl	EQU			$30000					; Enable flash from Niagra
	ENDIF ; generated for fun
	IF &TYPE('NiagraFPUAcc') = 'UNDEFINED' THEN ; generated for fun
NiagraFPUAcc	EQU			$34000					; FPU access detected
	ENDIF ; generated for fun
	IF &TYPE('NiagraSpeedReg') = 'UNDEFINED' THEN ; generated for fun
NiagraSpeedReg	EQU			$36000					; Returns the CPU clock frequency
	ENDIF ; generated for fun

;---------------------------------------------------								<SM4> rb, start
; Ponti Register Equates  (NiagraGUR register space + offset
;---------------------------------------------------

	IF &TYPE('PontiSPIMdmCtl') = 'UNDEFINED' THEN ; generated for fun
PontiSPIMdmCtl		EQU			$000
	ENDIF ; generated for fun
	IF &TYPE('PontiSndCtl') = 'UNDEFINED' THEN ; generated for fun
PontiSndCtl			EQU			$400
	ENDIF ; generated for fun
	IF &TYPE('PontiSPISftReg') = 'UNDEFINED' THEN ; generated for fun
PontiSPISftReg		EQU			$800
	ENDIF ; generated for fun
	IF &TYPE('PontiLmpSftCtl') = 'UNDEFINED' THEN ; generated for fun
PontiLmpSftCtl		EQU			$C00
	ENDIF ; generated for fun

; Ponti PontiSPIMdmCtl bit definitions
	IF &TYPE('PontiSPIMdmId') = 'UNDEFINED' THEN ; generated for fun
PontiSPIMdmId		EQU			0				; (1 = SPI modem connected)
	ENDIF ; generated for fun
	IF &TYPE('PontiSPIAck') = 'UNDEFINED' THEN ; generated for fun
PontiSPIAck			EQU			2				; (1 = ack idle)
	ENDIF ; generated for fun
	IF &TYPE('PontiSPIReq') = 'UNDEFINED' THEN ; generated for fun
PontiSPIReq			EQU			3				; (1 = req idle)
	ENDIF ; generated for fun
	IF &TYPE('PontiSPIIrq') = 'UNDEFINED' THEN ; generated for fun
PontiSPIIrq			EQU			4				; (1 = interrupting)
	ENDIF ; generated for fun

; Ponti PontiSoundCtl bit definitions
	IF &TYPE('PontiSndSPIIrqMsk') = 'UNDEFINED' THEN ; generated for fun
PontiSndSPIIrqMsk	EQU			0				; (1 = mask int)			- irq mask for PontiSPIIrq
	ENDIF ; generated for fun
	IF &TYPE('PontiSndIntMic') = 'UNDEFINED' THEN ; generated for fun
PontiSndIntMic		EQU			1				; (1 = using internal mic)	- flag to check which mike is used	<H22>
	ENDIF ; generated for fun
	IF &TYPE('PontiSndLatchClr') = 'UNDEFINED' THEN ; generated for fun
PontiSndLatchClr	EQU			2				; (pulse high to clear)		- line directly to latch
	ENDIF ; generated for fun
	IF &TYPE('PontiSndLatchData') = 'UNDEFINED' THEN ; generated for fun
PontiSndLatchData	EQU			3				; (1 = snd ckt used)		- output value of the sound latch
	ENDIF ; generated for fun
	IF &TYPE('PontiSndPWMOff') = 'UNDEFINED' THEN ; generated for fun
PontiSndPWMOff		EQU			4				; (1 = PWM off)				- ultimate off to remove "pop"
	ENDIF ; generated for fun
	IF &TYPE('PontiSndPwrOn') = 'UNDEFINED' THEN ; generated for fun
PontiSndPwrOn		EQU			5				; (1 = power snd ckt)		- sw equal of latch output
	ENDIF ; generated for fun
	IF &TYPE('PontiSndMux0') = 'UNDEFINED' THEN ; generated for fun
PontiSndMux0		EQU			6				; (1 = ???)
	ENDIF ; generated for fun
	IF &TYPE('PontiSndMux1') = 'UNDEFINED' THEN ; generated for fun
PontiSndMux1		EQU			7				; (1 = modem sound {regardless of Mux0})
	ENDIF ; generated for fun

; Ponti PontiLmpSftCtl bit definitions
	IF &TYPE('PontiLmpOff') = 'UNDEFINED' THEN ; generated for fun
PontiLmpOff			EQU			0				; (1 = backlight on) 		- turn on the backlight tube
	ENDIF ; generated for fun
	IF &TYPE('PontiLmpHWCtl') = 'UNDEFINED' THEN ; generated for fun
PontiLmpHWCtl		EQU			1				; (1 = Hardware control) 	- if set, hardware control loop
	ENDIF ; generated for fun
	IF &TYPE('PontiLmpMux0') = 'UNDEFINED' THEN ; generated for fun
PontiLmpMux0		EQU			2				; (1 = 1/2 pot) 			- 1/2 scale pot reduction
	ENDIF ; generated for fun
	IF &TYPE('PontiLmpMux1') = 'UNDEFINED' THEN ; generated for fun
PontiLmpMux1		EQU			3				; (1 = 1/4 pot) 			- 1/4 scale pot reduction
	ENDIF ; generated for fun
	IF &TYPE('PontiLmpSPIDir') = 'UNDEFINED' THEN ; generated for fun
PontiLmpSPIDir		EQU			4				; (1 = shift out) 			- direction of shift register
	ENDIF ; generated for fun
												;									<SM4> rb, end
;-------------------------------------																		<H21> thru next <H21>
;	djMEMC memory controller equates
;-------------------------------------

;	This hard-coded I/O address is in here because there is no more room in the
;	Universal tables to hold this information.

	IF &TYPE('MEMCAddr') = 'UNDEFINED' THEN ; generated for fun
MEMCAddr			EQU		$50F0E000				; same for both Wombat + WLCD memory maps
	ENDIF ; generated for fun

	IF &TYPE('MEMCRegisterStart') = 'UNDEFINED' THEN ; generated for fun
MEMCRegisterStart	EQU		0
	ENDIF ; generated for fun
	IF &TYPE('MEMCIntleaveEnable') = 'UNDEFINED' THEN ; generated for fun
MEMCIntleaveEnable	EQU		MEMCRegisterStart		; DRAM interleave enable reg.
	ENDIF ; generated for fun
	IF &TYPE('dj_OneBufferedBusBit') = 'UNDEFINED' THEN ; generated for fun
dj_OneBufferedBusBit EQU	5
	ENDIF ; generated for fun
;	djMEMC supports up to a maximum of 10 (TEN) DRAM banks
	IF &TYPE('dj_MaxBanks') = 'UNDEFINED' THEN ; generated for fun
dj_MaxBanks			EQU		10						;														<H22>
	ENDIF ; generated for fun

	IF &TYPE('MEMCDRAMCfg0') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg0		EQU		MEMCIntleaveEnable+4	; Bank 0 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg1') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg1		EQU		MEMCDRAMCfg0+4			; Bank 1 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg2') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg2		EQU		MEMCDRAMCfg1+4			; Bank 2 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg3') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg3		EQU		MEMCDRAMCfg2+4			; Bank 3 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg4') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg4		EQU		MEMCDRAMCfg3+4			; Bank 4 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg5') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg5		EQU		MEMCDRAMCfg4+4			; Bank 5 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg6') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg6		EQU		MEMCDRAMCfg5+4			; Bank 6 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg7') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg7		EQU		MEMCDRAMCfg6+4			; Bank 7 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg8') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg8		EQU		MEMCDRAMCfg7+4			; Bank 8 cfg reg
	ENDIF ; generated for fun
	IF &TYPE('MEMCDRAMCfg9') = 'UNDEFINED' THEN ; generated for fun
MEMCDRAMCfg9		EQU		MEMCDRAMCfg8+4			; Bank 9 cfg reg
	ENDIF ; generated for fun

	IF &TYPE('MEMCmemTop') = 'UNDEFINED' THEN ; generated for fun
MEMCmemTop			EQU		MEMCDRAMCfg9+4			; Top of stitched RAM
	ENDIF ; generated for fun
	IF &TYPE('MEMCconfig') = 'UNDEFINED' THEN ; generated for fun
MEMCconfig			EQU		MEMCmemTop+4			; "Multiple bit DRAM/ROM configuration register"
	ENDIF ; generated for fun
	IF &TYPE('MEMCRefresh') = 'UNDEFINED' THEN ; generated for fun
MEMCRefresh			EQU		MEMCconfig+4			; DRAM refresh rate register
	ENDIF ; generated for fun


;__________________________________________________________________________________________
;
;
; Interrupt Vector Definitions and Masks
;
;
;__________________________________________________________________________________________



;---------------------------------------------------
; Interrupt Masks
;---------------------------------------------------

	IF &TYPE('hiIntMask') = 'UNDEFINED' THEN ; generated for fun
hiIntMask 		EQU 		$0700					; programmer switch only
	ENDIF ; generated for fun
	IF &TYPE('pwrOffEnbl') = 'UNDEFINED' THEN ; generated for fun
pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts
	ENDIF ; generated for fun
	IF &TYPE('sccIntMask') = 'UNDEFINED' THEN ; generated for fun
sccIntMask		EQU 		$0400					; SCC interrupt level
	ENDIF ; generated for fun
	IF &TYPE('sccEnblMask') = 'UNDEFINED' THEN ; generated for fun
sccEnblMask   	EQU 		$FBFF					; mask to enable SCC interrupts
	ENDIF ; generated for fun
	IF &TYPE('slotIntMask') = 'UNDEFINED' THEN ; generated for fun
slotIntMask   	EQU 		$0200		   			; slot's interrupt level	<v1.4><1.9>
	ENDIF ; generated for fun
	IF &TYPE('viaIntMask') = 'UNDEFINED' THEN ; generated for fun
viaIntMask		EQU 		$0100					; VIA1 interrupt level
	ENDIF ; generated for fun
	IF &TYPE('loIntMask') = 'UNDEFINED' THEN ; generated for fun
loIntMask 		EQU 		$0100
	ENDIF ; generated for fun


;---------------------------------------------------
; Hardware Base Addresses
;---------------------------------------------------

	IF &TYPE('WrOffs') = 'UNDEFINED' THEN ; generated for fun
WrOffs			EQU			0						; SCSI write addrs are same as read base
	ENDIF ; generated for fun
	IF &TYPE('MskIOP1') = 'UNDEFINED' THEN ; generated for fun
MskIOP1			EQU			1						; IOP 1 (SWIM) is level 1 interrupt
	ENDIF ; generated for fun
	IF &TYPE('MskVIA1') = 'UNDEFINED' THEN ; generated for fun
MskVIA1			EQU			1						; VIA 1 is level 1
	ENDIF ; generated for fun
	IF &TYPE('MskADB') = 'UNDEFINED' THEN ; generated for fun
MskADB			EQU			1						; ADB is level 1
	ENDIF ; generated for fun
	IF &TYPE('Msk60Hz') = 'UNDEFINED' THEN ; generated for fun
Msk60Hz			EQU			1						; 60 Hz is level 1
	ENDIF ; generated for fun
	IF &TYPE('MskSCSI') = 'UNDEFINED' THEN ; generated for fun
MskSCSI			EQU			2						; SCSI is level 2
	ENDIF ; generated for fun
	IF &TYPE('MskSound') = 'UNDEFINED' THEN ; generated for fun
MskSound		EQU			2						; sound is level 2						<4.5>
	ENDIF ; generated for fun
	IF &TYPE('MskSlots') = 'UNDEFINED' THEN ; generated for fun
MskSlots		EQU			2						; slots are level 2 interrupts
	ENDIF ; generated for fun
	IF &TYPE('MskRTC') = 'UNDEFINED' THEN ; generated for fun
MskRTC			EQU			3						; RTC is level 3
	ENDIF ; generated for fun
	IF &TYPE('MskIOP0') = 'UNDEFINED' THEN ; generated for fun
MskIOP0			EQU			4						; IOP 0 (& SCC chip) is level 4
	ENDIF ; generated for fun
	IF &TYPE('MskPwrOff') = 'UNDEFINED' THEN ; generated for fun
MskPwrOff		EQU			6						; Poweroff button is level 6
	ENDIF ; generated for fun
	IF &TYPE('MskNMI') = 'UNDEFINED' THEN ; generated for fun
MskNMI			EQU			7						; NMI switch is level 7
	ENDIF ; generated for fun


; ---------------------------------------------------------------------------------------------------	<T8>
;		Bit definitions for the Cache Control Register (CACR) on various CPUs							<T8>
; ---------------------------------------------------------------------------------------------------	<T8>
;
;	020 CACR:		(from MC68020 User's Manual, 3rd Ed.  pg. 6-3)										<T8>
;			+------------------------------------------------+											<T8>
;			|  0  ..............  0 |  C  |  CE  |  F  |  E  |											<T8>
;			+------------------------------------------------+											<T8>
;			  31                  4    3      2     1     0												<T8>
;
;				C   =  Clear Cache																		<T8>
;				CE  =  Clear Entry																		<T8>
;				F   =  Freeze Cache																		<T8>
;				E   =  Enable (Inst.) Cache																<T8>
;
;
;	030 CACR:		(from MC68030 User's Manual, 2nd Ed.  pg 6-15)										<T8>
;			+------------------------------------------------------------------------------------+		<T8>
;			|  0  ...  0  | WA | DBE | CD | CED | FD | ED | 0 | 0 | 0 | IBE | CI | CEI | FI | EI |		<T8>
;			+------------------------------------------------------------------------------------+		<T8>
;			 31       14    13    12   11    10    9    8   7   6   5    4    3     2    1     0		<T8>
;
;				WA  =	Write Allocate																	<T8>
;				DBE =	Data Burst Allocate																<T8>
;				CD	=	Clear Data Cache																<T8>
;				CED	=	Clear Entry in Data Cache														<T8>
;				FD	=	Freeze Data Cache																<T8>
;				ED	=	Enable Data Cache																<T8>
;				IBE	=	Instruction Burst Enable														<T8>
;				CI	=	Clear Instruction Cache															<T8>
;				CEI	=	Clear Entry in Instruction Cache												<T8>
;				FI	=	Freeze Instruction Cache														<T8>
;				EI	=	Enable Instruction Cache														<T8>
;
;
;	040 CACR:		(from MC68040 User's Manual, 1st Ed.,  pg. 7-19)									<T8>
;			+-------------------------------------+														<T8>
;			|  DE  |  0 ... 0  |  IE  |  0 ... 0  |														<T8>
;			+-------------------------------------+														<T8>
;			   31    30     16    15    14     0														<T8>
;
;				DE	=	Enable Data Cache																<T8>
;				IE	=	Enable Instruction Cache														<T8>
;

;	MC68040 CACR bits of note:

	IF &TYPE('CACR_IE_040') = 'UNDEFINED' THEN ; generated for fun
CACR_IE_040				EQU		15				; bit # of instruction cache enable/disable on 040s		<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_DE_040') = 'UNDEFINED' THEN ; generated for fun
CACR_DE_040				EQU		31				; bit # of data cache enable/disable on 040s			<T8>
	ENDIF ; generated for fun

;	MC68020 and MC68030 CACR bits of note:

	IF &TYPE('CACR_EI_020_030') = 'UNDEFINED' THEN ; generated for fun
CACR_EI_020_030			EQU		0				; bit # of inst. cache enable/disable on 020/030s		<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_FI_020_030') = 'UNDEFINED' THEN ; generated for fun
CACR_FI_020_030			EQU		1				; bit # of inst. cache freeze on 020/030s				<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_CEI_020_030') = 'UNDEFINED' THEN ; generated for fun
CACR_CEI_020_030		EQU		2				; bit # of inst. cache flush entry on 020/030s			<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_CI_020_030') = 'UNDEFINED' THEN ; generated for fun
CACR_CI_020_030			EQU		3				; bit # of inst. cache flush on 020/030s				<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_IBE_030') = 'UNDEFINED' THEN ; generated for fun
CACR_IBE_030			EQU		4				; bit # of data cache burst enable on 030s				<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_ED_030') = 'UNDEFINED' THEN ; generated for fun
CACR_ED_030				EQU		8				; bit # of data cache enable/disable on 030s			<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_FD_030') = 'UNDEFINED' THEN ; generated for fun
CACR_FD_030				EQU		9				; bit # of data cache freeze on 030s					<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_CED_030') = 'UNDEFINED' THEN ; generated for fun
CACR_CED_030			EQU		10				; bit # of data cache flush entry on 030s				<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_CD_030') = 'UNDEFINED' THEN ; generated for fun
CACR_CD_030				EQU		11				; bit # of data cache flush on 030s						<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_DBE_030') = 'UNDEFINED' THEN ; generated for fun
CACR_DBE_030			EQU		12				; bit # of data cache burst enable on 030s				<T8>
	ENDIF ; generated for fun
	IF &TYPE('CACR_WA_030') = 'UNDEFINED' THEN ; generated for fun
CACR_WA_030				EQU		13				; bit # of write allocate enable on 030s				<T8>
	ENDIF ; generated for fun

;__________________________________________________________________________________________
;
;
; Miscellaneous Equates - Look Here If You Can't Find It Anywhere Else.
;
;
;__________________________________________________________________________________________



	IF &TYPE('Machine') = 'UNDEFINED' THEN ; generated for fun
Machine   		EQU 		7						; new Machine number for patches			<18>
	ENDIF ; generated for fun

;---------------------------------------------------
; System Software Information
;---------------------------------------------------

	IF &TYPE('numOsTrap') = 'UNDEFINED' THEN ; generated for fun
numOsTrap 		EQU 		256   					; number of os traps
	ENDIF ; generated for fun
	IF &TYPE('ToolTable') = 'UNDEFINED' THEN ; generated for fun
ToolTable 		EQU 		$0E00 					; start of toolbox trap table
	ENDIF ; generated for fun
	IF &TYPE('numTbTrap') = 'UNDEFINED' THEN ; generated for fun
numTbTrap 		EQU 		1024   					; number of toolbox traps
	ENDIF ; generated for fun
	IF &TYPE('numTrapMask') = 'UNDEFINED' THEN ; generated for fun
numTrapMask   	EQU 		numTbTrap-1				; mask for number of tb traps
	ENDIF ; generated for fun
	IF &TYPE('JMemMgr24') = 'UNDEFINED' THEN ; generated for fun
JMemMgr24		EQU			$1E00					; jump vector start for 24 bit Memory Manager 		<v1.9>
	ENDIF ; generated for fun
	IF &TYPE('JMemMgr32') = 'UNDEFINED' THEN ; generated for fun
JMemMgr32		EQU			$1F00					; jump vector start for 32 bit Memory Manager 		<v1.9>
	ENDIF ; generated for fun
	IF &TYPE('HeapStart') = 'UNDEFINED' THEN ; generated for fun
HeapStart 		EQU 		$2800 					; Low mem is now 10k bytes							<SM13>
	ENDIF ; generated for fun
	IF &TYPE('defSysHeap') = 'UNDEFINED' THEN ; generated for fun
defSysHeap		EQU 		$18000    				; Default size of the system heap
	ENDIF ; generated for fun
	IF &TYPE('nDfltStackSize') = 'UNDEFINED' THEN ; generated for fun
nDfltStackSize	EQU 		$6000 					; Default stack size
	ENDIF ; generated for fun

**** maybe not so temporary to allow things to build ****									<3.5>
	IF &TYPE('oneSecConst') = 'UNDEFINED' THEN ; generated for fun
oneSecConst   	EQU 		8 						; gets converted to $80000 for onesec constant<3.5>
	ENDIF ; generated for fun
	IF BlackBirdDebug THEN
	IF &TYPE('ROMStart') = 'UNDEFINED' THEN ; generated for fun
ROMStart  		EQU 		$40000000 				; ••PN BlackBirdstarting address of final ROM code	<3.5>
	ENDIF ; generated for fun
	ELSE
	IF &TYPE('ROMStart') = 'UNDEFINED' THEN ; generated for fun
ROMStart  		EQU 		$40800000 				; starting address of final ROM code	<3.5>
	ENDIF ; generated for fun
	ENDIF
	IF &TYPE('snd2MemTop') = 'UNDEFINED' THEN ; generated for fun
snd2MemTop		EQU 		$300  					; SoundLow to Memtop
	ENDIF ; generated for fun
	IF &TYPE('pwm2MemTop') = 'UNDEFINED' THEN ; generated for fun
pwm2MemTop		EQU 		$2FF  					; PWMBuffer to MemTop
	ENDIF ; generated for fun
	IF &TYPE('bufWorldSize') = 'UNDEFINED' THEN ; generated for fun
bufWorldSize  	EQU 		8192		   			; total size of the BufPtr world		<H16>
	ENDIF ; generated for fun

;---------------------------------------------------								<SM4> rb, start
;  Sound parameters																			<P4>
;---------------------------------------------------
	IF &TYPE('sampleSize') = 'UNDEFINED' THEN ; generated for fun
sampleSize		equ			4				; number of bytes per sample
	ENDIF ; generated for fun
	IF &TYPE('bufferSize') = 'UNDEFINED' THEN ; generated for fun
bufferSize		equ			960				; number of samples per buffer
	ENDIF ; generated for fun
	IF &TYPE('sampleRate') = 'UNDEFINED' THEN ; generated for fun
sampleRate		equ			24 * 1024		; 24KHz sample rate
	ENDIF ; generated for fun

;---------------------------------------------------
;  PSC Hardware Defs
;---------------------------------------------------

; === Hardware Base Addresses ===
	IF &TYPE('PSCBase') = 'UNDEFINED' THEN ; generated for fun
PSCBase			equ			$50f31000		; Base address of the PSC
	ENDIF ; generated for fun

;---------------------------------------------------
;  PSC Sound Register Offsets
;---------------------------------------------------
	IF &TYPE('sndComCtl') = 'UNDEFINED' THEN ; generated for fun
sndComCtl		equ			$200			; [word] sound and communications control
	ENDIF ; generated for fun
	IF &TYPE('singerCtl') = 'UNDEFINED' THEN ; generated for fun
singerCtl		equ			$204			; [long] singer sound CODEC control
	ENDIF ; generated for fun
	IF &TYPE('singerStat') = 'UNDEFINED' THEN ; generated for fun
singerStat		equ			$208			; [long] singer sound CODEC status  (read only)
	ENDIF ; generated for fun
	IF &TYPE('sndPhase') = 'UNDEFINED' THEN ; generated for fun
sndPhase		equ			$20c			; [long] sound subsystem phase  (read only)
	ENDIF ; generated for fun
	IF &TYPE('sndInBase') = 'UNDEFINED' THEN ; generated for fun
sndInBase		equ			$210			; [long] sound input double-buffer base address
	ENDIF ; generated for fun
	IF &TYPE('sndOutBase') = 'UNDEFINED' THEN ; generated for fun
sndOutBase		equ			$214			; [long] sound output double buffer base address
	ENDIF ; generated for fun
	IF &TYPE('sndSize') = 'UNDEFINED' THEN ; generated for fun
sndSize			equ			$218			; [word] sound input and output buffer size
	ENDIF ; generated for fun
	IF &TYPE('dspOverRun') = 'UNDEFINED' THEN ; generated for fun
dspOverRun		equ			$21C			; [byte] DSP overrun status register.
	ENDIF ; generated for fun

;---------------------------------------------------
;  PSC Sound Register Bit Definitions
;---------------------------------------------------
; === sndComCtl register ===
	IF &TYPE('pSubFrmInSel') = 'UNDEFINED' THEN ; generated for fun
pSubFrmInSel	equ			0				; singer sound CODEC input subframe select
	ENDIF ; generated for fun
	IF &TYPE('pSubFrmInSel1') = 'UNDEFINED' THEN ; generated for fun
pSubFrmInSel1	equ			0				; singer sound CODEC input subframe select, lsbit
	ENDIF ; generated for fun
	IF &TYPE('pSubFrmInSel2') = 'UNDEFINED' THEN ; generated for fun
pSubFrmInSel2	equ			1				; singer sound CODEC input subframe select, msbit
	ENDIF ; generated for fun

	IF &TYPE('pSubFrmOutSel') = 'UNDEFINED' THEN ; generated for fun
pSubFrmOutSel	equ			2				; singer sound CODEC output subframe select
	ENDIF ; generated for fun
	IF &TYPE('pSubFrmOutSel1') = 'UNDEFINED' THEN ; generated for fun
pSubFrmOutSel1	equ			2				; singer sound CODEC output subframe select, lsbit
	ENDIF ; generated for fun
	IF &TYPE('pSubFrmOutSel2') = 'UNDEFINED' THEN ; generated for fun
pSubFrmOutSel2	equ			3				; singer sound CODEC output subframe select
	ENDIF ; generated for fun
	IF &TYPE('pSubFrmOutSel3') = 'UNDEFINED' THEN ; generated for fun
pSubFrmOutSel3	equ			4				; singer sound CODEC output subframe select
	ENDIF ; generated for fun
	IF &TYPE('pSubFrmOutSel4') = 'UNDEFINED' THEN ; generated for fun
pSubFrmOutSel4	equ			5				; singer sound CODEC output subframe select, msbit
	ENDIF ; generated for fun

	IF &TYPE('pFrmIntEn') = 'UNDEFINED' THEN ; generated for fun
pFrmIntEn		equ			6				; frame interrupt enable
	ENDIF ; generated for fun
	IF &TYPE('pSndInEn') = 'UNDEFINED' THEN ; generated for fun
pSndInEn		equ			7				; sound input DMA enable
	ENDIF ; generated for fun
	IF &TYPE('pSndOutEn') = 'UNDEFINED' THEN ; generated for fun
pSndOutEn		equ			8				; sound output DMA enable
	ENDIF ; generated for fun

	IF &TYPE('pSndRate') = 'UNDEFINED' THEN ; generated for fun
pSndRate		equ			9				; singer sound CODEC sampling rate control
	ENDIF ; generated for fun
	IF &TYPE('pSndRate1') = 'UNDEFINED' THEN ; generated for fun
pSndRate1		equ			9				; singer sound CODEC sampling rate control, lsbit
	ENDIF ; generated for fun
	IF &TYPE('pSndRate2') = 'UNDEFINED' THEN ; generated for fun
pSndRate2		equ			10				; singer sound CODEC sampling rate control, msbit
	ENDIF ; generated for fun

	IF &TYPE('pComRate') = 'UNDEFINED' THEN ; generated for fun
pComRate		equ			11				; communications CODEC sampling rate contrl
	ENDIF ; generated for fun
	IF &TYPE('pComRate1') = 'UNDEFINED' THEN ; generated for fun
pComRate1		equ			11				; communications CODEC sampling rate contrl, lsbit
	ENDIF ; generated for fun
	IF &TYPE('pComRate2') = 'UNDEFINED' THEN ; generated for fun
pComRate2		equ			12				; communications CODEC sampling rate contrl, msbit
	ENDIF ; generated for fun
;				equ			13				; unused
;				equ			14				; unused
;				equ			15				; unused


	IF &TYPE('sndComCtlInit') = 'UNDEFINED' THEN ; generated for fun
sndComCtlInit 	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
							(0<<pSubFrmOutSel)|\	; Ouput subframe zero selected
							(0<<pFrmIntEn)|\		; frame interrupts disabled
							(0<<pSndInEn)|\			; sound input disabled
							(0<<pSndOutEn)|\		; sound output disabled
							(0<<pSndRate)|\			; 24KHz sampling rate selected
							(0<<pComRate)			; communications CODEC, we just don't care
	ENDIF ; generated for fun

	IF &TYPE('soundOutEnable') = 'UNDEFINED' THEN ; generated for fun
soundOutEnable	equ 		(0<<pSubFrmInSel)|\		; Input subframe zero selected
							(1<<pSubFrmOutSel)|\	; Ouput subframe zero selected
							(0<<pFrmIntEn)|\		; frame interrupts enabled
							(0<<pSndInEn)|\			; sound input disabled
							(1<<pSndOutEn)|\		; sound output disabled
							(0<<pSndRate)|\			; 24KHz sampling rate selected
							(0<<pComRate)			; communications CODEC, we just don't care
	ENDIF ; generated for fun



; === singerCtl register ===
	IF &TYPE('pOutputPort') = 'UNDEFINED' THEN ; generated for fun
pOutputPort	equ			0					; set digital output port
	ENDIF ; generated for fun
	IF &TYPE('pOutputPort1') = 'UNDEFINED' THEN ; generated for fun
pOutputPort1	equ			0				; set digital output port, lsb
	ENDIF ; generated for fun
	IF &TYPE('pOutputPort2') = 'UNDEFINED' THEN ; generated for fun
pOutputPort2	equ			1				; set digital output port
	ENDIF ; generated for fun
	IF &TYPE('pOutputPort3') = 'UNDEFINED' THEN ; generated for fun
pOutputPort3	equ			2				; set digital output port
	ENDIF ; generated for fun
	IF &TYPE('pOutputPort4') = 'UNDEFINED' THEN ; generated for fun
pOutputPort4	equ			3				; set digital output port, msb
	ENDIF ; generated for fun

	IF &TYPE('pRightAtten') = 'UNDEFINED' THEN ; generated for fun
pRightAtten		equ			4				; right ouput attenutaion
	ENDIF ; generated for fun
	IF &TYPE('pRightAtten1') = 'UNDEFINED' THEN ; generated for fun
pRightAtten1	equ			4				; right ouput attenutaion, lsb
	ENDIF ; generated for fun
	IF &TYPE('pRightAtten2') = 'UNDEFINED' THEN ; generated for fun
pRightAtten2	equ			5				; right ouput attenutaion
	ENDIF ; generated for fun
	IF &TYPE('pRightAtten3') = 'UNDEFINED' THEN ; generated for fun
pRightAtten3	equ			6				; right ouput attenutaion
	ENDIF ; generated for fun
	IF &TYPE('pRightAtten4') = 'UNDEFINED' THEN ; generated for fun
pRightAtten4	equ			7				; right ouput attenutaion, msb
	ENDIF ; generated for fun

	IF &TYPE('pLeftAtten') = 'UNDEFINED' THEN ; generated for fun
pLeftAtten		equ			8				; Left ouput attenutaion
	ENDIF ; generated for fun
	IF &TYPE('pLeftAtten1') = 'UNDEFINED' THEN ; generated for fun
pLeftAtten1		equ			8				; Left ouput attenutaion, lsb
	ENDIF ; generated for fun
	IF &TYPE('pLeftAtten2') = 'UNDEFINED' THEN ; generated for fun
pLeftAtten2		equ			9				; Left ouput attenutaion
	ENDIF ; generated for fun
	IF &TYPE('pLeftAtten3') = 'UNDEFINED' THEN ; generated for fun
pLeftAtten3		equ			10				; Left ouput attenutaion
	ENDIF ; generated for fun
	IF &TYPE('pLeftAtten4') = 'UNDEFINED' THEN ; generated for fun
pLeftAtten4		equ			11				; Left ouput attenutaion, msb
	ENDIF ; generated for fun

	IF &TYPE('pRightGain') = 'UNDEFINED' THEN ; generated for fun
pRightGain		equ			12				; right input gain
	ENDIF ; generated for fun
	IF &TYPE('pRightGain1') = 'UNDEFINED' THEN ; generated for fun
pRightGain1		equ			12				; right input gain, lsb
	ENDIF ; generated for fun
	IF &TYPE('pRightGain2') = 'UNDEFINED' THEN ; generated for fun
pRightGain2		equ			13				; right input gain
	ENDIF ; generated for fun
	IF &TYPE('pRightGain3') = 'UNDEFINED' THEN ; generated for fun
pRightGain3		equ			14				; right input gain
	ENDIF ; generated for fun
	IF &TYPE('pRightGain4') = 'UNDEFINED' THEN ; generated for fun
pRightGain4		equ			15				; right input gain, msb
	ENDIF ; generated for fun

	IF &TYPE('pLeftGain') = 'UNDEFINED' THEN ; generated for fun
pLeftGain		equ			16				; left input gain
	ENDIF ; generated for fun
	IF &TYPE('pLeftGain1') = 'UNDEFINED' THEN ; generated for fun
pLeftGain1		equ			16				; left input gain, lsb
	ENDIF ; generated for fun
	IF &TYPE('pLeftGain2') = 'UNDEFINED' THEN ; generated for fun
pLeftGain2		equ			17				; left input gain
	ENDIF ; generated for fun
	IF &TYPE('pLeftGain3') = 'UNDEFINED' THEN ; generated for fun
pLeftGain3		equ			18				; left input gain
	ENDIF ; generated for fun
	IF &TYPE('pLeftGain4') = 'UNDEFINED' THEN ; generated for fun
pLeftGain4		equ			19				; left input gain, msb
	ENDIF ; generated for fun

	IF &TYPE('pRightInMux') = 'UNDEFINED' THEN ; generated for fun
pRightInMux		equ			20				; right input mux
	ENDIF ; generated for fun
	IF &TYPE('pLeftInMux') = 'UNDEFINED' THEN ; generated for fun
pLeftInMux		equ			21				; left input mux
	ENDIF ; generated for fun
	IF &TYPE('pMute') = 'UNDEFINED' THEN ; generated for fun
pMute			equ			22				; mute bit
	ENDIF ; generated for fun
	IF &TYPE('pExpCtl') = 'UNDEFINED' THEN ; generated for fun
pExpCtl			equ			23				; expand bit for control
	ENDIF ; generated for fun
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused

	IF &TYPE('singerCtlInit') = 'UNDEFINED' THEN ; generated for fun
singerCtlInit	equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
							(0<<pRightAtten)|\		; right output attenuation set to zero
							(0<<pLeftAtten)|\		; left output attenuation set to zero
							(%0101<<pRightGain)|\	; right input gain set to middle
							(%0101<<pLeftGain)|\	; left input gain set to middle
							(0<<pRightInMux)|\		; input muxes irrelevant
							(0<<pLeftInMux)|\		;
							(1<<pMute)|\			; mute ON
							(0<<pExpCtl)			; no expand
	ENDIF ; generated for fun

	IF &TYPE('unMute') = 'UNDEFINED' THEN ; generated for fun
unMute			equ			(%1111<<pOutputPort)|\	; digitial ouput ports selected
							(0<<pRightAtten)|\		; right output attenuation set to zero
							(0<<pLeftAtten)|\		; left output attenuation set to zero
							(%0101<<pRightGain)|\	; right input gain set to middle
							(%0101<<pLeftGain)|\	; left input gain set to middle
							(0<<pRightInMux)|\		; input muxes irrelevant
							(0<<pLeftInMux)|\		;
							(0<<pMute)|\			; mute OFF
							(0<<pExpCtl)			; no expand
	ENDIF ; generated for fun



; === singerStat register ===
	IF &TYPE('pInputPort1') = 'UNDEFINED' THEN ; generated for fun
pInputPort1		equ			0				; set digital Input port, lsb
	ENDIF ; generated for fun
	IF &TYPE('pInputPort2') = 'UNDEFINED' THEN ; generated for fun
pInputPort2		equ			1				; set digital Input port
	ENDIF ; generated for fun
	IF &TYPE('pInputPort3') = 'UNDEFINED' THEN ; generated for fun
pInputPort3		equ			2				; set digital Input port
	ENDIF ; generated for fun
	IF &TYPE('pInputPort4') = 'UNDEFINED' THEN ; generated for fun
pInputPort4		equ			3				; set digital Input port, msb
	ENDIF ; generated for fun
;				equ			4				; unused
;				equ			5				; unused
;				equ			6				; unused
;				equ			7				; unused
;				equ			8				; unused
;				equ			9				; unused
;				equ			10				; unused
;				equ			11				; unused
	IF &TYPE('pRevNum1') = 'UNDEFINED' THEN ; generated for fun
pRevNum1		equ			12				; revision number, lsb
	ENDIF ; generated for fun
	IF &TYPE('pRevNum2') = 'UNDEFINED' THEN ; generated for fun
pRevNum2		equ			13				; revision number
	ENDIF ; generated for fun
	IF &TYPE('pRevNum3') = 'UNDEFINED' THEN ; generated for fun
pRevNum3		equ			14				; revision number
	ENDIF ; generated for fun
	IF &TYPE('pRevNum4') = 'UNDEFINED' THEN ; generated for fun
pRevNum4		equ			15				; revision number, msb
	ENDIF ; generated for fun
	IF &TYPE('pSingerStatus1') = 'UNDEFINED' THEN ; generated for fun
pSingerStatus1	equ			16				; status bits, lsb
	ENDIF ; generated for fun
	IF &TYPE('pSingerStatus2') = 'UNDEFINED' THEN ; generated for fun
pSingerStatus2	equ			17				; status bits
	ENDIF ; generated for fun
	IF &TYPE('pSingerStatus3') = 'UNDEFINED' THEN ; generated for fun
pSingerStatus3	equ			18				; status bits
	ENDIF ; generated for fun
	IF &TYPE('pSingerStatus4') = 'UNDEFINED' THEN ; generated for fun
pSingerStatus4	equ			19				; status bits, msb
	ENDIF ; generated for fun
	IF &TYPE('pOFRight') = 'UNDEFINED' THEN ; generated for fun
pOFRight		equ			20				; right channel overflow
	ENDIF ; generated for fun
	IF &TYPE('pOFLeft') = 'UNDEFINED' THEN ; generated for fun
pOFLeft			equ			21				; left channel overflow
	ENDIF ; generated for fun
	IF &TYPE('pValidData') = 'UNDEFINED' THEN ; generated for fun
pValidData		equ			22				; valid sound data
	ENDIF ; generated for fun
	IF &TYPE('pExpStat') = 'UNDEFINED' THEN ; generated for fun
pExpStat		equ			23				; expand bit for status
	ENDIF ; generated for fun
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused


; === sound phase register ===
	IF &TYPE('pPreScaleLSB') = 'UNDEFINED' THEN ; generated for fun
pPreScaleLSB	equ			0				; pre-scaler lsbit
	ENDIF ; generated for fun
	IF &TYPE('pReScaleMSB') = 'UNDEFINED' THEN ; generated for fun
pReScaleMSB		equ			5				; pre-Scaler msbit
	ENDIF ; generated for fun
	IF &TYPE('pOffsetLSB') = 'UNDEFINED' THEN ; generated for fun
pOffsetLSB		equ			6				; sample offset lsbit
	ENDIF ; generated for fun
	IF &TYPE('pOffsetMSB') = 'UNDEFINED' THEN ; generated for fun
pOffsetMSB		equ			17				; sample offset msbit
	ENDIF ; generated for fun
;				equ			18				; unused
;				equ			19				; unused
;				equ			20				; unused
;				equ			21				; unused
;				equ			22				; unused
;				equ			23				; unused
;				equ			24				; unused
;				equ			25				; unused
;				equ			26				; unused
;				equ			27				; unused
;				equ			28				; unused
;				equ			29				; unused
;				equ			30				; unused
;				equ			31				; unused

	IF &TYPE('phaseOffsetMsk') = 'UNDEFINED' THEN ; generated for fun
phaseOffsetMsk	equ			$003FFFC0		;										<SM4> rb, end
	ENDIF ; generated for fun

;---------------------------------------------------
; PSC DSP Register Bit Definitions						<SM10> ejb
;---------------------------------------------------

; === dspOverrun register ===
	IF &TYPE('pdspReset') = 'UNDEFINED' THEN ; generated for fun
pdspReset		equ			0				; when set places the dsp in reset state
	ENDIF ; generated for fun
	IF &TYPE('pdspResetEn') = 'UNDEFINED' THEN ; generated for fun
pdspResetEn		equ			1				; when cleared disables the dspReset bit
	ENDIF ; generated for fun
	IF &TYPE('pdspFrameOvr') = 'UNDEFINED' THEN ; generated for fun
pdspFrameOvr	equ			2				; when set indicates cat2 frame overrun on the dsp
	ENDIF ; generated for fun
;				equ			3				; unused
;				equ			4				; unused
;				equ			5				; unused
;				equ			6				; unused
	IF &TYPE('pdspSet') = 'UNDEFINED' THEN ; generated for fun
pdspSet			equ			7				; "0" clears, "1" sets for any bit field [0:6] containing a "1"
	ENDIF ; generated for fun

;---------------------------------------------------
; ???
;---------------------------------------------------

	IF &TYPE('seRegs') = 'UNDEFINED' THEN ; generated for fun
seRegs			EQU 		$0C30 					; offset to Sys Error Regs w/o Overlay
	ENDIF ; generated for fun

;---------------------------------------------------
; Hardware configuration bits.
;---------------------------------------------------

	IF &TYPE('hwCbSCSI') = 'UNDEFINED' THEN ; generated for fun
hwCbSCSI  		EQU 		15        				; SCSI port present
	ENDIF ; generated for fun
	IF &TYPE('hwCbClock') = 'UNDEFINED' THEN ; generated for fun
hwCbClock 		EQU 		14        				; New clock chip present
	ENDIF ; generated for fun
	IF &TYPE('hwCbExPRAM') = 'UNDEFINED' THEN ; generated for fun
hwCbExPRAM		EQU 		13        				; Extra Parameter Ram valid.
	ENDIF ; generated for fun
	IF &TYPE('hwCbFPU') = 'UNDEFINED' THEN ; generated for fun
hwCbFPU   		EQU 		12        				; FPU chip present.
	ENDIF ; generated for fun
	IF &TYPE('hwCbMMU') = 'UNDEFINED' THEN ; generated for fun
hwCbMMU   		EQU 		11        				; Some kind of MMU present (see MMUType for what kind).
	ENDIF ; generated for fun
	IF &TYPE('hwCbADB') = 'UNDEFINED' THEN ; generated for fun
hwCbADB   		EQU 		10        				; Apple Desktop Bus present.
	ENDIF ; generated for fun
	IF &TYPE('hwCbAUX') = 'UNDEFINED' THEN ; generated for fun
hwCbAUX			EQU			9						; Running A/UX					<2.8>
	ENDIF ; generated for fun
	IF &TYPE('hwCbPwrMgr') = 'UNDEFINED' THEN ; generated for fun
hwCbPwrMgr		EQU			8						; Power Manager present			<2.8>
	ENDIF ; generated for fun
	IF &TYPE('hwCmSCSI') = 'UNDEFINED' THEN ; generated for fun
hwCmSCSI  		EQU 		(1 << hwCbSCSI)
	ENDIF ; generated for fun
	IF &TYPE('hwCmClock') = 'UNDEFINED' THEN ; generated for fun
hwCmClock 		EQU 		(1 << hwCbClock)
	ENDIF ; generated for fun
	IF &TYPE('hwCmExPRAM') = 'UNDEFINED' THEN ; generated for fun
hwCmExPRAM		EQU 		(1 << hwCbExPRAM)
	ENDIF ; generated for fun
	IF &TYPE('hwCmFPU') = 'UNDEFINED' THEN ; generated for fun
hwCmFPU   		EQU 		(1 << hwCbFPU)
	ENDIF ; generated for fun
	IF &TYPE('hwCmMMU') = 'UNDEFINED' THEN ; generated for fun
hwCmMMU   		EQU 		(1 << hwCbMMU)
	ENDIF ; generated for fun
	IF &TYPE('hwCmADB') = 'UNDEFINED' THEN ; generated for fun
hwCmADB   		EQU 		(1 << hwCbADB)
	ENDIF ; generated for fun
	IF &TYPE('hwCmAUX') = 'UNDEFINED' THEN ; generated for fun
hwCmAUX			EQU			(1 << hwCbAUX)
	ENDIF ; generated for fun
	IF &TYPE('hwCmPwrMgr') = 'UNDEFINED' THEN ; generated for fun
hwCmPwrMgr		EQU			(1 << hwCbPwrMgr)
	ENDIF ; generated for fun


;---------------------------------------------------
; HcMac Clock Change Addresses
;---------------------------------------------------

	IF &TYPE('Clock16M') = 'UNDEFINED' THEN ; generated for fun
Clock16M  		EQU 		$FE0000   				; Go to sixteen megahertz clock throughput
	ENDIF ; generated for fun
	IF &TYPE('Clock1M') = 'UNDEFINED' THEN ; generated for fun
Clock1M   		EQU 		$FE0002   				; Go to one megahertz clock throughput (adds 64 wait states)
	ENDIF ; generated for fun


;---------------------------------------------------
; SCC Clock Rates, Baud Rate Constants
;---------------------------------------------------

	IF &TYPE('nuMacClock') = 'UNDEFINED' THEN ; generated for fun
nuMacClock		EQU 		36864
	ENDIF ; generated for fun
	IF &TYPE('nuMacConst') = 'UNDEFINED' THEN ; generated for fun
nuMacConst		EQU 		115200
	ENDIF ; generated for fun

	IF &TYPE('macClock') = 'UNDEFINED' THEN ; generated for fun
macClock  		EQU 		36707 					; in Hz * 100
	ENDIF ; generated for fun
	IF &TYPE('macConst') = 'UNDEFINED' THEN ; generated for fun
macConst  		EQU 		114709    				; in Hz/32
	ENDIF ; generated for fun

	IF &TYPE('hcMacClock') = 'UNDEFINED' THEN ; generated for fun
hcMacClock		EQU 		36720 					; SCC clock rates
	ENDIF ; generated for fun
	IF &TYPE('hcMacConst') = 'UNDEFINED' THEN ; generated for fun
hcMacConst		EQU 		114750
	ENDIF ; generated for fun


;---------------------------------------------------
; Deep Shit Rectangle info
;---------------------------------------------------

	IF &TYPE('dsRectTL') = 'UNDEFINED' THEN ; generated for fun
dsRectTL  		EQU 		(64<<16)+32       		; top left = 64,32
	ENDIF ; generated for fun
	IF &TYPE('dsRectBR') = 'UNDEFINED' THEN ; generated for fun
dsRectBR  		EQU 		(190<<16)+480     		; bottom right = 190,480
	ENDIF ; generated for fun
	IF &TYPE('dsRectHei') = 'UNDEFINED' THEN ; generated for fun
dsRectHei 		EQU 		(DSrectBR**$FFFF0000)-(DSrectTL**$FFFF0000)>>16
	ENDIF ; generated for fun
	IF &TYPE('dsRectLen') = 'UNDEFINED' THEN ; generated for fun
dsRectLen 		EQU 		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)
	ENDIF ; generated for fun


;---------------------------------------------------
; System Error Equates
;---------------------------------------------------

	IF &TYPE('seVars') = 'UNDEFINED' THEN ; generated for fun
seVars			EQU 		seRegs        			; start of system error data space (wrap city)
	ENDIF ; generated for fun
	IF &TYPE('seVSize') = 'UNDEFINED' THEN ; generated for fun
seVSize   		EQU 		128       				; # of bytes in space
	ENDIF ; generated for fun
	IF &TYPE('seD0') = 'UNDEFINED' THEN ; generated for fun
seD0  			EQU 		seVars        			; loc of saved reg D0
	ENDIF ; generated for fun
	IF &TYPE('seA0') = 'UNDEFINED' THEN ; generated for fun
seA0  			EQU 		seD0+32       			; loc of saved reg A0
	ENDIF ; generated for fun
	IF &TYPE('seA7') = 'UNDEFINED' THEN ; generated for fun
seA7  			EQU 		seA0+28       			; loc of saved reg A7
	ENDIF ; generated for fun
	IF &TYPE('sePC') = 'UNDEFINED' THEN ; generated for fun
sePC  			EQU 		seA7+4        			; loc of saved PC
	ENDIF ; generated for fun
	IF &TYPE('seSR') = 'UNDEFINED' THEN ; generated for fun
seSR  			EQU 		sePC+4        			; loc of saved SR
	ENDIF ; generated for fun
	IF &TYPE('seAccess') = 'UNDEFINED' THEN ; generated for fun
seAccess  		EQU 		seSR+2        			; PC address during bus/address error
	ENDIF ; generated for fun
	IF &TYPE('seCmdSize') = 'UNDEFINED' THEN ; generated for fun
seCmdSize 		EQU 		seAccess+4    			; # of bytes of parameters passed in _debugger call
	ENDIF ; generated for fun
	IF &TYPE('se000BE') = 'UNDEFINED' THEN ; generated for fun
se000BE   		EQU 		seCmdSize+2       		; 8 bytes of bus error info for 68000
	ENDIF ; generated for fun
	IF &TYPE('seLastVar') = 'UNDEFINED' THEN ; generated for fun
seLastVar 		EQU 		se000BE+8     			; last var in System Error data space
	ENDIF ; generated for fun


;---------------------------------------------------
; ROM based debugger nub
;---------------------------------------------------

	IF &TYPE('rdPort') = 'UNDEFINED' THEN ; generated for fun
rdPort			EQU 		seLastVar     			; Number of port currently in use (0 => no link, 1 => A, 2 => B)
	ENDIF ; generated for fun
	IF &TYPE('rdCode') = 'UNDEFINED' THEN ; generated for fun
rdCode			EQU 		rdPort+2      			; Ptr to code download buffer.
	ENDIF ; generated for fun
	IF &TYPE('rdAtrap') = 'UNDEFINED' THEN ; generated for fun
rdAtrap   		EQU 		rdCode+4      			; Saved Rom Atrap handler
	ENDIF ; generated for fun
	IF &TYPE('rdLowTrap') = 'UNDEFINED' THEN ; generated for fun
rdLowTrap 		EQU 		rdAtrap+4     			; low value for trap handling
	ENDIF ; generated for fun
	IF &TYPE('rdHiTrap') = 'UNDEFINED' THEN ; generated for fun
rdHiTrap  		EQU 		rdLowTrap+2       		; high value for trap handling
	ENDIF ; generated for fun
	IF &TYPE('rdResult') = 'UNDEFINED' THEN ; generated for fun
rdResult  		EQU 		rdHiTrap+2    			; result of executing down-loaded code, etc. (16 bytes)
	ENDIF ; generated for fun
	IF &TYPE('rdEnd') = 'UNDEFINED' THEN ; generated for fun
rdEnd 			EQU 		rdResult+16       		; end of vars
	ENDIF ; generated for fun


;---------------------------------------------------
; Microbug
;---------------------------------------------------

; NOTE: Keep mbDotAddr immediately before mBlocAddr

	IF &TYPE('mbBufSize') = 'UNDEFINED' THEN ; generated for fun
mbBufSize 		EQU 		34
	ENDIF ; generated for fun
	IF &TYPE('mbBuffer') = 'UNDEFINED' THEN ; generated for fun
mbBuffer  		EQU 		seLastVar     			; buffer for input
	ENDIF ; generated for fun
	IF &TYPE('mbSign') = 'UNDEFINED' THEN ; generated for fun
mbSign			EQU 		mbBuffer+mbBufSize    	; ST => negative sign during conversion
	ENDIF ; generated for fun
	IF &TYPE('mbDotAddr') = 'UNDEFINED' THEN ; generated for fun
mbDotAddr 		EQU 		mbSign+2      			; saved address
	ENDIF ; generated for fun
	IF &TYPE('mBlocAddr') = 'UNDEFINED' THEN ; generated for fun
mBlocAddr 		EQU 		mbDotAddr+4       		; saved location
	ENDIF ; generated for fun


;---------------------------------------------------
; Alternate ROM vectors
;---------------------------------------------------

	IF &TYPE('DiagROM') = 'UNDEFINED' THEN ; generated for fun
DiagROM   		EQU 		$F80000   				; Alternate ROM - initial vector
	ENDIF ; generated for fun
	IF &TYPE('DiagROM1') = 'UNDEFINED' THEN ; generated for fun
DiagROM1  		EQU 		$F80080   				; Alternate ROM - memory sizing vector
	ENDIF ; generated for fun
	IF &TYPE('DiagROM2') = 'UNDEFINED' THEN ; generated for fun
DiagROM2  		EQU 		$F80088   				; Alternate ROM - init I/O vector
	ENDIF ; generated for fun


;---------------------------------------------------
; Timing constants
;---------------------------------------------------

	IF &TYPE('VIAClockHz') = 'UNDEFINED' THEN ; generated for fun
VIAClockHz		EQU			783360					; VIA clock rate is 783360 Hz.		<2.8>
	ENDIF ; generated for fun
	IF &TYPE('nTicks') = 'UNDEFINED' THEN ; generated for fun
nTicks			EQU 		VIAClockHz/1000   		; VIA timer ticks per msec
	ENDIF ; generated for fun
	IF &TYPE('oneSecTicks') = 'UNDEFINED' THEN ; generated for fun
oneSecTicks   	EQU 		60    					; ticks, of course
	ENDIF ; generated for fun
				IF &TYPE('__SysEqu__') = 'UNDEFINED' THEN
	IF &TYPE('TimeSCSIDB') = 'UNDEFINED' THEN ; generated for fun
TimeSCSIDB		EQU			$0B24					; DBRAs & SCSI access per millisecond <1.9>
	ENDIF ; generated for fun
				ENDIF

	IF &TYPE('ramChk') = 'UNDEFINED' THEN ; generated for fun
ramChk			EQU 		1024      				; Amount of memory tested for stack.
	ENDIF ; generated for fun



;__________________________________________________________________________________________
;
;
; ROM Header RECORD Definition
;
;
;__________________________________________________________________________________________


;---------------------------------------------------
; Romulator ROM location bits and TestFor Macro
;---------------------------------------------------

	IF &TYPE('locValid1') = 'UNDEFINED' THEN ; generated for fun
locValid1		EQU			7						; this must be 1
	ENDIF ; generated for fun
	IF &TYPE('locValid2') = 'UNDEFINED' THEN ; generated for fun
locValid2		EQU			6						; this must be 0
	ENDIF ; generated for fun
	IF &TYPE('inEmulatorBit') = 'UNDEFINED' THEN ; generated for fun
inEmulatorBit	EQU			1						; running in emulator
	ENDIF ; generated for fun
	IF &TYPE('inRamBit') = 'UNDEFINED' THEN ; generated for fun
inRamBit		EQU			0						; running in ram
	ENDIF ; generated for fun


