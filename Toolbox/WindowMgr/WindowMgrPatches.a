;
;	File:		WindowMgrPatches.a
;
;	Contains:	linked patches to the Window Mgr.
;
;	Copyright:	© 1989-1992 by Apple Computer, Inc., all rights reserved.
;
;   This file is used in these builds: BigBang
;
;	Change History (most recent first):
;
;		<48>	 6/11/92	JSM		Add comment about patchGetResource being rolled into
;									DialogMgr.a.
;		<47>	 5/15/92	DC		Fixes to patches to make ShowHide work for hiding applications.
;									Still needs work.
;		<46>	 5/14/92	DC		<no bug number> KSM:  In order to make CubeE usable as a base
;									for the layerless application model, I need to set up vectors
;									for "unpatching" the layer manager.  My the layerless apps INIT
;									will take these vectors and undo the 7.0 layer manager patches
;									that it replaces.  The setting up of these vectors is done in an
;									install proc and stored in the emWindowListGlobals field of
;									ExpandMem.  This is the only change to this file that was done
;									for the layerless app INIT that will actually affect CubeE, the
;									rest of the changes have been assiduously conditionalized.
;		<45>	 4/20/92	DC		Fixed patches to circumvent use of nextWindow to allow layerless
;									apps.  (all conditionalized to protect CubeE and System)
;		<44>	 4/10/92	DC		Put in conditional changes to WindowMgrPatches.a and LayerMgr.c
;									for implementing layerless apps.
;		<43>	  4/3/91	dba		kill enjoyable part of the code
;		<42>	 3/26/91	dba		BAL: move 68000 directive up to where it belongs (some universal
;									patches were being compiled with 68020 setting)
;		<41>	 3/11/91	VL		dba, #84426 (also related VL-004, see <38>): Removed code in
;									<38> for replacing active window by select window. Instead, make
;									sure that the current layer (i.e. WindowList) contains the
;									ActivatePalette window. Also, rearrange patch DoActivatePalette
;									to call HiliteWindow and ActivatePalette with the same
;									parameters as the ROM.
;		<40>	  3/4/91	dba		gbm: only load the SetWTitle patch on Color QuickDraw machines
;		<39>	 2/27/91	VL		dba, #VL-005: Fixed crash in CalcVBehind patch to SendBehind.
;									This is fixed by putting the check for loop termination at the
;									beginning of the loop. (This fixed the FreeHand crash).
;		<38>	 2/11/91	VL		KSM, #VL004: SelectWindow should call HiliteWindow and
;									ActivatePalette on the window being selected (not the active
;									window).
;		<37>	 2/11/91	VL		DC,#82197: Fixed the bug of passing illegal rgn (i.e. an empty
;									rgn) to InvalCommon.
;		<36>	  2/6/91	dba		dty, #dba12345: fix register trashing problem introduced when I
;									did <34>
;		<35>	  2/5/91	dba		VL, #dba12345: change back the test to see which case to use in SendBehind,
;									since the old test was smaller and worked fine (there was no
;									reason for me to change that line in <34>)
;		<34>	  2/5/91	gbm		dba/JDR, #dba12345: fix bugs where SendBehind bringing a window
;									to the front would paint too many windows; this is enhancing the
;									patch Darin and Vincent created in change <31>
;		<33>	 1/30/91	VL		dba, #Whiteboard7.0b4q6HowDoYouLikeThisBugNumberChris?: Use a
;									flag to indicate to PaintOne and PaintBehind that the ancestor
;									regions have already been calculated by a previous call. This
;									was the same idea as PaintBehindLite and PaintOneLite, but
;									works better for applications that patch PaintOne or
;									PaintBehind.
;		<32>	 1/24/91	VL		dba, #VL001:Patched ShowHide so that we replace the return
;									address of ShowHide to the caller of ShowWindow instead of
;									ShowWindow so that we don't have to keep a1 across trap.
;		<31>	 1/18/91	VL		(dba) Added CalcVBehind in SendBehind to deal with moving a
;									window in front of a window behind it.
;		<30>	 1/17/91	VL		(dba) Set PenSize to (1,1) after PenMode in _DragTheRgn.
;		<29>	 1/17/91	VL		(dba) Fixed up the list of ROMs on the AfterPaintBehindIn and
;									AfterPaintOneIn patches.
;		<28>	 1/17/91	VL		(dba) Added patchPaintBehind and a bunch of AfterPaintOneIn and
;									AfterPaintBehindIn patches. These comefrom patches call
;									PaintOneLite and PaintBehindLite to avoid recalculating the
;									ancestor rgns.
;		<27>	  1/3/91	VL		(RLC) Add one more call RedrawAll to LayerDispatch.
;		<26>	12/14/90	bbm		(djw) roll in linked comefrompatch from patchIIrom.a.
;		<25>	 12/6/90	VL		(& dba) Put in a patch for ShowHide so that it can deal with
;									layers.
;		<24>	 12/3/90	VL		& dba; Fixed PaintWhite bug in ROM (it should test for a word
;									instead of a byte).
;		<23>	 11/8/90	dba		& gbm; move patch that does a system error if we can’t load a
;									WDEF here from PTCH files
;		<22>	 10/8/90	dba		move the patch to NewControl to ControlMgrPatches.a
;		<21>	 10/2/90	dba		Fix patch to ShowHide so it does a MOVE.B #1 instead of an ST.
;		<20>	 9/23/90	dba		Put patches here to make the Macintosh II ROMs call the Palette
;									Mgr. again. (This was broken when we did 32-bit QuickDraw as a
;									patch for 7.0.) Move the clip calculation in PaintDesk to C so
;									that we can maintain the DeskPort’s visRgn.
;		<19>	 8/31/90	dba		Get rid of SetLayerLock, and replace it with GetDeskPort. Change
;									CurLayer to a new global so we can have a DeskPort global.
;		<18>	 8/30/90	dba		Took out obsolete usesPositioning flag. Got rid of the
;									SwapParent routine. Got rid of __InitWindows (use __InitLayers
;									instead). Deleted unnecessary come-from patch to CheckUpdate.
;									Put in Chris’ patch to GetAuxWin to call LoadResource on the
;									color table handle if it has been purged.
;		<17>	 8/16/90	dba		improve the speed of the Layer Manager by calling
;									CalcAncestorRgns at the right time instead of at every PaintOne
;									and PaintBehind call
;		<16>	  8/6/90	csd		Added patches to FindWindow and TrackGoAway to work around a bug
;									in Dreams 1.1
;		<15>	  8/5/90	DTY		_SetCtlColor totally hoses out if the ControlHandle is NIL.
;									Rewrite the bugger so if the default ‘cctb’ is changed, call
;									_PaintOne on the rearmost window with GrayRgn as the clobbered
;									region to redraw the controls in all the windows.  Also pulled
;									the code that finds the rearmost window out of fixSetWinColor,
;									and made it a proc.
;		<14>	 7/27/90	dba		make InvalRect and ValidRect be faster; also fix a bug in Dean’s
;									_SetWinColor patch (he’s fixing it and I’m checking in)
;		<13>	 7/25/90	DTY		Added come-from patch to _PaintOne to fix bad clobberedRgn
;									passed by _SetWinColor when the WindowPtr passed to _SetWinColor
;									is nil.
;		<12>	 7/23/90	EMT		Fixed patchSetClip which was incorrectly converted in <3>.
;		<11>	 7/23/90	EMT		Changed IsLayerLocked to WindowType.
;		<10>	 7/19/90	EMT		Returned to older style paint and calcvis loops.
;		 <9>	 7/11/90	EMT		Fixed BeginUpdate/EndUpdate reentrancy problem.
;		 <8>	  7/2/90	EMT		Miscellaneous size and performance improvements: Moved
;									__NewWindow, __NewCWindow and __DrawNew here from Layers.c.
;									Removed PaintOne and DrawMenuBar patches, since we no longer
;									cache visRgns.
;		 <7>	 6/15/90	DC		Fix PatchGetResource to allow for odd string alignments
;		 <6>	 6/14/90	EMT		Added patches to PaintOne and DrawMenuBar which detect and
;									correct for altered grayRgns, as used by Monitors to add
;									gDevices and HyperCard to hide and show the menu bar.
;		 <5>	  6/8/90	DC		Rolled over changes in GetResource backpatch
;		 <4>	  6/8/90	EMT		Fixed a bug in patchFrontWindow. JSRROM PreSkipUnHilite should
;									be a JMPROM.
;		 <3>	  6/7/90	EMT		Moved Layer Manager patches here.
;		 <2>	 4/26/90	dba		get rid of the CloseWindow patch since it doesn’t work yet
;		 <1>	 4/20/90	dba		first checked in
;
;	To Do:
;		optimize Bracketed calls for BringToFront, SelectWindow, DrawNew, ShowWindow, MoveWindow;
;		in that order.
;

		load 'StandardEqu.d'
		include 'LayerEqu.a'
		include 'PaletteEqu.a'
		include 'PalettePriv.a'
		include 'LinkedPatchMacros.a'
		
	IF &TYPE('hasLayerlessAppsINIT') = 'UNDEFINED' THEN
hasLayerlessAppsINIT	SET 0
	ENDIF

; *** move these equates into system equate files

CurLayer	EQU		$A90
WMgrUpdate	EQU		$AFC

selectGetDeskPort	equ		-5

		ROMs Plus,SE,II,Portable,IIci

SetWPort								ROMBind		(IIci,$16E02)
CloseWindowAfterCallToCancelActivate	ROMBind		(IIci,$189E4)
AfterKillControlsInCloseWindow			ROMBind		(Plus,$1178C),(SE,$BDF2),(II,$FB84),(Portable,$10990),(IIci,$189EC)
AfterPaintOneInSetWinColor				ROMBind		(II,$1089C),(IIci,$1978C)
AfterUnionRgnInSetWTitle				ROMBind		(Plus,$118FA),(SE,$BF60),(II,$FD16),(Portable,$10AFE),(IIci,$18BD8)
AfterOffsetRgnInMoveWindow				ROMBind		(Plus,$119AE),(SE,$C020),(II,$FDDA),(Portable,$10BBE),(IIci,$18C9C)
SetGutsInROM							ROMBind		(II,$108C6),(IIci,$197B6)
SetCtlColorAfterSetGuts					ROMBind		(II,$108AC),(IIci,$1979C)
SetEndInROM								ROMBind		(II,$108BC),(IIci,$197AC)
FromPaintOne							ROMBind		(Plus,$11328),(SE,$0B97A),(II,$0F586),(Portable,$104FC),(IIci,$183B6)
TestClip								ROMBind		(Plus,$11376),(SE,$0B9CA),(II,$0F602),(Portable,$1054C),(IIci,$18432)
AfterClipAbove							ROMBind		(Plus,$1132E),(SE,$0B982),(II,$0F58E),(Portable,$10504),(IIci,$183BE)
FromDragWindow							ROMBind		(Plus,$11E0C),(SE,$0C4B6),(II,$10366),(Portable,$11070),(IIci,$19244)
ClipGAbove								ROMBind		(Plus,$11ABE),(SE,$0C158),(II,$10008),(Portable,$10D12),(IIci,$18ED8)
NoBTF0									ROMBind		(Plus,$119BA),(SE,$0C02C),(II,$0FDE6),(Portable,$10BCA),(IIci,$18CA8)
PaintNewOne								ROMBind		(Plus,$11712),(SE,$0BD78),(II,$0FB0A),(Portable,$10916),(IIci,$18972)
FromGNECommon							ROMBind		(Plus,$110B0),(SE,$0B67C),(II,$0F23E),(Portable,$10170),(IIci,$15B50)
StartROMWMgr							ROMBind		(Plus,$111AC),(SE,$0B7E6),(II,$0F3B0),(Portable,$10376),(IIci,$181E0)
EndROMWMgr								ROMBind		(Plus,$12198),(SE,$0C94A),(II,$109BE),(Portable,$11442),(IIci,$198B8)
FromSelectWindow						ROMBind		(Plus,$11BFC),(SE,$0C296),(II,$10146),(Portable,$10E50),(IIci,$1901C)
BTF1									ROMBind		(Plus,$11C28),(SE,$0C2C2),(II,$10172),(Portable,$10E7C),(IIci,$1904C)
PostDoActivate							ROMBind		(Plus,$11C14),(SE,$0C2AE),(II,$1015E),(Portable,$10E68),(IIci,$19034)
	;be sure to skip MOVE.L 4(SP),D0
PreSkipUnHilite							ROMBind		(Plus,$11C18),(SE,$0C2B2),(II,$10162),(Portable,$10E6C),(IIci,$19038)
	;be sure to include BEQ.S NoActivate
FromBTF1								ROMBind		(Plus,$11CA6),(SE,$0C346),(II,$101F6),(Portable,$10F00),(IIci,$190D0)
InsertWindow							ROMBind		(Plus,$111E8),(SE,$0B830),(II,$0F43C),(Portable,$103B2),(IIci,$1826C)
MakeDeactive							ROMBind		(Plus,$117E6),(SE,$0BE4C),(II,$0FC02),(Portable,$109EA),(IIci,$18AC4)
CallWindow								ROMBind		(Plus,$11A20),(SE,$0C092),(II,$0FF48),(Portable,$10C48),(IIci,$18E0E)
CallDWindow								ROMBind		(Plus,$11A5A),(SE,$0C0CC),(II,$0FF7C),(Portable,$10C86),(IIci,$18E4C)
CallWCalc								ROMBind		(Plus,$11A68),(SE,$0C0DA),(II,$0FF8A),(Portable,$10C94),(IIci,$18E5A)
FromGetADHndl							ROMBind		(Plus,$14DA8),(SE,$0F3D2),(II,$13EA0),(Portable,$130E6),(IIci,$19F64)
FromGetNewWind							ROMBind		(Plus,$15F1E),(SE,$10576),(II,$152FA),(Portable,$1B68C),(IIci,$21CB8)
SetUpColor								ROMBind		(Plus,$00001),(SE,$00001),(II,$0F3BE),(Portable,$00001),(IIci,$181EE)
NoDeskHook								ROMBind		(Plus,$11396),(SE,$0B9EA),(II,$0F624),(Portable,$1056C),(IIci,$18454)
IvalCommon								ROMBind		(Plus,$11F90),(SE,$0C640),(II,$105D6),(Portable,$111FE),(IIci,$194B4)
AfterHiliteWindowInDoActivate			ROMBind		(II,$1016A)
AfterLoadResourceInCallWindow			ROMBind		(Plus,$11A44),(SE,$0C0B6),(II,$0FF6C)
AfterSectRgnInGoPaintOne				ROMBind		(Plus,$11346),(SE,$0B99A),(II,$F5A6),(IIci,$183D6),(portable,$1051c)
SkipEraseInROM							ROMBind		(Plus,$11350),(SE,$0B9A4),(II,$F5DA),(IIci,$1840A),(portable,$10526)
EraseInROM								ROMBind		(Plus,$1134c),(SE,$0B9A0),(II,$F5AC),(IIci,$183DC),(portable,$10522)
AfterGetKeysInGetPinMouse				ROMBind		(II,$10724)
AfterMoveGWKeyMapInGetPinMouse			ROMBind		(II,$10728)
AfterFirstSectRgnInGoPaintOne			ROMBind		(Plus,$11328),(SE,$B97A),(II,$F586),(IIci,$183B6),(portable,$104FC)
TestClipAfterClipAbove					ROMBind		(Plus,$1132E),(SE,$B982),(II,$F58E),(IIci,$183BE),(portable,$10504)
AfterPaintBehindInDrawNew				ROMBind		(Plus,$11484),(SE,$BAD8),(II,$F72A),(IIci,$18564),(Portable,$1065A)
AfterPaintOneInMoveWindow				ROMBind		(Plus,$119FE),(SE,$C070),(II,$FE2A),(IIci,$18CEC),(Portable,$10C0E)
AfterPaintOneInBringToFront				ROMBind		(Plus,$11CA2),(SE,$C342),(II,$101F2),(IIci,$190CC),(Portable,$10EFC)
AfterPaintBehindInSendBehind			ROMBind		(Plus,$11D0A),(SE,$C3AA),(II,$1025A),(IIci,$19134),(Portable,$10F64)
AfterPaintOneInSetDeskCPat				ROMBind		(II,$10824),(IIci,$19714)
AfterPenModeInDragTheRgn				ROMBind		(Plus,$11E8C),(SE,$C53C),(II,$103EC),(IIci,$192CA),(Portable,$110F6)
AfterCalcVBehindInSendBehind			ROMBind		(Plus,$11D06),(SE,$C3A6),(II,$10256),(IIci,$19130),(Portable,$10F60)
AfterShowHideInShowWindow				ROMBind		(Plus,$11832),(SE,$BE98),(II,$FC4E),(IIci,$18B10),(Portable,$10A36)

;————————————————————————————————————————————————————————————————————————————————————————————————————
; NoChangeInGrowWindow — hide the window before killing the controls
;
;	If GrowWindow is called and the resultant window rect is unchanged from the window's
;	original value, GrowWindow is supposed to return zero.  Because of a trashed register
;	in the GetPinMouse utility (D6), this was not happening leading many applications to
;	perform an unneeded update.  This corrects the GetPinMouse utility.  Many thanks to
;	Chris DeRossi in Tech Support who found this bug.

NoChangeInGrowWindow ComeFromPatchProc _GetKeys,AfterGetKeysInGetPinMouse,(II)

GWKeyMap	EQU		-72								; key map (straight from GrowWindow)

			ADDQ.L	#4,SP							; get rid of the return address
			jsrOld
			TST.B	GWKeyMap+6(A6)					; is the command key down?
			jmpROM	AfterMoveGWKeyMapInGetPinMouse	; and go back

			ENDPROC

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————

PatchTrackGoAwayForDreams	PatchProc	_TrackGoAway

; Dreams version 1.1 includes a WDEF which trashes A4 when called with a HitTest message. This
; causes the Layer Manager to die. The only time the WDEF is called with this message is from
; TrackGoAway and from FindWindow. This is a wrapper patch to TrackGoAway which saves and restores A4.
; As soon as Dreams revs, this code should be removed. This code should never be rolled into ROM.

				move.l	A4, -(SP)				; save A4 for later restoration
				subq	#2, SP					; room for the integer result
				move.l	2+4+4+4(SP), -(SP)		; theWindow parameter
				move.l	4+2+4+4(SP), -(SP)		; thePt parameter

				jsrOld							; call TrackGoAway

				move.w	(SP)+, D0				; get integer result
				move.l	(SP)+, A4				; restore the problem register
				move.l	(SP)+, A0				; original return address
				addq	#8, SP					; pop caller’s parameters
				move.w	D0, (SP)				; give caller the result
				jmp		(A0)					; return to original caller

				EndProc
	ENDIF
				
	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————

PatchFindWindowForDreams	PatchProc	_FindWindow

; Dreams version 1.1 includes a WDEF which trashes A4 when called with a HitTest message. This
; causes the Layer Manager to die. The only time the WDEF is called with this message is from
; TrackGoAway and from FindWindow. This is a wrapper patch to FindWindow which saves and restores A4.
; As soon as Dreams revs, this code should be removed. This code should never be rolled into ROM.

				move.l	A4, -(SP)				; save A4 for later restoration
				subq	#2, SP					; room for the integer result
				move.l	2+4+4+4(SP), -(SP)		; thePoint parameter
				move.l	4+2+4+4(SP), -(SP)		; theWindow parameter

				jsrOld							; call FindWindow

				move.w	(SP)+, D0				; get integer result
				move.l	(SP)+, A4				; restore the problem register
				move.l	(SP)+, A0				; original return address
				addq	#8, SP					; pop caller’s parameters
				move.w	D0, (SP)				; give caller the result
				jmp		(A0)					; return to original caller

				EndProc
	ENDIF
	
	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————

PatchGetAuxWin	PatchProc	_GetAuxWin,(II,IIci)
				Entry		ReloadColorTableCommon

; The routines that need to get at a window’s color table generally call GetAuxWin first to
; get the color table handle. That makes this a good place to reload the color table if it’s
; been purged.

				subq	#2, SP					; room for a boolean result
				move.l	2+4+4(SP), -(SP)		; copy the WindowPtr parameter
				move.l	4+2+4(SP), -(SP)		; copy the AuxWinHandle parameter
				jsrOld							; call GetAuxWin

ReloadColorTableCommon
				move.w	(SP)+, 4+4+4(SP)		; copy boolean result for caller
				move.l	(SP)+, 4(SP)			; plop return address on top of WindowPtr parameter
				move.l	(SP)+, A0				; get ptr to Aux[Win|Ctl]Handle
				move.l	(A0), A0				; Aux[Win|Ctl]Handle in A0
				move.l	(A0), A0				; Aux[Win|Ctl]Ptr in A0
				move.l	awCTable(A0), A0		; Color table handle (resource handle) in A0
				tst.l	(A0)					; is the master pointer NIL?
				bnz.s	@GetAuxWinReturn
				move.l	A0, -(SP)				; push the resource handle
				_LoadResource					; try to get it back in memory
@GetAuxWinReturn
				rts

				EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————

PatchGetAuxCtl	PatchProc	_GetAuxCtl,(II,IIci)
				Import		ReloadColorTableCommon

; The routines that need to get at a control’s color table generally call GetAuxCtl first to
; get the color table handle. That makes this a good place to reload the color table if it’s
; been purged. This routine does exactly the same thing as the GetAuxWin patch above, so we share
; code.

				subq	#2, SP					; room for a boolean result
				move.l	2+4+4(SP), -(SP)		; copy the ControlHandle parameter
				move.l	4+2+4(SP), -(SP)		; copy the AuxCtlHandle parameter
				jsrOld							; call GetAuxCtl
				jmp		ReloadColorTableCommon

				EndProc
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
; CloseWindow — fix 32-bit activation bug

	if 0 then ; *** this patch doesn’t work yet

; A bug occurs in the IIci ROM under 32-bit mode. The high bit of CurActivate and CurDeactivate
; are used as flags to indicate that the events have already been sent. CancelActivate is called by
; CloseWindow to get rid of activate and deactivate events that would otherwise happen for windows
; that are no longer around. The old 24-bit version masked two pointers with Lo3Bytes when comparing
; them. This can cause a (relatively rare) bug where you get an activate or deactivate event for a
; window that is already closed. *** Should we patch it? I don’t know. ***

FixCancelActivate patchproc _CloseWindow,(IIci)

; This code is copied from the ROM CloseWindow.

		MOVEM.L D3-D4/A2/A3,-(SP)		; save working registers
		MOVE.L	20(SP),A3				; get window pointer
		jsrROM 	SetWPort				; set the port to the WMgrPort

; Cancel pending activate events. (This cancels activates for DisposeWindow too)

		bsr.s	CancelActivate

; re-join the ROM

		jmpROM	CloseWindowAfterCallToCancelActivate

; CancelActivate -- takes a window pointer and checks to see if
; that address is in either the CurActivate or the CurDeactive locations.
; If it is, clears that address.  Has the effect of
; cancelling pending activate events.  Trashes A0, D0 and D1.

; The original patch worked by clearing CurActivate or CurDeactive. This didn’t work
; because if a window was both CurActivate and CurDeactive, then both are cleared
; and next GetNextEvent on an activate didn’t set sys<->app bit.
; Later, we decided that we don’t care about the sys<->app bit, so to make 32-bit
; machines work, we patch this so that it clears the low memory once again.

CancelActivate
		lea 	CurActivate,a0			; check CurActivate first
		bsr.s	@tryOne
		addq	#4,a0					; now do CurDeactive
@tryOne
		move.l	(a0),d1					; get address
		move.l	a3,d0
		eor.l	d1,d0					; get bit differences
		_StripAddress					; strip it down
		tst.l	d0
		bne.s	@dontClear				; oops, not the same address
		clr.l	(a0) 					; else cancel the event
@dontClear
		rts

		endproc

	endif

;————————————————————————————————————————————————————————————————————————————————————————————————————
; CloseWindow — hide the window before killing the controls

; CloseWindow has a call to KillControls before a call to ShowHide that actually hides the window.
; This come-from patch to KillControls is a call to ShowHide *before* killing the controls. This
; prevents all the drawing that happens as the various controls are disposed.

HideWindowBeforeKillingControls ComeFromPatchProc _KillControls,AfterKillControlsInCloseWindow

		MOVE.L	A3,-(SP)				; push the window
		CLR.W	-(SP)					; say “Hide”
		_ShowHide						; hide the window

		jmpOld							; rejoin our regularly scheduled KillControls

		endproc

;————————————————————————————————————————————————————————————————————————————————————————————————————

		machine mc68020					; some Macintosh II-only patches

;————————————————————————————————————————————————————————————————————————————————————————————————————
; DoActivate — call ActivatePalette after doing HiliteWindow at the end of DoActivate

DoActivatePalette ComeFromPatchProc _HiliteWindow,AfterHiliteWindowInDoActivate,(II)

			addq	#6,sp						; get rid of return address	& boolean parameter to HiliteWindow			<41>
			move.l	(sp),-(sp)					; duplicate window for ActivatePalette (actually for HiliteWindow)		<41>
			st		-(sp)						; push "TRUE"															<41>

			jsrOld								; call the real HiliteWindow

			_ActivatePalette					; activate its palette

			move.l	(sp)+,(sp)					; deallocate the parameter
			rts									; return

			EndProc

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; MoveWindow — call ActivatePalette at the end

MoveWindowActivatePalette PatchProc _MoveWindow,(II)

			LEA		10(SP),A0					; point to parameters

			move.l	(a0),-(sp)					; push window pointer for ActivatePalette

			MOVE.L	(A0),-(SP)					; push ten bytes of parameters for MoveWindow
			MOVE.L	-(A0),-(SP)
			MOVE.W	-(A0),-(SP)
			jsrOld								; call the ROM MoveWindow

			_ActivatePalette					; activate the palette
			rtd		#10							; strip 10 bytes and return

			EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; SizeWindow — call ActivatePalette at the end

SizeWindowActivatePalette PatchProc _SizeWindow,(II)

			LEA		10(SP),A0					; point to parameters

			move.l	(a0),-(sp)					; push window pointer for ActivatePalette

			MOVE.L	(A0),-(SP)					; push ten bytes of parameters for SizeWindow
			MOVE.L	-(A0),-(SP)
			MOVE.W	-(A0),-(SP)
			jsrOld								; call the ROM SizeWindow

			_ActivatePalette					; activate the palette
			rtd		#10							; strip 10 bytes and return

			EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; CloseWindow — call DisposePalette for palettes with the disposeBit set

CloseWindowDisposePalettes PatchProc _CloseWindow,(II)

			MOVE.L	4(SP),A0					; get the window
			TST.W	PORTBITS+ROWBYTES(A0)		; is it new?
			BPL.S	@noDispose					; => no
			MOVE.L	grafVars(A0),A0				; get grafVar handle
			MOVE.L	(A0),A0						; point at grafVars
			MOVE.L	pmFgColor(A0),D0			; is there a palette?
			BEQ.S	@noDispose					; => no
			Move.L	D0,A0						; let's use an address register
			Move.L	(A0),A0						; dereference it
			BTst.B	#disposeBit,pmPrivate(A0)	; should we dispose of it?
			Beq.S	@noDispose					; no => the user has to dispose of it

			MOVE.L	D0,-(SP)					; else push palette
			_DisposePalette						; and dump it
@noDispose

			jmpOld								; go dispose the window

			EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; ShowHide — call ActivatePalette.

ShowHideActivatePalette PatchProc _ShowHide,(II)

			tst.b	4(sp)						; is this making a window visible?
			beqOld								; no, don’t bother with the palette
			move.l	6(sp),a0					; get the window pointer
			tst.b	wVisible(a0)				; is the window already visible?
			bne.s	@done						; yes, no need to do anything at all

			MOVE.L	a0,-(SP)					; push window pointer for ActivatePalette
			MOVE.L	a0,-(SP)					; push parameters for ShowHide
			move.b	#1,-(SP)					; we wouldn’t be here if it wasn’t true
			jsrOld								; call ShowHide
			_ActivatePalette					; activate its palette
@done
			RTD		#6							; strip parameters and return

	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop

			EndProc
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————

		machine mc68000					; back to universal patches

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; ShowHide patch for the Layer Manager
; 	PreShowHide fixes up the regions of the windows of the layer to be shown/hidden:
;	If the layer is becoming visible, all the visible windows (determined by the visible flag)
;		will have their structRgn and contRgn recalculated.
;	If the layer is becoming invisble, all the windows will have their structRgn, contRgn and
;		visRgn emptied out.

retAddr		equ	0
showFlag	equ	retAddr+4
windowPtr	equ	showFlag+2

patchShowHide	PatchProc	_ShowHide
				EXPORT		oldShowHide

				IMPORT	PreShowHide
				move.l	windowPtr(sp),-(sp)		; duplicate the parameters on stack
				move.w	showFlag+4(sp),-(sp)
				jsr		PreShowHide				; fix up regions
oldShowHide		jmpOld							; ShowHide

				ENDPROC
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; ShowHide in ShowWindow <32>
; ShowWindow puts the return address in a1 and then calls ShowHide. Now we just replace the
; return address with a1 and returns directly to the caller of ShowWindow instead of ShowWindow.
ShowHideInShowWindow	ComeFromPatchProc	_ShowHide,AfterShowHideInShowWindow

						move.l	a1,(sp)			; replace return address
						jmpOld					; ShowHide

						EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; Fix PaintOne so that it uses the ClipAbove trap.
patchSectRgn	ComeFromPatchProc	_SectRgn,FromPaintOne

				ADDQ.L	#4, SP					;pop the return address - we don't need it.
				JSROLD							;call SectRgn

				JSRROM	TestClip				;exit if clipRgn is empty
				MOVE.L	A2,-(SP)				;now subtract windows above this one
				_ClipAbove						;Call the trap instead.
				JMPROM	AfterClipAbove

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
; Fix DragWindow so that it always calls ClipAbove
patchDragGrayRgn	ComeFromPatchProc	_DragGrayRgn,FromDragWindow

myKeyMap		EQU 	-36 					;place to hold keyMap

				MOVE.B	myKeyMap+6(A6),D6		;was command key down?
				BMIOLD							;yes, everything's cool.

				MOVE.L	WindowList, A3			;else, clipAbove the first window
				JSRROM	ClipGAbove				;clip to windows above us
				MOVE.L	16(A6),A3				;get window
				JMPOLD

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
; Fix MoveWindow so that it calls ClipAbove(WindowList) for the bringToFront case.
patchSetClip	ComeFromPatchProc	_SetClip,NoBTF0

				ADDQ.L	#8,SP					;clear off the stack
				MOVE.L	WindowList, A3			;else, clipAbove the first window
				JSRROM	ClipGAbove				;clip to windows above us
				MOVE.L	34(SP),A3				;get window
				JMPROM	NoBTF0

				ENDPROC
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
; Fix lots of window manager routines to use ActiveWindow instead of FrontWindow.
; Fix SelectWindow so that it brings a window to the front and selects the
; new active window.
; patchFrontWindow is a come-from patch and therefore needs to call __FrontWindow
; instead of the other way around.
patchFrontWindow	ComeFromPatchProc	_FrontWindow

				CMPROM	StartROMWMgr,(SP)		;coming from Window Manager in ROM?
				BLOOLD							;nope, skip the patch.

				CMPROM	EndROMWMgr,(SP)			;coming from Window Manager in ROM?
				BHIOLD							;nope, skip the patch.

				CMPROM	FromSelectWindow,(SP)	;coming from SelectWindow?
				BNE.S	@ActiveWindow			;nope, just call ActiveWindow instead.

				ADDQ.L	#4,SP					;clear off return address
	IF NOT hasLayerlessApps THEN
				BSR.S	@ActiveWindow			;find out the active window
	ELSE
				IMPORT	__FrontWindow
				JSR		__FrontWindow			;find out the active window
	ENDIF
				MOVE.L	8(SP),-(SP) 			;push the new window
				
	IF NOT hasLayerlessApps THEN
				JSRROM	BTF1					;bring it to the front
	ELSE
				IMPORT	BringToFrontGuts
				JSR		BringToFrontGuts		;bring it to the front
	ENDIF

				MOVE.L	8(SP),A0				;get the window in A0
				MOVE.B	wVisible(A0),-(SP)		;save visible on stack
				ST.B	wVisible(A0)			;make it appear visible for ActiveWindow

				SUBQ.L	#4,SP					;make room for FrontWindow result
				BSR.S	@ActiveWindow			;find out the new active window

				MOVE.L	14(SP),A0				;get the window in A0
				MOVE.B	4(SP),wVisible(A0)		;restore wVisible

				MOVE.L	6(SP),D0				;get the old frontWindow
				CMP.L	(SP),D0					;is it the same?
				BEQ.S	@CallSkipUnHilite		;yes, don't post events

				TST.L	D0						;is old frontWindow nil?
				BEQ.S	@SkipDeactive			;yes, skip the deactivate

				JSRROM	MakeDeactive			;go post the deactivate

@SkipDeactive
				MOVE.L	(SP)+,D0				;get the new active window
				ADDQ.L	#6,SP					;strip the old frontWindow
				JMPROM	PostDoActivate

@CallSkipUnHilite
				LEA		10(SP),SP				;strip the frontWindows
				TST.L	D0						;Is it nil?
				JMPROM	PreSkipUnHilite

@ActiveWindow
				IMPORT	__ActiveWindow
				JMP		__ActiveWindow			;jump vector to real ActiveWindow

				ENDPROC

	IF NOT hasLayerlessApps THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; Fix BTF1 so that it calculates the visRgns using CalcVisBehind.
patchCalcVis	ComeFromPatchProc	_CalcVis,FromBTF1

				MOVE.L	(SP),A0					;get the return address
				MOVE.L	STRUCTRGN(A3),(SP)		;for now, everything's clobbered
				MOVE.L	A0,-(SP)				;push the return address
				IMPORT	__CalcVisBehind
				JMP		__CalcVisBehind

				ENDPROC
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
; _SetWinColor calls _PaintOne to redraw the window in with the new colors in the 'wtcb', with the
; structRgn of the window as the clobbered region.  If nil was passed in to _SetWinColor to change
; the default window color table, _SetWinColor passed structRgn(0) as the clobbered region to
; _PaintOne which is very bad.  Put a comefrom patch on _PaintOne to see if the we’re coming from
; _SetWinColor.  If we are, and the windowPtr is nil, change the clobbered region parameter to use
; GrayRgn.  The windowPtr parameter is changed to the rearmost visible window, since the windows
; need to be redraw with the new colors anyway.

fixSetWinColor	ComeFromPatchProc	_PaintOne,AfterPaintOneInSetWinColor,(II,IIci)

				tst.l	8(sp)					; See if the WindowPtr parameter is nil
				bneOld							; If not nil, go to old _PaintOne

				move.l	GrayRgn,4(sp)			; Use GrayRgn as clobberedRgn
				IMPORT	GetRearWindow
				bsr		GetRearWindow			; Get rearmost WindowPtr in A1
				move.l	a1,8(sp)				; Change windowPtr parameter

				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns

				import	__PaintOne
				jmp		__PaintOne				; Return to our regularly scheduled _PaintOne

				ENDPROC

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; _SetCtlColor tests the control that was passed to it to see if it’s visible before it calling
; _Draw1Control. However, it doesn’t check to see if it was passed NIL first.  In these cases,
; _SetCtlColor hoses out completely.  Rewrite _SetCtlColor to check for that NIL handle before doing
; anything else.  If the handle is NIL, find the rearmost window, and call _PaintOne on it.  (We can
; save some time if we’re sure that only the frontmost window ever has active controls, in which case,
; we only have to re-paint the front window.)  If the handle is kosher, we can go on normally.

fixSetCtlColor	PatchProc	_SetCtlColor,(II,IIci)
				IMPORT	GetRearWindow

SetCtlColor
				MOVEM.L	A2/A3,-(SP)			;get some address registers
				MOVE.L	AuxCtlHead,A2		;get the list head
				LEA		AuxCtlHead,A3		;in case we need to deallocate
				jsrROM	SetGutsInROM

; Start of fix

				move.l	16(sp),d0			; Get control handle parameter
				bneROM	SetCtlColorAfterSetGuts	; If it wasn’t nil, go back to ROM

				bsr		GetRearWindow		; Returns rearmost window in A1
				move.l	a1,-(sp)			; Paint from the rearmost window on up
				move.l	GrayRgn,-(sp)		; Use the entire desktop as the clobbered region
				_PaintOne					; Draw all the windows

				jmpROM	SetEndInROM			; Call the ROM to exit _SetCtlColor
				ENDPROC
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
; fixSetWinColor and fixSetCtlColor both look for the rearmost window, so I pulled this out of
; fixSetWinColor, and made it a proc.

GetRearWindow	PROC
				move.l	WindowList,d0			; Get first window
				move.l	d0,a1
				beq.s	@gotLastWindow			; If no windows, exit loop

@findLastWindowLoop
				move.l	d0,a0
				tst.b	wVisible(a0)			; Is it visible?
				beq.s	@findNextVisibleWindow	; No, go on to the next one
				move.l	a0,a1					; Potential last visible window

@findNextVisibleWindow
				move.l	nextWindow(a0),d0		; Get next window
				bne.s	@findLastWindowLoop		; If there’s a window, branch back

@gotLastWindow
				rts
				ENDPROC

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; patchGetResource - automatically center windows, dialogs, and alerts
;
; This patch has been rolled into DialogMgr.a.
;

patchGetResource	ComeFromPatchProc	_GetResource

				CMPROM	FromGetNewWind,(SP)		; Check if we're coming from a window creating place
				BEQ.S	doPosPatch
				CMPROM	FromGetADHndl,(SP)
				BNEOLD

doPosPatch		MOVEM.L		D7/A3/A4/A6, -(SP)	; Save some regs for temps
				MOVEA.L		A7, A6				; Save the current stack pointer
				SUBQ.L		#$4, A7				; Make some space for return value from GetResource
				MOVE.L		22(A6), -(SP)		; Re-push the arguments
				MOVE.W		20(A6), -(SP)
				jsrOld							; Call Pre-patch GetResource
				MOVEA.L		(SP), A3			; Save the Handle in a temp
				TST.L		(SP)+				; check the return value
				BEQ.S		leavePatch			; If the Handle is NULL, run away
				MOVEA.L		(A3), A4			; Store the pointer in another temp
				CMPI.W		#$7FFC, (A4)		; Check if this template has already been fixed
				BEQ.S		leavePatch			; If it has then return it undisturbed.

				; Check the size of the dialog

				MOVEA.L		A3, A0				; Get Ready for a call to GetHandleSize
				_GetHandleSize					; put handle size in D0 for size check of template
				MOVE.L		D0, D7				; Save the value for later
				CMP.L		#'ALRT', 22(A6)		; if its an alert,...
				BNE.S		checkDLOG
				SUB.L		#$C, D0				; ... subtract the old alert size from the handle size
				BRA.S		checkSize
checkDLOG		MOVEQ.L		#0, D1
				CMP.L		#'DLOG', 22(A6)		; if its a dialog,...
				BNE.S		doWIND
				SUB.L		#$15, D0			; ... subrtact out the old DLOG size (0x14) plus length byte
				MOVE.B		$0014(A4), D1		; get the length of a dialog's title
				BRA.S		subtractString
doWIND			SUB.L		#$13, D0			; it must be a WIND so subtract out WIND size (0x12) plus length byte
				MOVE.B		$0012(A4), D1		; get the length of a window's title
subtractString	SUB.L		D1, D0				; subtract the title length from the handle size
checkSize		CMPI		#2, D0				; If the template is old, D0 will be 0, If it is new,...
				BLT.S		leavePatch			; ...it will be 2 (or more if an app is monkeying with the new template)
				SUB.L		D0, D7				; subract the size of the extra stuff from the length of the template
				BTST		#0, D7				; If this value is odd, it means that the string was of
				BEQ.S		addToAddr			; such a size as to require a byte filler for alignment
				ADDQ.L		#1, D7				; so we add one to D7 to allow for this
addToAddr		ADDA.L		D7, A4				; Advance the pointer to where the positioning word should be (will be even)
				MOVE.W		(A4), D1			; move the position word into D1 (D1's upper word is already zeroed)
				ANDI.W		#$7FF, D1			; get the position word's lower 11 bits.
				MOVEQ		#$A, D0				; move the signature into D0
				CMP.W		D0, D1				; compare the signature to the lower 11 bits of positioning data
				BNE.S		leavePatch			; If they are not zero, this is someone's old-style, non-standard template.

				; We've decided that this is a good, automatically-positioned template.
				; Now we're going to doctor it for NameAndPositionWindow.

				MOVEA.L		(A3), A0			; Get a pointer to the template data.

				MOVE.W		(A0), D0			; put height into template.bounds.bottom
				SUB.W		D0, 4(A0)

				MOVE.W		2(A0), D0			; put width into template.bounds.right
				SUB.W		D0, 6(A0)

				MOVE.W		#$7FFC, (A0)		; Move "Magic Cookie" into template.bounds.top
				MOVE.W		(A4), 2(A0)			; Move position information into template.bounds.left

leavePatch		MOVE.L		A3, 26(A6)			; return the handle to the (possibly doctored) template
				MOVEM.L		(SP)+, D7/A3/A4/A6	; restore temps

cleanupGetRsrc	MOVE.L	(SP)+, A0
				ADDQ.L	#6, SP
				JMP		(A0)

				ENDPROC
	ENDIF
	
;————————————————————————————————————————————————————————————————————————————————————————————————————
romMakeDeactive	PROC	EXPORT

				MOVE.L	(SP)+, A0				; Get return address
				MOVE.L	(SP), D0				; Rom takes parameter in D0
				MOVE.L	A0, (SP)				; Put return address on stack
				JMPROM	MakeDeactive

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
romCallWindow	PROC	EXPORT

				MOVEM.L	A3/D3, -(SP)			; Save A3 and D3
				MOVE.L	12(SP), D3				; D3 = parameter
				MOVE.W	16(SP), D0				; D0 = message
				MOVE.L	18(SP), A3				; A3 = window pointer
				JSRROM	CallWindow				; Go into ROM
				MOVEM.L	(SP)+, A3/D3			; Restore A3 and D3
				MOVE.L	(SP)+, A0				; Get return address
				ADDQ.L	#4, SP					; Clean up stack
				JMP		(A0)					; And go home

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
romCallWindowDraw	PROC	EXPORT

				MOVE.L	A3, -(SP)				; Save A3
				MOVE.L	8(SP), A3				; A3 = window pointer
				JSRROM	CallDWindow				; Go into ROM
				MOVE.L	(SP)+, A3				; Restore A3
				MOVE.L	(SP)+, A0				; Get return address
				ADDQ.L	#4, SP					; Clean up stack
				JMP		(A0)					; And go home

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
romCallWindowCalc	PROC	EXPORT

				MOVE.L	A3, -(SP)				; Save A3
				MOVE.L	8(SP), A3				; A3 = window pointer
				JSRROM	CallWCalc				; Go into ROM
				MOVE.L	(SP)+, A3				; Restore A3
				MOVE.L	(SP)+, A0				; Get return address
				ADDQ.L	#4, SP					; Clean up stack
				JMP		(A0)					; And go home

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
romInsertWindow	PROC	EXPORT

				JMPROM	InsertWindow

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
; Sets up the background color for PaintAction.  Uses code in ROM.
SetUpBackColor	PROC	EXPORT

				MOVEQ.L	#wContentColor, D0		; Use the content color
				MOVE.L	4(SP), A0				; A0 = window pointer
				JSRROM	SetUpColor
				_RGBBackColor
				RTS

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
; This routine does everything needed to paint the desk, including switching to the system
; heap in case of pattern expansion.
PaintDesk		PROC	EXPORT

				MOVE.L	DeskHook,D0 			;user got a deskPaint routine?
				BEQ.S	@NoDeskHook				;if not, paint gray

; a routine is installed in the deskHook so invoke it to do the painting
				MOVE.L	D0,A0					;get deskPaint address
				MOVEQ	#0,D0					;flag its a paint call
				JMP 	(A0)					;let the user do the painting

; no deskPainting routine was installed so paint it the standard desk pattern
@NoDeskHook
				CMP.W	#$3FFF,ROM85			;color machine ?
				BLS.S	@color					;no
				MOVE.L	GrayRgn,-(SP)			;push the desktop region
				PEA		DeskPattern				;and the desktop pattern
				_FillRgn						;now fill it
				RTS

@color
				MOVE.L	TheZone,-(SP)
				MOVE.L	SysZone,TheZone
				JSRROM	NoDeskHook
				MOVE.L	(SP)+,TheZone
				RTS

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
; Called by several window manager routines that need to have the current layer saved,
; set and restored.
LayerBracket	PROC	ENTRY

;	A0		= address of routine to "bracket"
;	D0.L	= address of window who's parent should be the current layer
;	D1.W	= number of words of stack to preserve (parameters + return value)
; Stack:
;		|-------------------|
;		|	D1.W words		|
;		|	of "parameters"	|
;		|-------------------|
;		|	return address	|
;		|-------------------| <- SP

				MOVE.L	(SP), D2				; Save the return address in D2.
				SUBQ.L	#8, SP					; We'll need 8 more bytes on the stack.
				MOVE.L	SP, A1					; Destination of move in A1.
				MOVE.L	A0, -(SP)				; Push the routine we'll call on the stack.
				LEA		12(A1), A0				; Source of move in A0.
				BRA.S	@downDBRA				; Start the copy.
@copyDownLoop
				MOVE.W	(A0)+, (A1)+			; Copy a word down.
@downDBRA		DBRA	D1, @copyDownLoop		; Loop until we're done.

; Now the stack looks like this:
;		|-------------------| <- A1
;		|	12 bytes of		|
;		|	free space		|
;		|-------------------| <- A0
;		|	saved			|
;		|	"parameters"	|
;		|-------------------|
;		|	WMgr routine	|
;		|-------------------| <- SP
;	D0.L	= address of window who's parent should be the current layer
;	D1.W	= -1
;	D2.L	= return address

				MOVE.L	A6, (A1)
				MOVE.L	A1, A6					; Make a stack frame at A1.
				MOVE.L	D2, 4(A6)				; Save the return address at 4(A6).
				SUBQ.L	#4+4, SP				; Save space for results.
				MOVE.L	D0, -(SP)				; Get window for GetParent.
				
	IF hasLayerlessApps THEN
				IMPORT	__patchGetParent
				JSR		__patchGetParent		; Get the parent.
	ELSE
				IMPORT	__GetParent
				JSR		__GetParent				; Get the parent.
	ENDIF
	
				IMPORT	__SwapCurLayer
				JSR		__SwapCurLayer			; Swap the layer and get the old layer.
				MOVE.L	(SP)+, 8(A6)			; Save the old current layer at 8(A6).
				MOVE.L	(SP)+, A0				; Get the window manager routine.
				JSR		(A0)					; And call it.

; We've completed the window manager routine.  The stack looks like this:
;		|-------------------|
;		|	old CurLayer	|
;		|-------------------|
;		|	return address	|
;		|-------------------|
;		|	old A6			|
;		|-------------------| <- A6
;		|	return value	|
;		|-------------------| <- SP

				MOVE.L	8(A6), -(SP)			; Get window for SetCurLayer.
				_SetCurLayer					; Set it back.
				MOVE.L	4(A6), D2				; Save the return address in D2.
				MOVE.L	A6, A0					; Source of move in A0.
				MOVE.L	(A6), A6				; Remove the stack frame.
				MOVE.L	A0, D1
				SUB.L	SP, D1					; D1 is number of bytes to move back up.
				ASR.L	#1, D1					; Divide by two for word count.
				LEA		12(A0), A1				; Destination of move in A1.
				BRA.S	@upDBRA					; Start the copy.
@copyUpLoop
				MOVE.W	-(A0), -(A1)			; Copy a word up.
@upDBRA			DBRA	D1, @copyUpLoop			; Loop until we're done.
				MOVE.L	A1, SP					; Peel back the stack.
				MOVE.L	D2, A0					; Get the return address.
				JMP		(A0)					; And return.

				ENDPROC

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
patchInitWindows	PatchProc	_InitWindows

				subq	#2,sp					; Make room for error result.
				IMPORT	__InitLayers
				JSR		__InitLayers
				addq	#2,sp
				rts

				EXPORT	oldInitWindows
oldInitWindows
				JMPOLD

				ENDPROC
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
patchBeginUpdate	PatchProc	_BeginUpdate
				EXPORT	oldBeginUpdate

				MOVE.L	4(SP), WMgrUpdate		; Copy the window pointer to a safe place.

				IMPORT	__BeginUpdate
				JMP		__BeginUpdate

				EXPORT	oldBeginUpdate
oldBeginUpdate
				JMPOLD

				ENDPROC

patchEndUpdate	PatchProc	_EndUpdate

				MOVE.L	WMgrUpdate, D0
				CMP.L	4(SP), D0				; Is it the right window?
				BNE.S	goCalcVis				; Just CalcVis if not.

				CLR.L	WMgrUpdate				; Clear the global.

				EXPORT	oldEndUpdate
oldEndUpdate	JMPOLD							; Do the EndUpdate.

goCalcVis
	IF hasLayerlessApps THEN
				IMPORT	__patchCalcVis
				JMP		__patchCalcVis
	ELSE
				IMPORT	__CalcVis
				JMP		__CalcVis
	ENDIF

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
patchClipAbove	PatchProc	_ClipAbove

	IF hasLayerlessApps THEN
				IMPORT	__patchClipAbove
				JMP		__PatchClipAbove
	ELSE
				IMPORT	__ClipAbove
				JMP		__ClipAbove

				EXPORT	oldClipAbove
oldClipAbove
				JMPOLD
	ENDIF

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
patchPaintOne	PatchProc	_PaintOne

				IMPORT	__PaintOne
				JMP		__PaintOne

				EXPORT	oldPaintOne
oldPaintOne		JMPOLD

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
patchPaintBehind	PatchProc	_PaintBehind

	IF hasLayerlessApps THEN
					Import	__patchPaintBehind
					jmp		__patchPaintBehind
	ELSE
					Import	__PaintBehind
					jmp		__PaintBehind
	ENDIF

					EndProc

;————————————————————————————————————————————————————————————————————————————————————————————————————
patchCloseWindow	PatchProc	_CloseWindow

				IMPORT	__CloseWindow
				JMP		__CloseWindow

				EXPORT	oldCloseWindow
oldCloseWindow
				JMPOLD

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————

;				MakePatch __CheckUpdate,_CheckUpdate
;				
;	IF hasLayerlessApps THEN
;				MakePatch __patchCalcVis,_CalcVis
;				MakePatch __patchCalcVisBehind,_CalcVBehind
;	ELSE
;				MakePatch __CalcVis,_CalcVis
;				MakePatch __CalcVisBehind,_CalcVBehind
;	ENDIF
;				MakePatch __FrontWindow,_FrontWindow

;————————————————————————————————————————————————————————————————————————————————————————————————————
__NewWindow		PatchProc	_NewWindow

				MOVE.L	(SP)+, A0
				CLR.B	-(SP)
				MOVE.L	A0, -(SP)
				IMPORT	NewWindowCommon
				JMP		NewWindowCommon

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__NewCWindow	PatchProc	_NewCWindow,(II,IIci)

				MOVE.L	(SP)+, A0
				ST		-(SP)
				MOVE.L	A0, -(SP)
				IMPORT	NewWindowCommon
				JMP		NewWindowCommon

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__SelectWindow	PatchProc	_SelectWindow

				EXPORT		oldSelectWindow
oldSelectWindow	LEAOLD	A0
				IMPORT	TwoByFour
				JMP		TwoByFour

				ENDPROC

	IF NOT hasLayerlessApps THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
__BringToFront	PatchProc	_BringToFront

				EXPORT		oldBringToFront
oldBringToFront	LEAOLD	A0
				IMPORT	TwoByFour
				JMP		TwoByFour

				ENDPROC
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
__SendBehind	PatchProc	_SendBehind

				EXPORT		oldSendBehind
oldSendBehind	LEAOLD	A0
				IMPORT	FourByEight
				JMP		FourByEight

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__ShowWindow	PatchProc	_ShowWindow

				EXPORT		oldShowWindow
oldShowWindow	LEAOLD	A0
				EXPORT	TwoByFour
TwoByFour
				MOVEQ.L	#2, D1
				MOVE.L	4(SP), D0
				IMPORT	LayerBracket
				JMP		LayerBracket

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__DragWindow	PatchProc	_DragWindow

				EXPORT		oldDragWindow
oldDragWindow	LEAOLD	A0
				MOVEQ.L	#6, D1
				MOVE.L	12(SP), D0
				IMPORT	LayerBracket
				JMP		LayerBracket

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__MoveWindow	PatchProc	_MoveWindow

				EXPORT		oldMoveWindow
oldMoveWindow	LEAOLD	A0
				MOVEQ.L	#5, D1
				MOVE.L	10(SP), D0
				IMPORT	LayerBracket
				JMP		LayerBracket

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__ZoomWindow	PatchProc	_ZoomWindow

				EXPORT		oldZoomWindow
oldZoomWindow	LEAOLD	A0
				EXPORT	FourByEight,WindowAt8
FourByEight		MOVEQ.L	#4, D1
WindowAt8		MOVE.L	8(SP), D0
				IMPORT	LayerBracket
				JMP		LayerBracket

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__GetAuxWin		PatchProc	_GetAuxWin,(II,IIci)

				EXPORT		oldGetAuxWin
oldGetAuxWin	LEAOLD	A0
				MOVEQ.L	#5, D1
				IMPORT	WindowAt8
				JMP		WindowAt8

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__SetWinColor	PatchProc	_SetWinColor,(II,IIci)

				EXPORT		oldSetWinColor
oldSetWinColor	LEAOLD	A0
				IMPORT	FourByEight
				JMP		FourByEight

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__SetCtlColor	PatchProc	_SetCtlColor,(II,IIci)

				EXPORT		oldSetCtlColor
oldSetCtlColor	LEAOLD	A0
				MOVEQ.L	#4, D1
				IMPORT	ControlOwner
				JMP		ControlOwner

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
__GetAuxCtl		PatchProc	_GetAuxCtl,(II,IIci)

				EXPORT		oldGetAuxCtl
oldGetAuxCtl	LEAOLD	A0
				MOVEQ.L	#5, D1
				EXPORT	ControlOwner
ControlOwner
				MOVE.L	8(SP), D0
				IMPORT	LayerBracket
				BEQ.S	@LayerBracket
				MOVE.L	D0, A1
				MOVE.L	(A1), A1
				MOVE.L	contrlOwner(A1), D0
@LayerBracket
				JMP		LayerBracket

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————
patchFindWindow	PatchProc	_FindWindow

				IMPORT	__FindWindow
				JMP		__FindWindow

				EXPORT	__FindLayer
__FindLayer		JMPOLD

				ENDPROC

;————————————————————————————————————————————————————————————————————————————————————————————————————

__DrawNew		PatchProc	_DrawNew

				EXPORT	oldDrawNew
oldDrawNew		LEAOLD	A0
				MOVEQ.L	#3, D1
				MOVE.L	6(SP), D0
				IMPORT	LayerBracket
				JMP		LayerBracket

				EndProc

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————

SetWTitleActivatePalette ComeFromPatchProc _UnionRgn,AfterUnionRgnInSetWTitle,(II,IIci)

				move.l	a3,-(sp)				; pass the window pointer
				_ActivatePalette				; go tell the Palette Mgr to think about this window

				JMPOLD

				EndProc
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————

LayerDispatch	BeginDispatcher _LayerDispatch
				DispatchSelectors __GlobalPortRect = selectGlobalPortRect
				DispatchSelectors __PaintOnePal = selectPaintOnePal
				DispatchSelectors __EachWindow = selectEachWindow
	IF hasLayerlessApps THEN
				DispatchSelectors __patchGetParent = selectGetParent
	ELSE
				DispatchSelectors __GetParent = selectGetParent
	ENDIF
				DispatchSelectors __WindowType = selectWindowType
				DispatchSelectors __GetDeskPort = selectGetDeskPort
				DispatchSelectors __CheckUpdateIn = selectCheckUpdateIn
				DispatchSelectors __FrontWindowIn = selectFrontWindowIn
				DispatchSelectors __ActiveWindow = selectActiveWindow
				DispatchSelectors __GetRootLayer = selectGetRootLayer
				DispatchSelectors __InitLayers = selectInitLayers
				DispatchSelectors __NewLayer = selectNewLayer
				DispatchSelectors __IsLayer = selectIsLayer
				DispatchSelectors __GetCurLayer = selectGetCurLayer
				DispatchSelectors __SetCurLayer = selectSetCurLayer
				DispatchSelectors __SwapCurLayer = selectSwapCurLayer
				DispatchSelectors __GetSubWindows = selectGetSubWindows
	IF hasLayerlessApps THEN
				DispatchSelectors __patchFindLayer = selectFindLayer
	ELSE
				DispatchSelectors __FindLayer = selectFindLayer
	ENDIF
				DispatchSelectors __PositionWindow = selectPositionWindow
				DispatchSelectors __AutoPositionWindow = selectAutoPositionWindow
				DispatchSelectors __GetWindowState = selectGetWindowState
				DispatchSelectors __SetWindowState = selectSetWindowState
				DispatchSelectors __CheckWindow = selectCheckWindow
				DispatchSelectors __RedrawAll = selectRedrawAll
				EndDispatcher

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————

InitFasterInvals InstallProc

				Import	AlwaysRectRgn

				subq	#4,sp				;make room for region handle
				_NewRgn
				lea		AlwaysRectRgn,a0
				move.l	(sp)+,(a0)			;store away the region handle
				rts

				EndProc
	ENDIF
	
	IF NOT hasLayerlessAppsINIT THEN
	
				MakePatch FasterInvalRect,_InvalRect
				MakePatch FasterValidRect,_ValidRect

FasterInvals	Proc

				Export	FasterInvalRect,FasterValidRect
				Export	AlwaysRectRgn

AlwaysRectRgn	dc.l	0					;put region handle here

FasterValidRect
				moveq	#-1,d0				;flag it as a valid
				bra.s	IRectCommon
FasterInvalRect
				moveq	#0,d0				;flag that it’s an inval
IRectCommon
				move.l	4(sp),a0			;get pointer to rectangle
				move.l	AlwaysRectRgn,a1	;get handle to region
				move.l	a1,-(sp)			;pass it on the stack to IvalCommon
				move.l	(a1),a1
				add		#rgnBBox,a1			;advance to the bounding box
				move.w	left(a0),d1			;											<37>
				cmp.w	right(a0),d1		;if a vertical line							<37>
				bge.s	@emptyRgn			;	fill in empty rgn						<37>
				move.w	top(a0),d1			;											<37>
				cmp.w	bottom(a0),d1		;if a horizontal line						<37>
				bge.s	@emptyRgn			;	fill in empty rgn						<37>
				move.l	(a0)+,(a1)+			;smash in the rectangle
				move.l	(a0),(a1)
				bra.s	@doInval			;											<37>
@emptyRgn		clr.l	(a1)+				;empty rgn									<37>
				clr.l	(a1)				;											<37>
@doInval									;											<37>
				jsrROM	IvalCommon			;must JSR, since he expects a return address
				move.l	(sp)+,(sp)			;get rid of rectangle pointer
				rts

				EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; LoadResource — do a system error if we try to load a WDEF resource and fail

SysErrorIfNoWDEF ComeFromPatchProc _LoadResource,AfterLoadResourceInCallWindow,(Plus,SE,II)

				addq	#4,sp				; get rid of the return address
				jsrOld						; call LoadResource
				tst.l	(a0)				; is the handle we just tried to load still empty?
				bnzROM	AfterLoadResourceInCallWindow	; no, go back to the ROM
				moveq	#dsWDEFNotFound,D0	; get error code
				_SysError

				EndProc
	ENDIF
	
	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; SectRgn - test lo-mem PaintWhite (word) to see whether we want to paint the window content

CheckPaintWhiteWord	ComeFromPatchProc	_SectRgn,AfterSectRgnInGoPaintOne

				addq.l		#4,sp				; get rid of the return address
				jsrOld							; SectRgn
				tst.w		PaintWhite			; Do we want to paint white?
				beqROM		SkipEraseInROM		; no => Skip erase and continue on
				jmpROM		EraseInROM			; yes => go erase the region

				EndProc
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
; PaintBehind in DrawNew - since we have done CalcAncestorRgns in _PaintOne, we can do a PaintBehindLite

PaintBehindInDrawNew	ComeFromPatchProc	_PaintBehind,AfterPaintBehindInDrawNew

	IF hasLayerlessApps THEN
				SUBQ.L	#4, SP
				MOVE.L	A2, -(SP)
				IMPORT	GetNextWindow
				JSR		GetNextWindow
				MOVE.L	(SP)+, 8(SP)
	ELSE
				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns
	ENDIF
				jmpOld

				EndProc

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; PaintBehind in SendBehind - since SendBehind doesn't affect the structRgn, no need to recalc ancestors.

PaintBehindInSendBehind	ComeFromPatchProc	_PaintBehind,AfterPaintBehindInSendBehind

				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns
				jmpOld

				EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; PaintOne in SetDeskCPat - since SetDeskCPat doesn't affect the structRgn, no need to recalc ancestors.

PaintOneInSetDeskCPat	ComeFromPatchProc	_PaintOne,AfterPaintOneInSetDeskCPat,(II,IIci)

				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns
				jmpOld

				EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; PaintOne in MoveWindow - since we have done CalcAncestorRgns in _PaintBehind, we can do a PaintOneLite

PaintOneInMoveWindow	ComeFromPatchProc	_PaintOne,AfterPaintOneInMoveWindow

				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns
				jmpOld

				EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; PaintOne in BringToFront - since BringToFront doesn't affect the structRgn, no need to recalc ancestors.

PaintOneInBringToFront	ComeFromPatchProc	_PaintOne,AfterPaintOneInBringToFront

				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns
				jmpOld

				EndProc
	ENDIF

	IF NOT hasLayerlessAppsINIT THEN
;————————————————————————————————————————————————————————————————————————————————————————————————————
; PenMode in DragTheRgn - set the pen size to (1,1) after PenMode in DragTheRgn so that the outline
;							will be drawn with the expected thickness.

PenModeInDragTheRgn		ComeFromPatchProc	_PenMode,AfterPenModeInDragTheRgn

				move.l	OneOne,-(sp)	; get desired pen size
				_PenSize				; set it
				jmpOld					; PenMode

				EndProc
	ENDIF

;————————————————————————————————————————————————————————————————————————————————————————————————————
; CalcVBehind in SendBehind

; If SendBehind is actually moving a window to the front, we should paint starting with the window
; that ends up behind the window we are moving instead of the window that was behind it before we
; moved anything. To do this, we get the new “behind” window in A3, and then look through the list.
; If we never see that window in A3, then we know we should start painting there, but if we do see
; it, then we use the old code which paints from the old front window.

CalcVBehindInSendBehind	ComeFromPatchProc	_CalcVBehind,AfterCalcVBehindInSendBehind

; This checks to see if we are sent the window towards the back of the list, or towards the front.
; If we moved it back, we will find the window that is now behind it while walking to the end of the
; list, starting from the window that was behind it. If we find that we moved the window towards the
; back, we rejoin the ROM code, which handles that case nicely. If not, we use the new code below.

	IF hasLayerlessApps THEN
				IMPORT	GetNextWindow
	ENDIF

				move.l	8(sp),d0			; get the window that was behind the window we are moving
				bra.s	@start				; start with the NIL check
@loop
				cmp.l	d0,a3				; check if we find the window that is behind 	<34><35>
				beqOld						; we are moving window to the back (use ROM)
				move.l	d0,a0
				move.l	nextWindow(a0),d0
@start
				bne.s	@loop				; if we have another window, go looping

CalcUsAndPaintUs
; <34>
; Since we moved the window forward, nothing needs to be repainted except for the window we
; moved, which may now be exposed more. First, we calculate the visRgns of the moved window and all
; the windows behind it using CalcVBehind and the strucRgn of the moved window. Then, we figure out
; what part of the window was exposed by adding up all the strucRgns of the windows that it was
; moved in front of. We then use PaintOne to paint the window, but we set the flag that prevents
; CalcAncestorRgns, since this can never change the total region of windows in the layer.

				; kill the parameters to CalcVBehind and PaintBehind

				lea		12(sp),sp			; kill return address, region handle, and window pointer
				move.l	(sp)+,a0			; get window that was behind the window we moved	<36>
				movem.l	a2/a4,-(sp)			; save registers we use								<36>
				move.l	a0,a4				; keep window pointer in a non-volatile register	<36>

				move.l	a3,-(sp)			; calc the windows behind me (use up the return address)
				move.l	d3,-(sp)
				_CalcVBehind

				; Union strucRgns of all windows that used to be in front of the window that moved,
				; but are now behind it. We can find these windows by starting behind where the
				; window is now, and stopping when we get where it was before it moved.

	IF hasLayerlessApps THEN
				SUBQ.L	#4, SP
				MOVE.L	A3, -(SP)
				JSR		GetNextWindow
				MOVE.L	(SP)+, D0			; start behind us
	ELSE
				move.l	nextWindow(a3),d0	; start behind us
	ENDIF
				beq.s	Done				; if nothing is behind us, we are done
				move.l	d0,a2				; start with this window

				subq	#4,sp
				_NewRgn
				move.l	(sp)+,d3			; get a new region for unioning

@loop
				cmp.l	a2,a4				; check if we are done yet							<36><39>
				beq.s	@doneUnionRgns		; if done => exit loop									<39>
				move.l	structRgn(a2),-(sp)	; get the strucRgn
				move.l	d3,-(sp)			; union with our region
				move.l	d3,-(sp)			; destination in our region
				_UnionRgn
	IF hasLayerlessApps THEN
				SUBQ.L	#4, SP
				MOVE.L	A2, -(SP)
				JSR		GetNextWindow
				MOVE.L	(SP)+, A2			; move to next window (will never be NIL before the end)
	ELSE
				move.l	nextWindow(a2),a2	; move to next window (will never be NIL before the end)
	ENDIF
				bra.s	@loop				;														<39>
@doneUnionRgns								;														<39>

				; Now we have a region including all windows that used to cover the window that
				; moved but don’t cover it any more. By calling PaintOne with this region, we redraw
				; only the newly revealed part of the window that moved.

				move.l	a3,-(sp)
				move.l	d3,-(sp)			; paint the newly exposed part of the moved window
				move.l	ExpandMem,a0
				st		ExpandMemRec.ancestorRgnsCalced(a0)	; set the one-shot to keep from recalcing ancestor rgns
				_PaintOne

				move.l	d3,-(sp)
				_DisposeRgn					; get rid of that region
Done
				; Return to the ROM after PaintBehind because we did PaintOne instead.

				movem.l	(sp)+,a2/a4			; restore registers									<36>

				jmpROM	AfterPaintBehindInSendBehind

				EndProc

;————————————————————————————————————————————————————————————————————————————————————————————————————
; <41> ActivatePalette — ActivatePalette assumes that the window is in the WindowList (i.e. CurLayer).
;						Therefore, we have to call LayerBracket before ActivatePalette.

ActivatePaletteLayerBracket		PatchProc	_ActivatePalette,(II,IIci)

				EXPORT	oldActivatePal
oldActivatePal	LEAOLD	A0
				IMPORT	TwoByFour
				JMP		TwoByFour

				ENDPROC
				
	IF NOT hasLayerlessAppsINIT THEN
	
_NewHandleSys	OPWORD	$A522

;————————————————————————————————————————————————————————————————————————————————————————————————————
; setUpPatchInfo - collects up the addresses of all patched routines and their call-through adresses

setUpPatchInfo	InstallProc

patchData		RECORD	0
fixBeginUpdate	DS.L	2
fixEndUpdate	DS.L	2
fixPaintOne		DS.L	2
fixCloseWindow	DS.L	2
fixSelectWindow	DS.L	2
fixBringToFront	DS.L	2
fixSendBehind	DS.L	2
fixShowWindow	DS.L	2
fixDragWindow	DS.L	2
fixMoveWindow	DS.L	2
fixZoomWindow	DS.L	2
fixGetAuxWin	DS.L	2
fixSetWinColor	DS.L	2
fixSetCtlColor	DS.L	2
fixGetAuxCtl	DS.L	2
fixFindWindow	DS.L	2
fixDrawNew		DS.L	2
fixActivatePal	DS.L	2
fixShowHide		DS.L	2
size			EQU		*	
				ENDR

				MOVE.L	#patchData.size, D0
				_NewHandleSys
				MOVE.L	ExpandMem, A1
				MOVE.L	A0, ExpandMemRec.emWindowListGlobals(A1)
				MOVE.L	(A0), A0

; short circuit the patch on BeginUpdate
				IMPORT	patchBeginUpdate
				LEA		patchBeginUpdate, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldBeginUpdate
				LEA		oldBeginUpdate, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on EndUpdate			
				IMPORT	patchEndUpdate
				LEA		patchEndUpdate, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldEndUpdate
				LEA		oldEndUpdate, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on PaintOne			
				IMPORT	patchPaintOne
				LEA		patchPaintOne, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldPaintOne
				LEA		oldPaintOne, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on CloseWindow			
				IMPORT	patchCloseWindow
				LEA		patchCloseWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldCloseWindow
				LEA		oldCloseWindow, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on SelectWindow			
				IMPORT	__SelectWindow
				LEA		__SelectWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldSelectWindow
				LEA		oldSelectWindow, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on BringToFront			
				IMPORT	__BringToFront
				LEA		__BringToFront, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldBringToFront
				LEA		oldBringToFront, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on SendBehind			
				IMPORT	__SendBehind
				LEA		__SendBehind, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldSendBehind
				LEA		oldSendBehind, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on ShowWindow			
				IMPORT	__ShowWindow
				LEA		__ShowWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldShowWindow
				LEA		oldShowWindow, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on DragWindow			
				IMPORT	__DragWindow
				LEA		__DragWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldDragWindow
				LEA		oldDragWindow, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on MoveWindow			
				IMPORT	__MoveWindow
				LEA		__MoveWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldMoveWindow
				LEA		oldMoveWindow, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on ZoomWindow			
				IMPORT	__ZoomWindow
				LEA		__ZoomWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldZoomWindow
				LEA		oldZoomWindow, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on GetAuxWin			
				IMPORT	__GetAuxWin
				LEA		__GetAuxWin, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldGetAuxWin
				LEA		oldGetAuxWin, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on SetWinColor			
				IMPORT	__SetWinColor
				LEA		__SetWinColor, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldSetWinColor
				LEA		oldSetWinColor, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on SetCtlColor			
				IMPORT	__SetCtlColor
				LEA		__SetCtlColor, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldSetCtlColor
				LEA		oldSetCtlColor, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on GetAuxCtl			
				IMPORT	__GetAuxCtl
				LEA		__GetAuxCtl, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldGetAuxCtl
				LEA		oldGetAuxCtl, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on FindWindow			
				IMPORT	patchFindWindow
				LEA		patchFindWindow, A1
				MOVE.L	A1, (A0)+
				IMPORT	__FindLayer
				LEA		__FindLayer, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on DrawNew			
				IMPORT	__DrawNew
				LEA		__DrawNew, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldDrawNew
				LEA		oldDrawNew, A1
				MOVE.L	2(A1), (A0)+ 
				
; short circuit the patch on ActivatePalette		
				IMPORT	ActivatePaletteLayerBracket
				LEA		ActivatePaletteLayerBracket, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldActivatePal
				LEA		oldActivatePal, A1
				MOVE.L	2(A1), (A0)+ 

; short circuit the patch on ShowHide		
				IMPORT	patchShowHide
				LEA		patchShowHide, A1
				MOVE.L	A1, (A0)+
				IMPORT	oldShowHide
				LEA		oldShowHide, A1
				MOVE.L	2(A1), (A0)+ 
				
				RTS

				ENDPROC
	ENDIF

				END
