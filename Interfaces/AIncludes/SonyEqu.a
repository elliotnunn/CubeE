;
;	File:		SonyEqu.a
;
;	Contains:	xxx put contents here xxx
;
;	Written by:	xxx put writers here xxx
;
;	Copyright:	© 1991-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM5>	  8/3/93	BH		Added drive queue flag (dqManEjBit) for manually ejectable
;									device.
;	   <SM4>	 12/7/92	rab		Roll in Horror changes. Comments follow…
;		<H6>	  8/4/92	SWC		Increased the maximum head settling time to 100ms so
;									slower-stepping drives won't try to read/write data before
;									they're really ready.
;		<H5>	 2/25/92	CMP		Added new status code to support speed check status call.
;		<H4>	 2/13/92	CMP		Added a new control code for enabling/disabling retries and a
;									global flag to indicate if retries are enabled.
;		<H3>	 1/21/92	CMP		Added support for 32Mhz clock to SWIM2.
;	   <SM3>	 5/17/92	kc		Turn off onMac if undefined.
;	   <SM2>	 4/16/92	JSM		Roll-in change from Reality:
;									 <5>	 4/14/92	DTY		Fix up conditionals so the right offsets get generated for the
;																System build.  Moved extra stuff that was in the internal
;																version of SonyEqu.a into this file, so we can get rid of the
;																internal version.
;		 <4>	 10/1/91	JSM		Don’t use onMvMac conditional, Modern Victorian never existed.
;		 <3>	 1/30/91	gbm		sab, #38: Change the ‘already including this file’ variable to
;									all uppercase (for security reasons)
;

; Version: 3.23
; Created: Friday, October 20, 1989 at 9:52:02 PM
;
; File: SonyEqu.a
;
; Assembler Interface to the Macintosh Libraries
; Copyright Apple Computer, Inc. 1984-1990
; All Rights Reserved
;
;--------------------------------------------------------------------
;
; The following information was formerly in "private" files that were
; not released to the general developer community.
;
; The information in this file is not needed for normal application
; development. These equates and macros were necessary for development
; of the Macintosh ToolBox and Operating System, and are likely to be
; dependent on their current implementation. Use of any information
; in this file is likely to cause your software to fail on future
; versions of Macintosh system software or hardware.
;
; Apple Developer Support will not support any use of the following
; information.
;
; In order to prevent any "accidental" use of this information, it has
; been disabled using the conditional-assembly variable defined below.
; If you change this to a non-zero value, you're on your own.
;--------------------------------------------------------------------

	IF &TYPE('__INCLUDINGSONYEQU__') = 'UNDEFINED' THEN
__INCLUDINGSONYEQU__	SET	1

; If SonyNonPortable is defined to be non-zero, Then a machine type must be specified!

  				IF  		(&TYPE('SonyNonPortable') = 'UNDEFINED') THEN
SonyNonPortable   EQU 		0
  				ENDIF

  				IF  		(&TYPE('onMac') = 'UNDEFINED') THEN 
onMac 			EQU 		0		; <SM3>
  				ENDIF

  				IF  		(&TYPE('onMacPP') = 'UNDEFINED') THEN
onMacPP   		EQU 		0
  				ENDIF

  				IF  		(&TYPE('onNuMac') = 'UNDEFINED') THEN
onNuMac   		EQU 		0
  				ENDIF

          IF      (&TYPE('onHafMac') = 'UNDEFINED') THEN
onHafMac      EQU     0
          ENDIF

  				IF  		(&TYPE('onHcMac') = 'UNDEFINED') THEN
onHcMac   		EQU 		0
  				ENDIF

          IF      (&TYPE('onMac16') = 'UNDEFINED') THEN
onMac16       EQU     0
          ENDIF

          IF      (&TYPE('onMac32') = 'UNDEFINED') THEN
onMac32       EQU     0
          ENDIF

; forDiskDup should be set to 0 for most uses

  				IF  		(&TYPE('forDiskDup') = 'UNDEFINED') THEN
forDiskDup		EQU 		forROM					; Only significant for ROM builds.
  				ENDIF

; Note: supportsDCD means support for pass-thru connector as well.
; If this is 1, firstDCD and maxDCDcnt equates are needed as well.
; GetDrive must be adjusted for number of drives, as well!

  				IF  		onMac THEN
supportsPWM   	EQU 		1         				; set to 1 if PWM supported
maxDrvNum 		EQU 		4
supportsDCD   	EQU 		1         				; set to 1 to include DCD code
firstDCD  		EQU 		3
maxDCDcnt 		EQU 		2
iwmMode   		EQU 		$1F
  				ENDIF

  				IF  		onMacPP THEN
supportsPWM   	EQU 		1         				; set to 1 if PWM supported
maxDrvNum 		EQU 		5
supportsDCD   	EQU 		1         				; set to 1 to include DCD code
firstDCD  		EQU 		4
maxDCDcnt 		EQU 		2
iwmMode   		EQU 		$17       				; changed for Brian Howard to set half speed
; <?? same as Mac ??>
  				ENDIF

  				IF  		(&TYPE('onNuMacDCD') = 'UNDEFINED') THEN
onNuMacDCD		EQU 		0
  				ENDIF

  				IF  		onNuMac THEN
supportsPWM   	EQU 		0         				; set to 1 if PWM supported
  				IF  		onNuMacDCD THEN
maxDrvNum 		EQU 		4
supportsDCD   	EQU 		1         				; set to 1 to include DCD code
firstDCD  		EQU 		3
maxDCDcnt 		EQU 		2
  				ELSE
maxDrvNum 		EQU 		2
supportsDCD   	EQU 		0         				; set to 1 to include DCD code
  				ENDIF
iwmMode   		EQU 		$17
  				ENDIF

  				IF  		onHcMac THEN
supportsPWM   	EQU 		0         				; set to 1 if PWM supported
maxDrvNum 		EQU 		5
supportsDCD   	EQU 		1         				; set to 1 to include DCD code
firstDCD  		EQU 		4
maxDCDcnt 		EQU 		2
iwmMode   		EQU 		$17
  				ENDIF


  				IF  		SonyNonPortable THEN

  				IF  		(&TYPE('supportsMFM') = 'UNDEFINED') THEN
supportsMFM   	EQU 		0
  				ENDIF

; SonyVars Data Structure (offsets):
; (1) Driver local vars.
; (2) Drive-specific vars.
; (3) More driver local vars.
; (4) Direct-connect driver locals.
;
; Drive Constants:
; (1) Floppy drive constants (tuneable).
; (2) Floppy drive sense/control constants.
; (3) Floppy drive formatting constants.
; (4) Direct-connect drive constants.
;
; Driver Constants:
; (1) Driver Control codes.
;
; Driver Vectors:
; (1) Location of disk routine vectors.
;
;_______________________________________________________________________

;_______________________________________;
; ;
; SonyVars Data Structure (offsets): ;
;_______________________________________;

;_______________________________________;
;
; (1) Driver local vars. ; * = known to be used in a copy-
; protection scheme.
; +---------------------+ DiskUnitPtr <-----+
; | | |
; | "driver local vars" | |
; | | EjectWait |
; +---------------------+ <----+ |
; | | Track | |
; | drive1 | DrvLclLth |
; | | DriveMisc | |
; +---------------------+ <----+ |
; | | Track |
; | drive2 | Sony disk driver
; | | DriveMisc vars, plus
; +---------------------+ locals for each
; | | Track diskette drive
; | driveX | |
; | | DriveMisc |
; +---------------------+ |
; | | FloppyLclEnd |
; | "more driver vars" | |
; | | SonyVarEnd <-----+
; +---------------------+ <-----+
; | | Track |
; | driveN | |
; | | DriveMisc |
; +---------------------+
; | | DCD driver vars
; | driveN | plus locals for
; | | each DCD drive
; +---------------------+ |
; | | DCDCmd |
; | DCD driver locals | |
; | | DiskVarLth <-----+
; +---------------------+
;
;_______________________________________________________________________
;

  				IF  		supportsMFM THEN
mfmSectTime   	EQU 		75    					;7.5msec sector time
maxMFMSectors 	EQU 		18    					;18 MFM sectors/track side (@1440K)
  				ENDIF
				
maxGCRSectors 	EQU 		12        				;12 GCR sectors/track side (max)
diskUnitPtr   	EQU 		0         				; pointer to device control entry
diskQVE   		EQU 		diskUnitPtr+4     		; disk VBL task control block
drive 			EQU 		diskQVE+14    			; * 0001 = int drive, 0002 = ext drive
wait  			EQU 		drive+2       			; extra wait time for speed changes
sideTrack 		EQU 		wait+2        			; destination side/track
oneToOne  		EQU 		sideTrack+2       		; open up rupts flg (no longer used)
active			EQU 		oneToOne+1    			; * non-zero when driver is active
timeOut   		EQU 		active+1      			; * power time out
diskBuffer		EQU 		timeOut+2     			; pointer to track data buffer
firstSect 		EQU 		diskBuffer+4      		; low sector number needed on a track
sectMap   		EQU 		firstSect+2       		; bit map of sectors needed on a track
firstFSeq 		EQU 		sectMap+4     			; first file seq # for current r/w request
fBlksDone 		EQU 		firstFSeq+2       		; file blocks done previous to this track
readErrInit   	EQU 		fBlksDone+2       		; init value, read error countdown cntr
readErrCnt		EQU 		readErrInit+1     		; read error countdown cntr
recalInit 		EQU 		readErrCnt+1      		; init value, recal count
recalCnt  		EQU 		recalInit+1       		; recal count
wrgSectInit   	EQU 		recalCnt+1    			; init value, wrong sector countdown cnt
wrgSectCnt		EQU 		wrgSectInit+1     		; wrong sector countdown cnt
badSpdInit		EQU 		wrgSectCnt+1      		; init value, bad speed
badSpdCnt 		EQU 		badSpdInit+1      		; bad speed countdown value
command   		EQU 		badSpdCnt+1       		; I/O command
headSettle		EQU 		command+2     			; disk head settle time (@100usec)
spdChgTime		EQU 		headSettle+2      		; motor speed change time (@100usec)
pwrOnTime 		EQU 		spdChgTime+2      		; * power-on wait time (@100usec)
pwrOffTime		EQU 		pwrOnTime+2       		; * power down time (@1/2sec)
seekTime  		EQU 		pwrOffTime+2      		; seek wait time (@100usec)
sectTime  		EQU 		seekTime+2    			; * sector time (@100usec)
dskVBLTime		EQU 		sectTime+2    			; VBL task time (@16ms)
ejectTime 		EQU 		dskVBLTime+2      		; Eject time (@100usec)
ckDelta   		EQU 		ejectTime+2       		; delta time before speed recheck
ejectWait 		EQU 		ckDelta+4     			; VBL times after eject to ignore DIP

; Format/Verify code reuses some of these fields as follows:

gapSync   		EQU 		sectMap       			; (2) start with 7 groups of intersector sync
twoSided  		EQU 		command       			; (1) set non-zero for 2-sided format
sectSave  		EQU 		firstSect     			; (2) SectMpSave must follow
sectMapSave   	EQU 		sectMap       			; (8) uses SectMap, FirstFSeq, FBlksDone
sectCnt   		EQU 		firstSect     			; (2) loop counter . . .

;_______________________________________;
;
; (2) Drive-specific vars.

drvLclLth 		EQU 		66
drive1			EQU 		ejectWait+2       		; * internal drive variables
drive2			EQU 		drive1+drvLclLth  		; * external drive variables

  				IF  		onMacPP | onHcMac THEN
drive3			EQU 		drive2+drvLclLth  		; * real external for MacPP
floppyLclEnd  	EQU 		drive3+drvLclLth
  				ELSEIF		onMac | onNuMac | onMac32 THEN
floppyLclEnd  	EQU 		drive2+drvLclLth
  				ENDIF

track 			EQU 		0         				; current track location (used for spd)
writeProt 		EQU 		2         				; * bit7=1=write-protected
diskInPlace   	EQU 		3         				; * $FC-$FF= just ejected,
; 0=no disk in place,1=DIP,2=clamped
installed 		EQU 		4         				; * 0=don't know, 1=inst., $FF=not inst.
sides 			EQU 		5         				; * bit7=0=1 sided
dqel  			EQU 		6         				; drive queue element for this drive
driveQLink		EQU 		6
driveQVers		EQU 		10
driveSize 		EQU 		18        				; drive block size (DCD only!)
twoSideFmt		EQU 		18        				; * non-zero if 2-sided format
newIntf   		EQU 		19        				; $FF if new interface, $00 for old 
driveErrs 		EQU 		20        				; drive soft errs
driveS1   		EQU 		20        				; drive block size (high word)
driveType 		EQU 		22        				; old OffSpeed (no longer supported)
driveManf 		EQU 		24
driveChar 		EQU 		26

  				IF  		supportsMFM THEN
mfmDrive  		EQU 		22        				;$FF=SuperDrive, $00=400K or 800K GCR
mfmDisk   		EQU 		23        				;$FF=MFM, $00=GCR or unformatted
twoMegFmt 		EQU 		24        				;$FF=2 meg MFM (1440K), $00=1 meg (720K)
  				ENDIF

driveMisc 		EQU 		27
spdAdjCnt 		EQU 		24        				; speed adjust count this drive
trkSpeedTbl   	EQU 		26        				; 5-entry track speed table
tSTblCode 		EQU 		0         				; first is speed code
tSTblDelta		EQU 		2         				; 2% speed code delta
tSTblTicks		EQU 		4         				; longword last time checked tick cnt
trkSTEnd  		EQU 		66        				; end of drive vars

;_______________________________________;
;
; (3) More driver local vars.

wakeTimeCnt   	EQU 		floppyLclEnd      		; WakeUp remainder count
saveRegs  		EQU 		wakeTimeCnt+2     		; * wakeup routine saves D3-D7,A3-A6 here
tagBufPtr 		EQU 		saveRegs+36       		; if non-zero, pointer to separate
														; buffer for file tags . . .
tagBufOS  		EQU 		tagBufPtr+4       		; temp offset into buffer
diskErrs  		EQU 		tagBufOS+2    			; global soft errors
passThru  		EQU 		diskErrs+2    			; 0 if pass thru on external port
  				IF  		supportsMFM THEN
hasSuperDrives	EQU 		passThru+1    			; $FF if at least 1 SuperDrive connected
curSector 		EQU 		hasSuperDrives+1  		; current sector being read/written 
  				ELSE
sonyExtra 		EQU 		passThru+1    			; extra byte
curSector 		EQU 		sonyExtra+1       		; current sector being read/written 
  				ENDIF

tcRdEnable		EQU 		curSector+2       		; (byte) set non-zero to activate reads into cache
tcInstalled   	EQU 		tcRdEnable+1      		; (byte) non-zero when caching is installed and on
tcDrive   		EQU 		tcInstalled+1     		; (word) drive number of cache blks (zero to inval)
tcSideTrack   	EQU 		tcDrive+2     			; (word) side/track of cache blocks 
tcSectMap 		EQU 		tcSideTrack+2     		; (long) bitmap of sectors currently cached 
tcBuffer  		EQU 		tcSectMap+4       		; (long) pointer to track cache buffer (512+12)*12
tcNumCached   	EQU 		tcBuffer+4    			; (word) number read into cache 
tcNumUsed 		EQU 		tcNumCached+2     		; (word actual number used
lastDrive 		EQU 		tcNumUsed+2       		; (word) set at CkDrvNum to previous value of Drive
timeOutDrive  	EQU 		lastDrive+4       		; (word) set at PowerDown to value of Drive 
; Above value should have been +2 since lastDrive is a word.
timeQEl   		EQU 		timeOutDrive+2    		; a time queue element

  				IF  		onMac | (onMac32 and (NOT(onMacPP | onHcMac | forROM))) THEN
nextGZProc		EQU 		timeQEl+tmQSize-2     	; (long) saved old GZ proc
; Above had been +tmQSize, but that changed from $C to $E.
sonyVarEnd		SET 		nextGZProc+4      		; end of sony vars excluding DCD
  				ELSE
nextGZProc		EQU 		timeQEl+tmQSize   		; (long) saved old GZ proc
driveXlat 		EQU 		nextGZProc + 4    		; drive translate table (GetDrive,DiskOpen)
drvTblPtr 		EQU 		driveXlat+((maxDrvNum+1)*2) 
														; (long) pointer to DrvTbl to use
sonyVarEnd		SET 		drvTblPtr+4
  				ENDIF

  				IF  		supportsMFM THEN
isSWIM			EQU 		sonyVarEnd    			;FDC type: $FF=SWIM, $00=IWM
mfmMode   		EQU 		isSWIM+1      			;Current register set selected: $FF=SWIM, $00=IWM
sonyVarEnd		SET 		mfmMode+1     			; end of sony vars excluding DCD
  				ENDIF

  				IF  		onHcMac THEN
chipState 		EQU 		sonyVarEnd    			; Byte holds flag to indicate IWM on or off
sonyVarEnd		SET 		chipState+2       		; end of sony vars excluding DCD
  				ENDIF

  				IF  		hasPwrControls | hasPowerMgr THEN		; <1.1>
chipState 		EQU 		sonyVarEnd    			; Bit7 - saved VIA dir, 6..0 - pmgr enables <1.1>
diskSleepQEL	EQU			chipState+2				; sleep/wakeup queue element
sonyVarEnd		SET 		diskSleepQEL+SleepqRec.SleepqSize	; end of sony vars excluding DCD
  				ENDIF

				IF			forDiskDup THEN
fmtParams		EQU			sonyVarEnd				;pointer to parameters for special format command
gcrFmtByte		EQU			fmtParams+4				; saved GCR format byte for duplicator
clock32Mhz		EQU			gcrFmtByte+2			; ( 1) Clock speed: $FF=32Mhz, $00=16Mhz				<H3><SM4>
DisableRetries	EQU			clock32Mhz+1			; ( 1) $FF=Don't perform retries, $00=normal			<H4><SM4>
sonyVarEnd		SET			DisableRetries+1
				ENDIF


  				IF  		onMac|onNuMacDCD THEN
;_______________________________________;
;
; (4) Direct-connect driver locals.

tagSize   		EQU 		20        				; 20 bytes tags/block
dcdLclLth 		EQU 		28        				; (use fields through DriveMisc)
drive3			EQU 		sonyVarEnd    			; first DCD 
drive4			EQU 		drive3+dcdLclLth  		; second DCD
drive5			EQU 		drive4+dcdLclLth  		; third DCD
drive6			EQU 		drive5+dcdLclLth  		; fourth DCD

  				ENDIF

  				IF  		onMacPP|onHcMac THEN
;_______________________________________;
;
; (4) Direct-connect driver locals.

tagSize   		EQU 		20        				; 20 bytes tags/block
dcdLclLth 		EQU 		28        				; (use fields through DriveMisc)
drive4			EQU 		sonyVarEnd    			; first DCD
drive5			EQU 		drive4+dcdLclLth  		; second DCD
drive6			EQU 		drive5+dcdLclLth  		; third DCD
  				ENDIF

  				IF  		onMac|onMacPP|onHcMac|onNuMacDCD THEN


stsRtnAddr		EQU 		drive6+dcdLclLth  		; DCD status call return address
dcdCmd			EQU 		stsRtnAddr+4      		; command byte to DCD
response  		EQU 		dcdCmd        			; response byte (command+$80)
seqNum			EQU 		response+1    			; mb sequence number (sys commands only)
status			EQU 		seqNum+1      			; returned status bytes
startBlock		EQU 		status        			; starting block # (in commands)
driveOut  		EQU 		startBlock+3      		; we send drive number in this field
driveIn   		EQU 		status+2      			; low 6 bits
tagBytes  		EQU 		status+4      			; tag bytes get stuffed here temporarily
devType   		EQU 		tagBytes      			; first 20 bytes of status are written
devManufctr   	EQU 		devType+2     			; in the 20-byte tag buffer
devChar   		EQU 		devManufctr+2
devBlks   		EQU 		devChar       			; low 3 bytes of this longword
devSpares 		EQU 		devChar+4
devBadBlks		EQU 		devSpares+2
devMisc   		EQU 		devBadBlks+2      		; 8 bytes misc
bufSize   		EQU 		tagBytes+tagSize  		; number of bytes/block
lastStatus		EQU 		bufSize+4     			; last status returned
lastResult		EQU 		lastStatus+4      		; error type
dcdFlags  		EQU 		lastResult+1      		; flag of whether we've done a reset
chkTime   		EQU 		dcdFlags+1    			; 100usec check ready count
maxTime   		EQU 		chkTime+2     			; maximum number of checks
stsBuffer 		EQU 		maxTime+2     			; 512 bytes of status
devReserve		EQU 		stsBuffer
devIcon   		EQU 		devReserve+44
devFiller 		EQU 		devIcon+256       		; 32 bytes for optional name
diskVarLth		EQU 		devFiller+32
stsBufSize		EQU 		diskVarLth-stsBuffer

  				ELSE  								;
diskVarLth		EQU 		sonyVarEnd    			;
  				ENDIF 								;

; device characteristics byte:

devChEject		EQU 		4         				; ejectable if 1
devChWP   		EQU 		3         				; write protected if 1
devChIcon 		EQU 		2         				; icon available if 1


;_______________________________________;
; ;
; Drive Constants: ;
;_______________________________________;


dqSides   		EQU 		-1        				; Bit 7 of this byte: 0=single-sided Sony, 1=double sided
dqInstall 		EQU 		-2        				; 0=unknown, 1=installed, FF=no disk
dqDIP 			EQU 		-3        				; $FC-$FF = disk just ejected,
; 0 = no disk in place
; 1 = disk in place
; 2 = disk has been read
; >8 = non-ejectable disk
dqWrPrt   		EQU 		-4        				; Bit 7 of this byte: 1=disk is write protected.

dqManEjBit		EQU			5						; bit 5 of the dqInstall byte is set after  <SM5> <BH 03Aug93>
													; installation for a manual-eject drive
;_______________________________________;
;
; (1) Floppy drive constants (tuneable).

kSeekTime 		EQU 		120       				; 12 ms trk-to-trk
kHdSetTime		EQU			100*10					; 100 ms head settle time								<H6><SM4>
kEjectTime		EQU 		7500      				; .75 seconds eject time
kEjectWait		EQU 		-4        				; - number of VBL calls after eject before dip check
kSectTime 		EQU 		100       				; minimum sector time in 100 us increments (10 ms)
kPowerOn  		EQU 		4000      				; read/write powerup time in 100 us increments
kRWPOff   		EQU 		5         				; read/write power off time (in 1/2 seconds)
kDskVBLTime   	EQU 		30        				; happens every 1/2 second
kSpdChgTime   	EQU 		1500      				; speed change wait time = 150ms
kCkDelta  		EQU 		14400     				; speed check delta time (in 1/60 sec) (4 min)

;_______________________________________;
;
; (2) Floppy drive sense/control constants.
; (ca1-ca0-sel-ca2).

dirLAdr   		EQU 		0         				; dirtn low
dirHAdr   		EQU 		1
rdDtaAdr  		EQU 		1         				; side 0 read data
rdDta1Adr 		EQU 		3         				; side 1 read data
stepLAdr  		EQU 		4         				; step low and step sense address
stepHAdr  		EQU 		5
  				IF  		supportsMFM THEN
mfmModeAdr		EQU 		6         				;Switch drive into MFM (constant) mode
gcrModeAdr		EQU 		7         				;Switch drive into GCR (variable) mode
  				ENDIF
mtrOnAdr  		EQU 		8
mtrOffAdr 		EQU 		9
ejectLAdr 		EQU 		12
ejectHAdr 		EQU 		13
dipAdr			EQU 		2         				; disk in place sense address
mfmDrvAdr 		EQU 		5         				;1=SuperDrive, 0=400K or 800K GCR
wrProtAdr 		EQU 		6         				; write protect sense address
sidesAdr  		EQU 		9         				; sense for number of sides
tk0Adr			EQU 		10        				; track 0 sense address
readyAdr  		EQU 		11        				; /Ready sense address
drvExstAdr		EQU 		13        				; sense=0 when a drive is connected
tachAdr   		EQU 		14        				; tach feedback sense address
newIntfAdr		EQU 		15        				; implements ready handshake if 1
  				IF  		supportsMFM THEN
twoMegAdr 		EQU 		15        				;0=1 meg disk, 1=2 meg disk
  				ENDIF

;_______________________________________;
;
; (3) Floppy drive formatting constants.

fmtByte   		EQU 		$02       				; 2-1 interleave, single-sided
fmt2Byte  		EQU 		$22       				; 2-1 interleave, double-sided
mustFindCt		EQU 		1500
minSync   		EQU 		4         				; min number of inter-sector sync groups
  				IF  		supportsMFM THEN

numSDFmts 		EQU 		3         				; 2 GCR + 1 MFM single-density
numDDFmts 		EQU 		1         				; 1 MFM double-density format
  				ELSE
numSDFmts 		EQU 		2         				; 2 GCR single density formats
  				ENDIF

  				IF  		onMac|onMacPP|onHcMac|onNuMacDCD THEN
;_______________________________________;
;
; (4) Direct-connect drive constants.

blkSize   		EQU 		512       				; 512 bytes data/block
syncByte  		EQU 		$AA       				; Sync byte for start of transmission
nonZerStat		EQU 		1
comErr			EQU 		2

; New HD20 error codes

wrtHsLw   		EQU 		$10       				; HSHK low before starting
wrtHSLwTO 		EQU 		$11       				; Time out waiting for HSHK to go low
wrtHSHighTO   	EQU 		$13       				; Time out waiting for HSHK to go high
rdHsHi			EQU 		$20       				; HSHK high before starting
rdSyncTO  		EQU 		$21       				; Time out waiting for sync ($AA) bye
rdGroupTO 		EQU 		$22       				; Time out waiting for group
rdHoffSyncTO  	EQU 		$24       				; Time out waiting for sync after holdoff
rdHsHiTO  		EQU 		$25       				; Time out waiting for HSHK high
rdChksumErr   	EQU 		$26       				; Checksum error on response packet
invalidResp   	EQU 		$30       				; First byte in response packet was wrong
sqncNumErr		EQU 		$31       				; Sequence number in response packet was wrong
dNumberErr		EQU 		$32       				; Drive number in response packet was wrong
noResp			EQU 		$40       				; No response packet ever received

; LastStatus

opFailed  		EQU 		24        				; bit to test for operation failed
bChksum   		EQU 		30        				; bit number for checksum error

; DCDFlags

resetonce 		EQU 		0
retryonce 		EQU 		1
maxTries  		EQU 		4         				; max # times to try command
tSeekChk  		EQU 		10        				; check during a seek every 1 ms
tSeekMax  		EQU 		10000     				; max time for seek = 10 secs
tStsChk   		EQU 		10        				; check during a status every 1 ms
tStsMax   		EQU 		10000     				; max time for status = 10 secs
tQuickTime		EQU 		100
tNextChk  		EQU 		7         				; check for next block after 700 µsec
tNextMax  		EQU 		10000     				; max time for next block = 7 secs
tFVChk			EQU 		100       				; check during fmt/vfy every 10 ms
tFVMax			EQU 		18000     				; max time for fmt/vfy = 3 minutes
tRstAssert		EQU 		1000      				; assert reset for 100 msec
tRstSettle		EQU 		20000     				; 2 sec wait for busy to settle
tRstChk   		EQU 		100       				; check during reset every 10 ms
tRstMax   		EQU 		1600      				; max time for reset = 16 seconds

; DCD sense/cntl addr (ca1-ca0-sel-ca2)

dcdExist  		EQU 		5         				; /Exist (/Sides=/DrvIn=1 also)
dcdReset  		EQU 		1         				; for 1ms resets DCD controller
  				ENDIF 								;

;_______________________________________;
; ;
; Driver Constants: ;
;_______________________________________;

;_______________________________________;
;
; (1) Driver Control codes.

verifyCC  		EQU 		5         				; 'verify' control code
formatCC  		EQU 		6         				; 'format' control code
tagBufCC  		EQU 		8         				; 'set tag buffer' control code
tCacheCC  		EQU 		9         				; 'track cache' control 
iconIDCC  		EQU 		20        				; 'get icon id' control code
iconCC			EQU 		21        				; 'get icon' control code
iconLogCC 		EQU 		22        				; 'get logical icon' code
infoCC			EQU 		23        				; 'get drive info' code
RetriesCC		EQU			17232					; 'Enable/Disable Retries' code			<H4><SM4>
  				IF  		forDiskDup THEN
FmtCopyCC 		EQU 		$5343     				;one-pass format/copy/verify for disk duplicator
  				ENDIF
GetRawDataCC	EQU			18244					; 'get raw track data' code				<1.5>

; (2) Driver Status codes.

fmtLstCode		EQU 		6         				;Returns a list of disk formats
  				IF  		supportsMFM THEN
mfmStsCode		EQU 		10        				;'Get MFM status' status code
  				ENDIF
SpdChkSts		EQU		17232						; Checks disk speed at a given track	<H5><SM4>
  				IF  		forDiskDup THEN
DupVerSts 		EQU 		$4456     				;disk duplicator version supported (to match features)
FmtByteSts		EQU 		$5343     				;return address header format byte
  				ENDIF 								; for disk duplicator


;_______________________________________;
;
; Driver Vectors: ;
;_______________________________________;

;_______________________________________;
;
; (1) Location of disk routine vectors.

jFigTrkSpd		EQU 		DiskVars
jDiskPrime		EQU 		jFigTrkSpd+4
jRdAddr   		EQU 		jDiskPrime+4
jRdData   		EQU 		jRdAddr+4
jWrData   		EQU 		jRdData+4
jSeek 			EQU 		jWrData+4
jSetUpPoll		EQU 		jSeek+4
jRecal			EQU 		jSetUpPoll+4
jControl  		EQU 		jRecal+4
jWakeUp   		EQU 		jControl+4
jReSeek   		EQU 		jWakeUp+4
jMakeSpdTbl   	EQU 		jReSeek+4
jAdrDisk  		EQU 		jMakeSpdTbl+4
jSetSpeed 		EQU 		jAdrDisk+4
niblTbl   		EQU 		jSetSpeed+4
jDiskSel  		EQU 		$B40      				; (long) vector to .Sony DiskSelect routine 
jSendCmd  		EQU 		$B44      				; (long) vector to .Sony DCD SendCmd routine
jDCDReset 		EQU 		$B48      				; (long) vector to .Sony DCD DCDReset routine

  				IF  		supportsMFM THEN
jMRdAddr  		EQU 		$680      				; (long) vector to MFM MRdAddr
jMRdData  		EQU 		jMRdAddr+4    			; (long) vector to MFM MRdData
jMWrData  		EQU 		jMRdData+4    			; (long) vector to MFM MWrData
  				ENDIF

  				ENDIF 								;end exclusion of private information

	ENDIF	; ...already included 